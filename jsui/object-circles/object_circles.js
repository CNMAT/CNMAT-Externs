/*three circle interpolation control*/inlets = 1;outlets = 3;sketch.default2d();var vbrgb = [1.,1.,1.,0.];var vfrgb = [0.5,0.5,0.5,0.];var test = 0.;var grav = 999.;var hand = 0;var hand2 = 0;var osc = "/oops"//zone objectfunction zone (n, x, y, d, r, g, b, a, h,q){	this.name = n;	this.x = x;	this.y = y;	this.diam = d;	this.red = r;	this.green = g;	this.blue = b;	this.alpha = a;	this.height = h;	this.grav = q;}//prototype zone with draw methodnew zone ("zero", -0.3, 0.3, 0.5, 0.9, 0.1, 0.1, 0.4, 1.,0.);zone.prototype.draw = drawzone;//an array of starter zonesvar all_zones= new Array();all_zones[0] = new zone ("zero", -0.3, 0.3, 0.5, 0.9, 0.1, 0.1, 0.4, 1.,0.);all_zones[1] = new zone ("one", 0.3, 0.3, 0.5, 0.1, 0.9, 0.1, 0.4, 1.,0.);all_zones[2] = new zone ("two", 0., -0.3, 0.5, 0.1, 0.1, 0.9, 0.4, 1.,0.);//initial drawingclear();for (i = 0 ; i < all_zones.length ; i ++)	all_zones[i].draw();refresh();function clear(){	with (sketch) {		glclearcolor(vbrgb[0],vbrgb[1],vbrgb[2],vbrgb[3]);		glclear();	}}function drawzone(){	with (sketch) {		moveto (this.x, this.y);		glcolor (this.red, this.green, this.blue, this.alpha);		circle (this.diam);	}}function bang(){	clear();	for (i = 0 ; i < all_zones.length ; i ++)	all_zones[i].draw();	refresh();}function fsaa(v){	sketch.fsaa = v;	bang();}function frgb(r,g,b){	vfrgb[0] = r/255.;	vfrgb[1] = g/255.;	vfrgb[2] = b/255.;	draw();	refresh();}function center(c,x,y){	all_zones[c].x = x;	all_zones[c].y = y;	bang();	refresh();}function diam(c,d){	all_zones[c].diam = d;	bang();	refresh();}function rgb(c,r,g,b){	all_zones[c].red = r/255.;	all_zones[c].blue = g/255.;	all_zones[c].green = b/255.;	bang();	refresh();}function brgb(r,g,b){	vbrgb[0] = r/255.;	vbrgb[1] = g/255.;	vbrgb[2] = b/255.;	draw();	refresh();}// all mouse events are of the form: // onevent <x>, <y>, <button down>, <cmd(PC ctrl)>, <shift>, <capslock>, <option>, <ctrl(PC rbutton)>// if you don't care about the additonal modifiers args, you can simply leave them out.// one potentially confusing thing is that mouse events are in absolute screen coordinates, // with (0,0) as left top, and (width,height) as right, bottom, while drawing // coordinates are in relative world coordinates, with (0,0) as the center, +1 top, -1 bottom,// and x coordinates using a uniform scale based on the y coordinates. to convert between screen // and world coordinates, use sketch.screentoworld(x,y) and sketch.worldtoscreen(x,y,z).function setvalueof(x,y){	list(x,y);}function getvalueof(){	var a = new Array(vx,vy);		return a;}function onresize(w,h){	draw();	refresh();}onresize.local = 1; //privatefunction onclick(x,y,but,cmd,shift,capslock,option,ctrl){	ondrag (x,y,but,cmd,shift,capslock,option,ctrl);}onclick.local = 1; //privatefunction ondrag (x,y,but,cmd,shift,capslock,option,ctrl){	worldx = sketch.screentoworld(x,y)[0]; 	worldy = sketch.screentoworld(x,y)[1];if (shift) { //add the correct gravities to the zone objects	for (i = 0 ; i < all_zones.length ; i ++)	all_zones[i].grav = Math.sqrt(Math.pow((worldx - all_zones[i].x),2.) + Math.pow ((worldy - all_zones[i].y),2.));	//find the smallest one (centers then diameters)	grav = 999.	for (i = 0 ; i < all_zones.length ; i ++)	if (all_zones[i].grav <  grav)		{	hand = i;	hand2 = 0;	grav = all_zones[i].grav;}for (i = 0 ; i < all_zones.length ; i ++)	if (Math.abs((all_zones[i].diam/2.) - (all_zones[i].grav)) <  grav)		{	hand = i;	hand2 = 1;	grav = (all_zones[i].grav - all_zones[i].diam);}else { hand2 = 0 }osc = "/grav";outlet(2, osc, grav);osc = "/hand2";outlet(2, osc, hand2);if (hand2 < 1)	{	all_zones[hand].x = worldx;	all_zones[hand].y = worldy;	osc = "/" + all_zones[hand].name+"/x" ;	outlet(2, osc, all_zones[hand].x);	osc = "/" + all_zones[hand].name+"/y";	outlet(2, osc, all_zones[hand].y);		bang();}else if (hand2 = 1)	{	all_zones[hand].diam = all_zones[hand].grav;	osc = "/" + all_zones[hand].name+"/d" ;	outlet(2, osc, all_zones[hand].diam);		bang();}}else{	bang();	outlet(0, worldx);	outlet(1,worldy);}}ondrag.local = 1;  //private