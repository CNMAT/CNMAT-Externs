/*three circle interpolation control*/inlets = 1;outlets = 3;sketch.default2d();var vbrgb = [0.,0.,0.,0.];var vfrgb = [0.5,0.5,0.5,0.];var test = 0.;var grav = 999.;var dgrav = 999.;var shownames = 1;var myfontsize = 14;var hand = 0;var hand2 = 0;var osc = "/oops"//zone objectfunction zone (n, x, y, d, r, g, b, a, h, q){	this.name = n;	this.x = x;	this.y = y;	this.diam = d;	this.red = r;	this.green = g;	this.blue = b;	this.alpha = a;	this.height = h;	this.grav = q;}//prototype zone with draw methodnew zone ("zero", -0.3, 0.3, 0.5, 0.9, 0.1, 0.1, 0.4, 1.,0.);zone.prototype.draw = drawzone;//an array of starter zonesvar all_zones= new Array();all_zones[0] = new zone ("zero", -0.3, 0.3, 0.5, 1., 1., 0., 0.6, 1.,0.);all_zones[1] = new zone ("one", 0.3, 0.3, 0.5, 0, 1., 0.1, 0.6, 1.,0.);all_zones[2] = new zone ("two", 0., -0.3, 0.5, 0.7, 0.7, 0.7, 0.6, 1.,0.);//initial drawingclear();for (i = 0 ; i < all_zones.length ; i ++)	all_zones[i].draw();refresh();function clear(){	with (sketch) 	{		glclearcolor(vbrgb[0],vbrgb[1],vbrgb[2],vbrgb[3]);		glclear();	}}function drawzone(){	with (sketch) 	{		moveto (this.x, this.y);		glcolor (this.red, this.green, this.blue, this.alpha);		circle (this.diam);		if (shownames == 1)		{			textalign("center","center");			fontsize(myfontsize);					moveto (this.x, this.y);			sketch.text (this.name);		}			}}function bang(){	clear();	for (i = 0 ; i < all_zones.length ; i ++)	all_zones[i].draw();	refresh();}function fsaa(v){	sketch.fsaa = v;	bang();}function names(v){	shownames = v;	bang();}function frgb(r,g,b){	vfrgb[0] = r/255.;	vfrgb[1] = g/255.;	vfrgb[2] = b/255.;	draw();	refresh();}function center(c,x,y){	all_zones[c].x = x;	all_zones[c].y = y;	bang();	refresh();}function diam(c,d){	all_zones[c].diam = d;	bang();	refresh();}function name(c,d){	all_zones[c].name = d;	bang();	refresh();}function fontsize(v){	myfontsize = v;	bang();	refresh();}function rgb(c,r,g,b){	all_zones[c].red = r/255.;	all_zones[c].green = g/255.;	all_zones[c].blue = b/255.;	bang();	refresh();}function brgb(r,g,b){	vbrgb[0] = r/255.;	vbrgb[1] = g/255.;	vbrgb[2] = b/255.;	bang();}// all mouse events are of the form: // onevent <x>, <y>, <button down>, <cmd(PC ctrl)>, <shift>, <capslock>, <option>, <ctrl(PC rbutton)>// if you don't care about the additonal modifiers args, you can simply leave them out.// one potentially confusing thing is that mouse events are in absolute screen coordinates, // with (0,0) as left top, and (width,height) as right, bottom, while drawing // coordinates are in relative world coordinates, with (0,0) as the center, +1 top, -1 bottom,// and x coordinates using a uniform scale based on the y coordinates. to convert between screen // and world coordinates, use sketch.screentoworld(x,y) and sketch.worldtoscreen(x,y,z).function onresize(w,h){	bang();	refresh();}onresize.local = 1; //privatefunction onclick(x,y,but,cmd,shift,capslock,option,ctrl){	worldx = sketch.screentoworld(x,y)[0]; 	worldy = sketch.screentoworld(x,y)[1];	if (shift) 	{ //add the correct gravities to the zone objects		for (i = 0 ; i < all_zones.length ; i ++)		{		all_zones[i].grav = Math.sqrt(Math.pow((worldx - all_zones[i].x),2.) + Math.pow ((worldy - all_zones[i].y),2.))		}	//find the smallest one (centers then diameters)		grav = 999.		for (i = 0 ; i < all_zones.length ; i ++)		{			if (all_zones[i].grav <  grav)			{				hand = i;				hand2 = 0;				grav = all_zones[i].grav;			}		}		dgrav = grav		for (j = 0 ; j < all_zones.length ; j ++)		 {			if (Math.abs((all_zones[j].diam) - (all_zones[j].grav)) <  dgrav)			{				hand = j;				hand2 = 1;				dgrav = (Math.abs(all_zones[j].diam - all_zones[j].grav));			}		}	}}onclick.local = 1; //privatefunction ondrag (x,y,but,cmd,shift,capslock,option,ctrl){	worldx = sketch.screentoworld(x,y)[0]; 	worldy = sketch.screentoworld(x,y)[1];	if (shift)	{		if (hand2 == 0)		{			all_zones[hand].x = worldx;			all_zones[hand].y = worldy;			osc = "/" + all_zones[hand].name+"/x" ;			outlet(2, osc, all_zones[hand].x);			osc = "/" + all_zones[hand].name+"/y";			outlet(2, osc, all_zones[hand].y);				bang();		}		if (hand2 == 1)		{			all_zones[hand].diam = Math.sqrt(Math.pow((worldx - all_zones[hand].x),2.) + Math.pow ((worldy - all_zones[hand].y),2.));			osc = "/" + all_zones[hand].name+"/d" ;			outlet(2, osc, all_zones[hand].diam);			bang();		}	}	bang();	outlet(0, worldx);	outlet(1,worldy);}ondrag.local = 1;  //privateetetee