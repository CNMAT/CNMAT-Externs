#include "ext.h"#include "z_dsp.h"#include "fft.h"#include <string.h>#include <math.h>#define RES_ID	7085#define VERSION "1.0.1"//version 1.0.1 Port to Universal Binary, assist strings, changed free() routine to call dsp_free() *before* freeing memory. - mzed#define NUMBAND 25 // at 44100 Hz only#define t_floatarg double#define DEFAULT_FS 44100#define DB_REF 96#define SFM_MAX 60//#define TWOPI 6.28318530717952646f#define FOURPI 12.56637061435917292f#define THREEPI 9.424777960769379f#define DEFBUFSIZE 1024		// Default signal buffer size#define MAXPADDING 16		// Maximum FFT zero padding (in # of FFT sizes)#define MAXDELAY 512		// Maximum initial delay (in # of signal vectors)#define DEFDELAY 0			// Default initial delay (in # of signal vectors) #define DEFNPITCH 1			// Default number of pitches to output#define DEFNPEAKANAL 20		// Default number of peaks to analyse #define DEFNPEAKOUT 0		// Default number of peaks to output#define DEFNPARTIAL 7		// Default number of partials for threshold#define DEFAMPLO 40			// Default Low attack threshold#define DEFAMPHI 50			// Default High attack threshold#define DEFVIBTIME 50		// Default vibrato update rate#define DEFVIBDEPTH 0.5		// Default vibrato depth (1 semitone)#define MINFREQINBINS 5     // Minimum frequency in bins for reliable output#define HISTORY 20			// Number of old values kept#define MAXNPITCH 3			// Maximum number of pitch outputs#define MAXNPEAK 100		// Maximum number of peaks#define MINBIN 3			// Minimum FFT bin#define BINPEROCT 48		// bins per octave#define MINBW 0.03f			// consider BW >= 0.03 FFT bins#define GLISS 0.7f			// Pitch glissando#define BINAMPCOEFF 30.0f	// Don't know how to describe this#define DBFUDGE 30.8f		// Don't know how to describe this#define BPEROOVERLOG2 69.24936196f // BINSPEROCT/log(2)#define FACTORTOBINS 275.00292191f // 4/(pow(2.0,1/48.0)-1)#define BINGUARD 10			// extra bins to throw in front#define PARTIALDEVIANCE 0.023f // acceptable partial detuning in %#define LOGTODB 4.34294481903f // 10/log(10)#define KNOCKTHRESH 4e5f 	// don't know how to describe this#define MAXHIST 3		    // find N hottest peaks in histogram#define POWERTHRES 1e-9f	// Total power minimum threshold#define FIDDLEDB_REF 100.0f	// Fiddle dB Reference#define MAXNUMSAMP 512		// Maximum number of samples allowed possible for half-cosine#define DEF_TIME 150		// Default time for the half-cosine decay#define DEF_LATENCY 150		// Default Latency to wait before activating a pitch segmentation #define MAXTIME 2000		// Maximum time allowed for the half-cosine decay#define DEFSEGTHRESH 100	// Default segmentation threshold#define MAXTHRESH 500		// Maximum possible Threshold (in dB)#define MAXLATENCY 1000		// Maximum possible latency (in ms)#define HANNING_W(i,ac) ((1.0f - cos((i * TWOPI) / (ac - 1.0f))) * 0.5f)#define HAMMING_W(i,ac) (0.54f - 0.46f * cos((TWOPI * i) / (ac - 1.0f)))#define BLACK62_W(i,ac) (0.44859f - 0.49364f * cos(TWOPI * ((i - 1.0f)/(ac - 1.0f))) + 0.05677f * cos(FOURPI * ((i - 1.0f)/(ac - 1.0f))))#define BLACK70_W(i,ac) (0.42323f - 0.49755f * cos(TWOPI * ((i - 1.0f)/(ac - 1.0f))) + 0.07922f * cos(FOURPI * ((i - 1.0f)/(ac - 1.0f))))#define BLACK74_W(i,ac) (0.402217f - 0.49703f * cos(TWOPI * ((i - 1.0f)/(ac - 1.0f))) + 0.09892f * cos(FOURPI * ((i - 1.0f)/(ac - 1.0f))) - 0.00188 * cos(THREEPI * ((i - 1.0f)/(ac - 1.0f))))#define BLACK92_W(i,ac) (0.35875f - 0.48829f * cos(TWOPI * ((i - 1.0f)/(ac - 1.0f))) + 0.14128f * cos(FOURPI * ((i - 1.0f)/(ac - 1.0f))) - 0.01168 * cos(THREEPI * ((i - 1.0f)/(ac - 1.0f))))#define MINF(A,B) ((A < B) ? A : B)#define ftom pitch_ftom#define mtof pitch_mtof#define flog log#define fexp exp#define fsqrt sqrtstatic t_float pitch_partialonset[] = {	0, 48,76.0782000346154967102, 96, 111.45254855459339269887, 124.07820003461549671089,	134.75303625876499715823, 144, 152.15640006923099342109, 159.45254855459339269887,	166.05271769459026829915, 172.07820003461549671088, 177.62110647077242370064,	182.75303625876499715892, 187.53074858920888940907, 192};static t_int pitch_intpartialonset[] = {	0, 48, 76, 96, 111, 124, 135, 144, 152, 159, 166, 172, 178, 183, 188, 192};#define NPARTIALONSET ((t_int)(sizeof(pitch_partialonset)/sizeof(t_float)))void *analyzer_class;enum {Recta = 0, Hann, Hamm, Black62, Black70, Black74, Black92};#define DEFWIN	Black70		// Default window// Some structures from Fiddle~typedef struct peakout {    // a peak for output    t_float po_freq;		// frequency in Hz    t_float po_amp;	    	// amplitude} t_peakout;typedef struct peak {	    // a peak for analysis    t_float p_freq;		    // frequency in bins    t_float p_width;		// peak width in bins    t_float p_pow;		    // peak power    t_float p_loudness;	    // 4th root of power    t_float *p_fp;		    // pointer back to spectrum} t_peak;typedef struct histopeak {	// Histogram for peaks    t_float h_pitch;		// estimated pitch    t_float h_value;		// value of peak    t_float h_loud;		    // combined strength of found partials    t_int h_index;		    // index of bin holding peak    t_int h_used;			// true if an x_hist entry points here} t_histopeak;typedef struct pitchhist {		// struct for keeping history by pitch    t_float h_pitch;		    // pitch to output    t_float h_amps[HISTORY];	// past amplitudes    t_float h_pitches[HISTORY]; // past pitches    t_float h_noted;		    // last pitch output    t_int h_age;			    // number of frames pitch has been there    t_histopeak *h_wherefrom;	// new histogram peak to incorporate} t_pitchhist;// The actual main external structuretypedef struct _analyzer {	t_pxobject x_obj;	t_float x_Fs;			// Sample rate	t_int x_overlap;		// Number of overlaping samples	t_int x_hop;			// Number of non-overlaping samples	t_int x_window;			// Type of window		char x_winName[32];		// Window name		t_int x_delay;			// Vector size delay before to start feeding the buffer	t_int x_counter;		// Counter that goes with the vector size delay	// Variables from Fiddle~	t_int x_npitch;			// Number of pitches to output	t_int x_npeakanal;		// Number of peaks to analyse	t_int x_npeakout;		// Number of peaks to output    t_int x_histphase;		// Phase into amplitude history vector    t_pitchhist x_hist[MAXNPITCH]; // History of current pitches    t_float x_dbs[HISTORY];	// DB history, indexed by "histphase"    t_int x_dbage;		    // number of bins DB has met threshold	t_peak x_peaklist[MAXNPEAK+1]; // This was originally a local buffer in pitch_getit	t_histopeak x_histvec[MAXHIST];// This one too			// Parameters from fiddle~    t_float x_amplo;    t_float x_amphi;    t_int x_vibtime;    t_int x_vibbins;    t_float x_vibdepth;    t_float x_npartial;	// Half-Cosine and Segmentation	t_float *cosine;		// Buffer containing the cosine data	t_int numSamps;			// Number of samples for the half-cosine	t_float *oldData;		// Buffer of last Filtered data	t_float *heldData;		// Buffer of last Un-filtered data	t_int *index;			// Buffer of indexes in the Cosine buffer    t_float *OldEnerBark;	// Old Energy Bark buffer    t_float oldCookPitch;	// Old Cooked pitch for derivative    t_float curCookPitch;	// Current Cooked pitch for derivative    t_float segThresh;		// Threshold for segmentation    t_int segReady;			// Flag for segmentation (ready = 1, on-hold = 0)	t_int segPitchReady;	// Same as segReady but for pitch    t_int x_usePitch;		// Flag for the use of Pitch in the segmentation or not    t_int max_wait;			// Min latency to wait before activating a pitch segmentation (in vector sizes)	t_int curr_wait;		// State of the wait	t_float x_latency;		// for Print	t_float x_time;			// for Print		// Buffers    t_int *Buf1;			// buffer 1 : Use buffers of integers to copy faster    t_int *Buf2;			// buffer 2    t_float *BufFFT;		// FFT buffer    t_float *BufPower;		// Power spectrum buffer    t_float *WindFFT;		// Window of FFTSize    t_float *memFFT;		// fft.c memory space    t_peakout *peakBuf;		// Spectral peaks for output    t_float *histBuf;		// Histogram Buffer    t_int BufSize;			// FFT buffer size	t_int FFTSize;			// Size of FFT    t_int BufWritePos;		// Where to write in buffer    t_float *BufBark;		// Bark buffer	t_int *BufSizeBark;		// Number of bins per band	void *x_clock;			// Use a clock for outputs... (better than Qelem)    void *x_segBangout;		// Outlet for Onset detection from the segmentation    void *x_noteout;		// Outlet for cooked pitch    void *x_peakout;		// Outlet for sinusoidal decomposition    void *x_pitchout;		// Outlet for raw pitch & amplitude	void *x_outseg;			// Outlet for the amplitude derivative	void *x_segBangOut;		// Outlet for segmentation bangs	} t_analyzer;t_symbol *ps_rectangular, *ps_hanning, *ps_hamming, *ps_black62, *ps_black70, *ps_black74, *ps_black92, *ps_noPitch, *ps_Pitch;t_int *analyzer_perform(t_int *w);void analyzer_dsp(t_analyzer *x, t_signal **sp, short *connect);void analyzer_float(t_analyzer *x, double f);void analyzer_int(t_analyzer *x, long n);void analyzer_assist(t_analyzer *x, void *b, long m, long a, char *s);void analyzer_print(t_analyzer *x);void analyzer_amprange(t_analyzer *x, t_floatarg amplo, t_floatarg amphi);void analyzer_vibrato(t_analyzer *x, t_floatarg vibtime, t_floatarg vibdepth);void analyzer_npartial(t_analyzer *x, t_floatarg npartial);void segment_latency(t_analyzer *x, t_float latency);void segment_cosine(t_analyzer *x, t_float time);void segment_thresh(t_analyzer *x, t_float thresh);void segment_clear(t_analyzer *x, Symbol *sym);void readBufSize(t_analyzer *x, t_atom *argv);void readx_overlap(t_analyzer *x, t_atom *argv);void readFFTSize(t_analyzer *x, t_atom *argv);void readx_window(t_analyzer *x, t_atom *argv);void readx_delay(t_analyzer *x, t_atom *argv);void readx_npeakanal(t_analyzer *x, t_atom *argv);void read_segThresh(t_analyzer *x, t_atom *argv);void readx_usePitch(t_analyzer *x, t_atom *argv);void *analyzer_new(t_symbol *s, short argc, t_atom *argv);void analyzer_free(t_analyzer *x);void analyzer_tick(t_analyzer *x);t_float pitch_mtof(t_float f);t_float pitch_ftom(t_float f);t_int pitch_ilog2(t_int n);void pitch_getit(t_analyzer *x); // modified fiddle main functionvoid main(void) {    post("Segment~ object version " VERSION " by Tristan Jehan");    post("copyright © 2001 Massachusetts Institute of Technology");    post("Internal pitch tracker based on Miller Puckette's fiddle~");    post("copyright © 1997-1999 Music Department UCSD");	post("  ");	ps_rectangular = gensym("rectangular");	ps_hanning = gensym("hanning");	ps_hamming = gensym("hamming");	ps_black62 = gensym("black62");	ps_black70 = gensym("black70");	ps_black74 = gensym("black74");	ps_black92 = gensym("black92");	ps_noPitch = gensym("nopitch");	ps_Pitch   = gensym("pitch");	setup( (Messlist **)&analyzer_class, (method)analyzer_new, (method)analyzer_free, (short)sizeof(t_analyzer), 0L, A_GIMME, 0);			addmess((method)analyzer_dsp, "dsp", A_CANT, 0);	addmess((method)analyzer_assist, "assist", A_CANT, 0);    addmess((method)analyzer_print, "print", 0);    addmess((method)analyzer_amprange, "amp-range", A_FLOAT, A_FLOAT, 0);    addmess((method)analyzer_vibrato, "vibrato", A_FLOAT, A_FLOAT, 0);   	addmess((method)analyzer_npartial, "npartial", A_FLOAT, 0);   	addmess((method)segment_cosine, "time", A_FLOAT, 0);   	addmess((method)segment_latency, "wait", A_FLOAT, 0);   	addmess((method)segment_thresh, "thresh", A_FLOAT, 0);	addmess((method)segment_clear, "clear", 0);	addfloat((method)analyzer_float);	addint((method)analyzer_int);	dsp_initclass();	rescopy('STR#', RES_ID);}t_int *analyzer_perform(t_int *w) {	t_float *in = (t_float *)(w[1]);	t_analyzer *x = (t_analyzer *)(w[2]);	t_int n = (int)(w[3]);	t_int *myintin = (t_int *)in; 				// Copy integers rather than floats -> faster	t_int *myintBufFFT = (t_int *)(x->BufFFT);	// We assume sizeof(float) == sizeof(int) though	t_int i, index = 0, cpt = n, maxindex;	t_int overlapindex = x->BufSize - x->x_overlap;	t_int *TmpBuf = x->Buf1;			    if (x->x_obj.z_disabled)    	goto skip;	if (x->x_counter < 1) {			// Copy input samples into FFT buffer			while ((x->BufWritePos < x->BufSize) && (cpt > 0)) {			x->Buf1[x->BufWritePos] = myintin[index];			x->BufWritePos++;			index++;			cpt--;		}			// When Buffer is full...		if (x->BufWritePos >= x->BufSize) {						// Save overlapping samples into Buffer 2			for (i=0; i<x->x_overlap; i++) 				x->Buf2[i] = x->Buf1[overlapindex+i];			maxindex = n - index + x->x_overlap;			// Copy the rest of incoming samples into Buffer 2			for (i=x->x_overlap; i<maxindex; i++) {				x->Buf2[i] = myintin[index];				index++;			}					x->BufWritePos = maxindex;													// Make a copy of Buffer 1 into Buffer FFT for computation outside the perform function			for (i=0; i<x->BufSize; i++) 				myintBufFFT[i] = x->Buf1[i];			// Go for the FFT outside the perform function with a delay of 0 ms!			clock_delay(x->x_clock,0);					// Swap buffers			x->Buf1 = x->Buf2;			x->Buf2 = TmpBuf;		}	} else {		x->x_counter--;	}	skip:		return (w+4);}void analyzer_dsp(t_analyzer *x, t_signal **sp, short *connect) {	int vs = sys_getblksize();	// Initializing the delay counter	x->x_counter = x->x_delay;	x->segReady = 0; // Set it to 0 because when turning on audio, there's always an onset.	x->segPitchReady = 0; // Set it to 0 because when turning on audio, there's always an onset of Pitch.	if (vs > x->BufSize) post("Segment~: You need to use a smaller signal vector size...");	else if (connect[0]) dsp_add(analyzer_perform, 3, sp[0]->s_vec, x, sp[0]->s_n);}void analyzer_float(t_analyzer *x, double f) {	int n = (t_int)(f * x->x_Fs/1000.0f); 	analyzer_int(x, n);}void analyzer_int(t_analyzer *x, long n) {	t_int vs = sys_getblksize();	x->x_hop = n; 	if (x->x_hop < vs) {		post("Segment~: You can't overlap so much...");		x->x_hop = vs;	} else if (x->x_hop > x->BufSize) {		x->x_hop = x->BufSize;	}	x->x_overlap = x->BufSize - x->x_hop;	}void analyzer_assist(t_analyzer *x, void *b, long m, long a, char *s) { if (m == ASSIST_INLET) {               sprintf(s, "(signal) audio to segment");			   }       else {		switch (a) {			case 0:			sprintf(s,"(bang) onsets");			break;		case 1:			sprintf(s,"(float) loudness variation function");			break;		case 2:			sprintf(s,"(float) continuous cooked MIDI pitch");			break;			}	}	//assist_string(RES_ID,m,a,1,2,s);}void analyzer_print(t_analyzer *x) {    post("time %.2f",  x->x_time);    post("thresh %.2f", x->segThresh);	if (x->x_usePitch == 1) {		post("amp-range %.2f %.2f",  x->x_amplo, x->x_amphi);		post("vibrato %d %.2f",  x->x_vibtime, x->x_vibdepth);		post("npartial %.2f",  x->x_npartial);    	post("wait %.2f", x->x_latency);	}    post(" ");}void analyzer_amprange(t_analyzer *x, t_floatarg amplo, t_floatarg amphi) {    if (amplo < 0) amplo = 0;    if (amphi < amplo) amphi = amplo + 1;    x->x_amplo = amplo;    x->x_amphi = amphi;}void analyzer_vibrato(t_analyzer *x, t_floatarg vibtime, t_floatarg vibdepth) {    if (vibtime < 0) vibtime = 0;    if (vibdepth <= 0) vibdepth = 1000;    x->x_vibtime = vibtime;    x->x_vibdepth = vibdepth;    x->x_vibbins = (t_int) (x->x_Fs * 0.001f * vibtime) / (x->BufSize - x->x_overlap);    if (x->x_vibbins >= HISTORY) x->x_vibbins = HISTORY - 1;    if (x->x_vibbins < 1) x->x_vibbins = 1;}void analyzer_npartial(t_analyzer *x, t_floatarg npartial) {    if (npartial < 0.1) npartial = 0.1;    x->x_npartial = npartial;}void readBufSize(t_analyzer *x, t_atom *argv) {    t_float ms2samp = x->x_Fs * 0.001f;    	if (argv[0].a_type == A_LONG) {		x->BufSize = argv[0].a_w.w_long; // Samples	} else if (argv[0].a_type == A_FLOAT) {		x->BufSize = (t_int)(argv[0].a_w.w_float * ms2samp); // Time in ms	} else {		x->BufSize = DEFBUFSIZE;	}}void readx_overlap(t_analyzer *x, t_atom *argv) {    t_float ms2samp = x->x_Fs * 0.001f;	if (argv[1].a_type == A_LONG) {		x->x_hop = argv[1].a_w.w_long; // Samples	} else if (argv[1].a_type == A_FLOAT) {		x->x_hop = (t_int)(argv[1].a_w.w_float * ms2samp); // Time in ms	} else {		x->x_hop = x->BufSize/2;	}	x->x_overlap = x->BufSize - x->x_hop;}void readFFTSize(t_analyzer *x, t_atom *argv) {    t_float ms2samp = x->x_Fs * 0.001f;    	if (argv[2].a_type == A_LONG) {		x->FFTSize = argv[2].a_w.w_long; // Samples	} else if (argv[2].a_type == A_FLOAT) {		x->FFTSize = (t_int)(argv[2].a_w.w_float * ms2samp); // Time in ms	} else {		x->FFTSize = x->BufSize;	}}void readx_window(t_analyzer *x, t_atom *argv) {	if (argv[3].a_w.w_sym == ps_rectangular) {		x->x_window = Recta;	} else if (argv[3].a_w.w_sym == ps_hanning) {		x->x_window = Hann;	} else if (argv[3].a_w.w_sym == ps_hamming) {		x->x_window = Hamm;	} else if (argv[3].a_w.w_sym == ps_black62) {		x->x_window = Black62;	} else if (argv[3].a_w.w_sym == ps_black70) {		x->x_window = Black70;	} else if (argv[3].a_w.w_sym == ps_black74) {		x->x_window = Black74;	} else if (argv[3].a_w.w_sym == ps_black92) {		x->x_window = Black92;	} else {		x->x_window = DEFWIN;	}}void readx_delay(t_analyzer *x, t_atom *argv) {    	if ((argv[4].a_type == A_LONG) && (argv[4].a_w.w_long >= 0) && (argv[4].a_w.w_long < MAXDELAY)) {		x->x_delay = argv[4].a_w.w_long;	} else if ((argv[4].a_type == A_FLOAT) && (argv[4].a_w.w_float >= 0) && (argv[4].a_w.w_float < MAXDELAY)) {		x->x_delay = (t_int)(argv[4].a_w.w_float);	} else {		post("Segment~: 'delay' argument may be out of range... Choosing default...");		x->x_delay = DEFDELAY;	}}void read_segThresh(t_analyzer *x, t_atom *argv) {    	if ((argv[5].a_type == A_LONG) && (argv[5].a_w.w_long >= 0)) {		x->segThresh = (t_float) argv[5].a_w.w_long;	} else if ((argv[5].a_type == A_FLOAT) && (argv[5].a_w.w_float >= 0)) {		x->segThresh = argv[5].a_w.w_float;	} else {		post("Segment~: choose a positive threshold...");		x->segThresh = DEFSEGTHRESH;	}	if (x->segThresh > MAXTHRESH) {		post("Segment~: threshold too high. Set it to %d", MAXTHRESH);		x->segThresh = MAXTHRESH;	}}void readx_usePitch(t_analyzer *x, t_atom *argv) {	if (argv[6].a_w.w_sym == ps_noPitch) {		x->x_usePitch = 0;	} else if (argv[6].a_w.w_sym == ps_Pitch) {		x->x_usePitch = 1;	} else {		x->x_usePitch = 0;	}}void readx_npeakanal(t_analyzer *x, t_atom *argv) {    	if ((argv[7].a_type == A_LONG) && (argv[7].a_w.w_long >= 0) && (argv[7].a_w.w_long <= MAXNPEAK)) {		x->x_npeakanal = argv[7].a_w.w_long;	} else if ((argv[7].a_type == A_FLOAT) && (argv[7].a_w.w_float >= 0) && (argv[7].a_w.w_float <= MAXNPEAK)) {		x->x_npeakanal = (t_int)(argv[7].a_w.w_float);	} else {		post("Segment~: '# of peaks to find' argument may be out of range... Choosing default...");		x->x_npeakanal = DEFNPEAKANAL;	}}void *analyzer_new(t_symbol *s, short argc, t_atom *argv) {	t_int i, j, band=0, oldband=0, sizeband=0;	t_int vs = sys_getblksize(); // get vector size	double freq = 0.0f, oldfreq = 0.0f;    t_analyzer *x = (t_analyzer *)newobject(analyzer_class);    dsp_setup((t_pxobject *)x,1); // one inlet		x->x_clock = clock_new(x,(method)analyzer_tick);	x->x_Fs = sys_getsr();	x->BufWritePos = 0;	x->segReady = 0;	x->segPitchReady = 0;			// From fiddle~    x->x_histphase = 0;    x->x_dbage = 0;    x->x_amplo = DEFAMPLO;    x->x_amphi = DEFAMPHI;    x->curCookPitch = 0.f;    x->oldCookPitch = 0.f;			// More initializations from Fiddle~    for (i=0; i<MAXNPITCH; i++) {		x->x_hist[i].h_pitch = x->x_hist[i].h_noted = 0.0f;		x->x_hist[i].h_age = 0;		x->x_hist[i].h_wherefrom = NULL;				for (j=0; j<HISTORY; j++)	    	x->x_hist[i].h_amps[j] = x->x_hist[i].h_pitches[j] = 0.0f;    }            for (i=0; i<HISTORY; i++)     	x->x_dbs[i] = 0.0f;	switch (argc) { // Read arguments		case 0: 			x->BufSize = DEFBUFSIZE;			x->x_overlap = x->BufSize/2;			x->x_hop = x->BufSize/2;			x->FFTSize = DEFBUFSIZE;			x->x_window = DEFWIN;			x->x_delay = DEFDELAY;			x->x_npitch = DEFNPITCH;			x->x_npeakanal = DEFNPEAKANAL;			x->x_npeakout = DEFNPEAKOUT;			x->segThresh = DEFSEGTHRESH;			x->x_usePitch = 0;			break;		case 1:			readBufSize(x,argv);			x->x_overlap = x->BufSize/2;			x->x_hop = x->BufSize/2;			x->FFTSize = x->BufSize;			x->x_window = DEFWIN;			x->x_delay = DEFDELAY;			x->x_npitch = DEFNPITCH;			x->x_npeakanal = DEFNPEAKANAL;			x->x_npeakout = DEFNPEAKOUT;			x->segThresh = DEFSEGTHRESH;			x->x_usePitch = 0;			break;		case 2:			readBufSize(x,argv);			readx_overlap(x,argv);					x->FFTSize = x->BufSize;			x->x_window = DEFWIN;			x->x_delay = DEFDELAY;			x->x_npitch = DEFNPITCH;			x->x_npeakanal = DEFNPEAKANAL;			x->x_npeakout = DEFNPEAKOUT;			x->segThresh = DEFSEGTHRESH;			x->x_usePitch = 0;			break;		case 3:			readBufSize(x,argv);			readx_overlap(x,argv);					readFFTSize(x,argv);			x->x_window = DEFWIN;			x->x_delay = DEFDELAY;			x->x_npitch = DEFNPITCH;			x->x_npeakanal = DEFNPEAKANAL;			x->x_npeakout = DEFNPEAKOUT;			x->segThresh = DEFSEGTHRESH;			x->x_usePitch = 0;			break;		case 4:			readBufSize(x,argv);			readx_overlap(x,argv);					readFFTSize(x,argv);			readx_window(x,argv);			x->x_delay = DEFDELAY;			x->x_npitch = DEFNPITCH;			x->x_npeakanal = DEFNPEAKANAL;			x->x_npeakout = DEFNPEAKOUT;			x->segThresh = DEFSEGTHRESH;			x->x_usePitch = 0;			break;		case 5:			readBufSize(x,argv);			readx_overlap(x,argv);					readFFTSize(x,argv);			readx_window(x,argv);			readx_delay(x,argv);			x->x_npitch = DEFNPITCH;			x->x_npeakanal = DEFNPEAKANAL;			x->x_npeakout = DEFNPEAKOUT;			x->segThresh = DEFSEGTHRESH;			x->x_usePitch = 0;			break;		case 6:			readBufSize(x,argv);			readx_overlap(x,argv);					readFFTSize(x,argv);			readx_window(x,argv);			readx_delay(x,argv);			x->x_npitch = DEFNPITCH;			x->x_npeakanal = DEFNPEAKANAL;			x->x_npeakout = DEFNPEAKOUT;			read_segThresh(x,argv);			x->x_usePitch = 0;			break;		case 7:			readBufSize(x,argv);			readx_overlap(x,argv);					readFFTSize(x,argv);			readx_window(x,argv);			readx_delay(x,argv);			x->x_npitch = DEFNPITCH;			x->x_npeakanal = DEFNPEAKANAL;			x->x_npeakout = DEFNPEAKOUT;			read_segThresh(x,argv);			readx_usePitch(x,argv);			break;		default:			readBufSize(x,argv);			readx_overlap(x,argv);						readFFTSize(x,argv);			readx_window(x,argv);			readx_delay(x,argv);			x->x_npitch = DEFNPITCH;			x->x_npeakout = DEFNPEAKOUT;			read_segThresh(x,argv);			readx_usePitch(x,argv);			readx_npeakanal(x,argv);			break;	}			if (x->x_npeakout > x->x_npeakanal) {		post("Segment~: You can't output more peaks than you pick...");		x->x_npeakout = x->x_npeakanal;	}		// Just storing the name of the window	switch(x->x_window) {		case 0:			strcpy(x->x_winName,"rectangular");			break;		case 1:			strcpy(x->x_winName,"hanning");			break;				case 2:			strcpy(x->x_winName,"hamming");			break;				case 3:			strcpy(x->x_winName,"black62");			break;				case 4:			strcpy(x->x_winName,"black70");			break;				case 5:			strcpy(x->x_winName,"black74");			break;				case 6:			strcpy(x->x_winName,"black92");			break;				default:			strcpy(x->x_winName,"black62");	}		if (x->BufSize < vs) { 		post("Segment~: Buffer size is smaller than the vector size, %d",vs);		x->BufSize = vs;	} else if (x->BufSize > 65536) {		post("Segment~: Maximum FFT size is 65536 samples");		x->BufSize = 65536;	}		if (x->FFTSize < x->BufSize) {		post("Segment~: FFT size is at least the buffer size, %d",x->BufSize);		x->FFTSize = x->BufSize;	}	if ((x->FFTSize > vs) && (x->FFTSize < 128))  x->FFTSize = 128;	else if ((x->FFTSize > 128) && (x->FFTSize < 256)) x->FFTSize = 256;	else if ((x->FFTSize > 256) && (x->FFTSize < 512)) x->FFTSize = 512;	else if ((x->FFTSize > 512) && (x->FFTSize < 1024)) x->FFTSize = 1024;	else if ((x->FFTSize > 1024) && (x->FFTSize < 2048)) x->FFTSize = 2048;	else if ((x->FFTSize > 2048) && (x->FFTSize < 4096)) x->FFTSize = 4096;	else if ((x->FFTSize > 8192) && (x->FFTSize < 16384)) x->FFTSize = 16384;	else if ((x->FFTSize > 16384) && (x->FFTSize < 32768)) x->FFTSize = 32768;	else if ((x->FFTSize > 32768) && (x->FFTSize < 65536)) x->FFTSize = 65536;	else if (x->FFTSize > 65536) {		post("Segment~: Maximum FFT size is 65536 samples");		x->FFTSize = 65536;	}		// Overlap case	if (x->x_overlap > x->BufSize-vs) {		post("Segment~: You can't overlap so much...");		x->x_overlap = x->BufSize-vs;	} else if (x->x_overlap < 1)		x->x_overlap = 0; 	x->x_hop = x->BufSize - x->x_overlap;	post("--- Segment~ ---");		post("	Buffer size = %d",x->BufSize);	post("	Hop size = %d",x->x_hop);	post("	FFT size = %d",x->FFTSize);	post("	Window type = %s",x->x_winName);	post("	Initial delay = %d",x->x_delay);	post("	Segmentation threshold = %.2f",x->segThresh);	if (x->x_usePitch == 1) {		post("  Use Pitch for segmenting");		post("	Number of peaks to search = %d",x->x_npeakanal);	} else {		post("  Don't use Pitch for segmenting");	}	post("  ");	// Allocate memory	x->Buf1 = (t_int*) NewPtr(x->BufSize * sizeof(t_float)); // Careful these are pointers to integers but the content is floats	x->Buf2 = (t_int*) NewPtr(x->BufSize * sizeof(t_float));	x->BufFFT = (t_float*) NewPtr(x->FFTSize * sizeof(t_float));	x->BufPower = (t_float*) NewPtr((x->FFTSize/2) * sizeof(t_float));	x->WindFFT = (t_float*) NewPtr(x->BufSize * sizeof(t_float));	x->memFFT = (t_float*) NewPtr(CMAX * x->FFTSize * sizeof(t_float)); // memory allocated for fft twiddle	x->peakBuf = (t_peakout*) NewPtr(x->x_npeakout * sizeof(t_peakout)); // from Fiddle~	x->histBuf = (t_float*) NewPtr((x->FFTSize + BINGUARD) * sizeof(t_float)); // for Fiddle~	x->cosine = (t_float*) NewPtr(MAXNUMSAMP * sizeof(*x->cosine));	x->oldData = (t_float*) NewPtr(NUMBAND * sizeof(*x->oldData));	x->heldData = (t_float*) NewPtr(NUMBAND * sizeof(*x->heldData));	x->index = (t_int*) NewPtr(NUMBAND * sizeof(*x->index));	if (x->x_Fs != DEFAULT_FS) {		error("Segment~: WARNING !!! Object set for 44.1 KHz only");		return;	} else {		x->OldEnerBark = (t_float*) NewPtr(NUMBAND * sizeof(t_float));		x->BufBark = (t_float*) NewPtr(2*NUMBAND * sizeof(t_float));		x->BufSizeBark = (t_int*) NewPtr(NUMBAND * sizeof(t_int));	}		for(i=0; i<NUMBAND; i++) {		x->OldEnerBark[i] = 0.0f;	}	if (x->x_usePitch == 1) {		x->x_noteout = floatout((t_analyzer *)x); // one outlet for MIDI & frequency cooked pitch	}	// Ouput values for segmentation	x->x_outseg = floatout((t_object *)x); // one outlet	// Make bang outlet for onset detection	x->x_segBangOut = bangout((t_object *)x);	// Compute and store Windows	if (x->x_window != Recta) {				switch (x->x_window) {			case Hann: 	for (i=0; i<x->BufSize; ++i)							x->WindFFT[i] = HANNING_W(i,x->BufSize); 						break;			case Hamm:	for (i=0; i<x->BufSize; ++i)							x->WindFFT[i] = HAMMING_W(i,x->BufSize);						break;			case Black62: for (i=0; i<x->BufSize; ++i)							x->WindFFT[i] = BLACK62_W(i,x->BufSize);						break;			case Black70: for (i=0; i<x->BufSize; ++i)							x->WindFFT[i] = BLACK70_W(i,x->BufSize);						break;			case Black74: for (i=0; i<x->BufSize; ++i)							x->WindFFT[i] = BLACK74_W(i,x->BufSize);						break;			case Black92: for (i=0; i<x->BufSize; ++i)							x->WindFFT[i] = BLACK92_W(i,x->BufSize);						break;		}	} else {		for (i=0; i<x->BufSize; ++i) { // Just in case			x->WindFFT[i] = 1.0f;		}	}	// More initializations from Fiddle~	for (i=0; i<x->x_npeakout; i++)		x->peakBuf[i].po_freq = x->peakBuf[i].po_amp = 0.0f;	analyzer_vibrato(x, DEFVIBTIME, DEFVIBDEPTH);	segment_latency(x, DEF_LATENCY);	analyzer_npartial(x, DEFNPARTIAL);		// Compute and store half cosine	segment_cosine(x,DEF_TIME);		// Initialize half-cosines for each channel	for (i=0; i<NUMBAND; i++) {    	x->oldData[i] = 0.0f;    	x->heldData[i] = 0.0f;    	x->index[i] = 0;    }	// Compute and store Bark scale		j = 1;		x->BufBark[0] = 0.0f;	for (i=0; i<x->FFTSize/2; i++) {		freq = (i*x->x_Fs)/x->FFTSize;		band = floor(13*atan(0.76*freq/1000) + 3.5*atan((freq/7500)*(freq/7500)));		if (oldband != band) {			x->BufBark[j] = oldfreq;			x->BufBark[j+1] = freq;			x->BufSizeBark[j/2] = sizeband;			j+=2;			sizeband = 0;		}		oldband = band;		oldfreq = freq;		sizeband++;	}	x->BufBark[2*NUMBAND-1] = freq;	x->BufSizeBark[NUMBAND-1] = sizeband;    return (x);}void  analyzer_free(t_analyzer *x) {	dsp_free((t_pxobject *)x);		if (x->Buf1 != NULL) DisposePtr((char *) x->Buf1);	if (x->Buf2 != NULL) DisposePtr((char *) x->Buf2);	if (x->BufFFT != NULL) DisposePtr((char *) x->BufFFT);	if (x->BufPower != NULL) DisposePtr((char *) x->BufPower);	if (x->WindFFT != NULL) DisposePtr((char *) x->WindFFT);	if (x->memFFT != NULL) DisposePtr((char *) x->memFFT);	if (x->peakBuf != NULL) DisposePtr((char *) x->peakBuf);	if (x->histBuf != NULL) DisposePtr((char *) x->histBuf);	if (x->x_clock != NULL) freeobject((t_object *)x->x_clock);	if (x->OldEnerBark != NULL) DisposePtr((char *) x->OldEnerBark);	if (x->BufBark != NULL) DisposePtr((char *) x->BufBark);	if (x->BufSizeBark != NULL) DisposePtr((char *) x->BufSizeBark);	if (x->cosine != NULL) DisposePtr((char *) x->cosine);	if (x->oldData != NULL) DisposePtr((char *) x->oldData);	if (x->heldData != NULL) DisposePtr((char *) x->heldData);	if (x->index != NULL) DisposePtr((char *) x->index);	}void segment_cosine(t_analyzer *x, t_float time) {	int i;		if (time > MAXTIME) {		time = MAXTIME;		post("Segment~: maximum time allowed is %d ms",MAXTIME);	} else if (time < 0) {		time = 0;		post("Segment~: set time to 0 ms");	}	x->x_time = time; 	x->numSamps = (int) round((time / (x->x_hop * 1000.0f/x->x_Fs)));	for (i=0; i<x->numSamps; i++) {		x->cosine[i] = 0.5f * cosf(PI * (i+1)/x->numSamps) + 0.5f;	}}void segment_latency(t_analyzer *x, t_float latency) {	int i;		if (latency > MAXLATENCY) {		latency = MAXLATENCY;		post("Segment~: maximum latency allowed is %d ms",MAXLATENCY);	} else if (latency < 0) {		latency = 0;		post("Segment~: set latency to 0 ms");	}	x->x_latency = latency;	x->max_wait = (int) round((latency / (x->x_hop * 1000.0f/x->x_Fs)) + 0.5);}void segment_thresh(t_analyzer *x, t_float thresh) {	int i;		if (thresh > MAXTHRESH) {		thresh = MAXTHRESH;		post("Segment~: maximum threshold allowed is %d",MAXTHRESH);	} else if (thresh < 0) {		thresh = 0;		post("Segment~: thresh can't be negative: set thresh to 0");	}	x->segThresh = (t_float) thresh;}void segment_clear(t_analyzer *x, Symbol *sym){	int i;	x->segReady = 1;	x->segPitchReady = 1;		for (i=0; i<NUMBAND; i++) {    	x->oldData[i] = 0.0f;    	x->heldData[i] = 0.0f;    	x->index[i] = 0;			}	}void analyzer_tick(t_analyzer *x) {	t_int i, index=0, cpt;	t_float bark = 0.0f, linbark = 0.0f, loud = 0.0f, bright = 0.0f; 	t_float sumSpectrum = 0.0f, SFM = 0.0f, sumDeriv = 0.0f;	t_float deriv, newData, instantDeriv, pitchDeriv;	t_int halfFFTSize = x->FFTSize/2;	t_float FsOverFFTSize = x->x_Fs/x->FFTSize;	t_float FsOverBarkSize = x->x_Fs/(2.0f*NUMBAND);	double prod = 1.0f, sum = 0.0f;	double invNumBand = 0.04f;    t_pitchhist *ph;		// Zero padding	for (i=x->BufSize; i<x->FFTSize; i++)		x->BufFFT[i] = 0.0f;	// Window the samples	if (x->x_window != Recta)		for (i=0; i<x->BufSize; ++i)			x->BufFFT[i] *= x->WindFFT[i];				// FFT	fftRealfast(x->FFTSize, x->BufFFT, x->memFFT);			// Squared Absolute (power)	for (i=0; i<x->FFTSize; i+=2) 		x->BufPower[i/2] = (x->BufFFT[i] * x->BufFFT[i]) + (x->BufFFT[i+1] * x->BufFFT[i+1]);		// Go into fiddle~ code	if (x->x_usePitch == 1) {		pitch_getit(x);		if (x->curr_wait > 0) {			x->curr_wait--;		} else {			x->segPitchReady = 1;		}	}				// Output Band energy (find brightness #1 and Segmentation)	for (i=0; i<NUMBAND; i++) {		cpt = x->BufSizeBark[i];		bark = 0.0f;		while (cpt > 0) {			bark += x->BufPower[index];			cpt--;			index++;		}		bark = bark/x->BufSizeBark[i];		// For Segmentation		linbark = bark; // keep a version in linear scale for linear plot		if (bark) {				bark = 10*log10(bark/DB_REF); 		} else { 			bark = -DB_REF;					 		} 		deriv = bark - x->OldEnerBark[i];		x->OldEnerBark[i] = bark;		newData = x->heldData[i] * x->cosine[x->index[i]]; 		if (newData > deriv) {			x->oldData[i] = newData;		} else {			x->oldData[i] = deriv;			x->heldData[i] = deriv;			x->index[i] = 0;		}		if (x->index[i] < x->numSamps-1) {			x->index[i]++;		}		 		sumDeriv += x->oldData[i] * (i+1); // Weight higher frequencies linearly		 	}	instantDeriv = sumDeriv/NUMBAND;	if (x->segReady == 0 && instantDeriv < x->segThresh) {		x->segReady = 1;	}	    outlet_float(x->x_outseg, instantDeriv);    // Output segmentation bang     if (instantDeriv > x->segThresh && x->segReady) {		outlet_bang(x->x_segBangOut);		x->segReady = 0;		x->curr_wait = x->max_wait;		x->segPitchReady = 0;	}	if (x->x_usePitch == 1) {		ph = x->x_hist;		if (ph->h_pitch != 0.) {			x->curCookPitch = ph->h_pitch;		}		outlet_float(x->x_noteout, x->curCookPitch);		pitchDeriv = fabs(x->curCookPitch - x->oldCookPitch);		x->oldCookPitch = x->curCookPitch;				if (pitchDeriv > 0 && x->segPitchReady) {			outlet_bang(x->x_segBangOut);					x->curr_wait = x->max_wait;			x->segPitchReady = 0;		}	}}	// Convert from MIDI to Hz and Hz to MIDIt_float pitch_mtof(t_float f) {	return (8.17579891564f * exp(.0577622650f * f));}t_float pitch_ftom(t_float f) {	return (17.3123405046f * log(.12231220585f * f));}t_int pitch_ilog2(t_int n) {    t_int ret = -1;        while (n) {		n >>= 1;		ret++;    }    return (ret);}// This is the actual Fiddle~ codevoid pitch_getit(t_analyzer *x){    t_int i, j, k;    t_peak *pk1; // peaks found    t_peakout *pk2; // peaks to output    t_histopeak *hp1;    t_float power_spec = 0.0f, total_power = 0.0f, total_loudness = 0.0f, total_db = 0.0f;    t_float *fp1, *fp2;    t_float *spec = x->BufFFT, *powSpec = x->BufPower, threshold, mult;    t_int n = x->FFTSize/2;    t_int npitch, newphase, oldphase, npeak = 0;    t_int logn = pitch_ilog2(n);    t_float maxbin = BINPEROCT * (logn-2);    t_float hzperbin = x->x_Fs/x->FFTSize;    t_float coeff = x->FFTSize/(t_float)x->BufSize;    t_float *histogram = x->histBuf + BINGUARD;    t_int npeaktot = (x->x_npeakout > x->x_npeakanal ? x->x_npeakout : x->x_npeakanal);    t_pitchhist *phist;        // Circular buffer for History    oldphase = x->x_histphase;    newphase = x->x_histphase + 1;    if (newphase == HISTORY) newphase = 0;    x->x_histphase = newphase;	// Get spectrum power	for (i=0; i<n; i++)		power_spec += powSpec[i];			    	total_power = 4.0f * power_spec; // Compensate for fiddle~ power estimation (difference of 6 dB)    if (total_power > POWERTHRES) {		total_db = (FIDDLEDB_REF-DBFUDGE) + LOGTODB*flog(total_power/n); // dB power estimation of fiddle~		total_loudness = fsqrt(fsqrt(power_spec)); // Use the actual real estimation rather than fiddle~'s		if (total_db < 0) total_db = 0.0f;    } else {    	total_db = total_loudness = 0.0f;    }    	// Store new db in history vector    x->x_dbs[newphase] = total_db;	// Not enough power to find anything    if (total_db < x->x_amplo) goto nopow;	// search for peaks	pk1 = x->x_peaklist;		    for (i=MINBIN, fp1=spec+2*MINBIN, fp2=powSpec+MINBIN; (i<n-2) && (npeak<npeaktot); i++, fp1+=2, fp2++) {    	 		t_float height = fp2[0], h1 = fp2[-1], h2 = fp2[1]; // Bin power and adjacents		t_float totalfreq, pfreq, f1, f2, m, var, stdev;			if (height<h1 || height<h2 || h1*coeff<POWERTHRES*total_power || h2*coeff<POWERTHRES*total_power) continue; // Go to next    	// Use an informal phase vocoder to estimate the frequency		pfreq = ((fp1[-4] - fp1[4]) * (2.0f * fp1[0] - fp1[4] - fp1[-4]) +				 (fp1[-3] - fp1[5]) * (2.0f * fp1[1] - fp1[5] - fp1[-3])) / (2.0f * height);		        	// Do this for the two adjacent bins too		f1 = ((fp1[-6] - fp1[2]) * (2.0f * fp1[-2] - fp1[2] - fp1[-6]) +			  (fp1[-5] - fp1[3]) * (2.0f * fp1[-1] - fp1[3] - fp1[-5])) / (2.0f * h1) - 1;		f2 = ((fp1[-2] - fp1[6]) * (2.0f * fp1[2] - fp1[6] - fp1[-2]) +			  (fp1[-1] - fp1[7]) * (2.0f * fp1[3] - fp1[7] - fp1[-1])) / (2.0f * h2) + 1;    	// get sample mean and variance of the three		m = 0.333333f * (pfreq + f1 + f2);		var = 0.5f * ((pfreq-m)*(pfreq-m) + (f1-m)*(f1-m) + (f2-m)*(f2-m));		totalfreq = i + m;				// BAD HACK TO BE CHANGE IN NEXT VERSION !!!!		if (coeff > 1) {			switch ((t_int)coeff) {				case 2:					mult = 0.005;					break;				case 4:					mult = 0.125;					break;				case 8:					mult = 0.2;					break;				case 16:					mult = 0.25; // weird values found by trying to get npeak around 6-7					break;				default:					mult = 0.25;			}						threshold = KNOCKTHRESH * height * mult;		} else {			threshold = KNOCKTHRESH * height;		}		if ((var * total_power) > threshold || (var < 1e-30)) continue;		stdev = fsqrt(var);		if (totalfreq < 4) totalfreq = 4;				// Store the peak info in the list of peaks		pk1->p_width = stdev;		pk1->p_pow = height;		pk1->p_loudness = fsqrt(fsqrt(height));		pk1->p_fp = fp1;		pk1->p_freq = totalfreq;			npeak++;		pk1++;    } // end for		    // prepare the raw peaks for output    for (i=0, pk1=x->x_peaklist, pk2=x->peakBuf; i<npeak; i++, pk1++, pk2++) {    	    	t_float loudness = pk1->p_loudness;    	if (i>=x->x_npeakout) break;    	    	pk2->po_freq = hzperbin * pk1->p_freq;    	pk2->po_amp = (2.f/(t_float)n) * loudness * loudness * coeff;    }            // in case npeak < x->x_npeakout    for (; i<x->x_npeakout; i++, pk2++) pk2->po_amp = pk2->po_freq = 0;	// now, make a sort of "likelihood" spectrum. Proceeding in 48ths of an octave,  	// from 2 to n/2 (in bins), the likelihood of each pitch range is contributed	// to by every peak in peaklist that's an integer multiple of it in frequency    if (npeak > x->x_npeakanal) npeak = x->x_npeakanal; // max # peaks to analyze            // Initialize histogram buffer to 0    for (i=0, fp1=histogram; i<maxbin; i++) *fp1++ = 0.0f;    for (i=0, pk1=x->x_peaklist; i<npeak; i++, pk1++) {    		t_float pit = BPEROOVERLOG2 * flog(pk1->p_freq) - 96.0f;		t_float binbandwidth = FACTORTOBINS * pk1->p_width/pk1->p_freq;		t_float putbandwidth = (binbandwidth < 2 ? 2 : binbandwidth);		t_float weightbandwidth = (binbandwidth < 1.0f ? 1.0f : binbandwidth);		t_float weightamp = 4.0f * pk1->p_loudness / total_loudness;		for (j=0, fp2=pitch_partialonset; j<NPARTIALONSET; j++, fp2++) {	    	t_float bin = pit - *fp2;	    	if (bin<maxbin) {				t_float para, pphase, score = BINAMPCOEFF * weightamp / ((j+x->x_npartial) * weightbandwidth);				t_int firstbin = bin + 0.5f - 0.5f * putbandwidth;				t_int lastbin = bin + 0.5f + 0.5f * putbandwidth;				t_int ibw = lastbin - firstbin;				if (firstbin < -BINGUARD) break;				para = 1.0f / (putbandwidth * putbandwidth);				for (k=0, fp1=histogram+firstbin, pphase=firstbin-bin; k<=ibw; k++, fp1++, pphase+=1.0f)		    		*fp1 += score * (1.0f - para * pphase * pphase);	    	}		} // end for    } // end for          //post("npeaks = %d, %f",npeak,mult); // For debugging weird hack!!!       	// Next we find up to NPITCH strongest peaks in the histogram.	// If a peak is related to a stronger one via an interval in	// the pitch_partialonset array, we suppress it.    for (npitch=0; npitch<x->x_npitch; npitch++) {		t_int index;		t_float best;		if (npitch) {	    	for (best=0, index=-1, j=1; j<maxbin-1; j++) {				if ((histogram[j]>best) && (histogram[j]>histogram[j-1]) && (histogram[j]>histogram[j+1])) {		    		for (k=0; k<npitch; k++)						if (x->x_histvec[k].h_index == j) goto peaknogood;		    		for (k=0; k<NPARTIALONSET; k++) {						if ((j-pitch_intpartialonset[k]) < 0) break;						if (histogram[j-pitch_intpartialonset[k]] > histogram[j]) goto peaknogood;					}		    		for (k=0; k<NPARTIALONSET; k++) {						if (j+ pitch_intpartialonset[k] >= maxbin) break;						if (histogram[j+pitch_intpartialonset[k]] > histogram[j]) goto peaknogood;		    		}		    		index = j;		    		best = histogram[j];				}	    		peaknogood: ;	    	}		} else {			best = 0; 			index = -1;	    	for (j=0; j<maxbin; j++)				if (histogram[j] > best) {		    		index = j; 		    		best = histogram[j];		    	}		}		if (index < 0) break;			x->x_histvec[npitch].h_value = best;		x->x_histvec[npitch].h_index = index;    }       	// for each histogram peak, we now search back through the	// FFT peaks.  A peak is a pitch if either there are several	// harmonics that match it, or else if (a) the fundamental is	// present, and (b) the sum of the powers of the contributing peaks	// is at least 1/100 of the total power.	//	// A peak is a contributor if its frequency is within 25 cents of	// a partial from 1 to 16.	//	// Finally, we have to be at least 5 bins in frequency, which	// corresponds to 2-1/5 periods fitting in the analysis window.    for (i=0; i<npitch; i++) {    	t_float cumpow=0, cumstrength=0, freqnum=0, freqden=0;		t_int npartials=0,  nbelow8=0;	    // guessed-at frequency in bins		t_float putfreq = fexp((1.0f / BPEROOVERLOG2) * (x->x_histvec[i].h_index + 96.0f));			for (j=0; j<npeak; j++) {	    	t_float fpnum = x->x_peaklist[j].p_freq/putfreq;	    	t_int pnum = fpnum + 0.5f;	    	t_float fipnum = pnum;	    	t_float deviation;	    	    	if ((pnum>16) || (pnum<1)) continue;	    	    	deviation = 1.0f - fpnum/fipnum;	   		if ((deviation > -PARTIALDEVIANCE) && (deviation < PARTIALDEVIANCE)) {		 	// we figure this is a partial since it's within 1/4 of		 	// a halftone of a multiple of the putative frequency.				t_float stdev, weight;				npartials++;				if (pnum<8) nbelow8++;				cumpow += x->x_peaklist[j].p_pow;				cumstrength += fsqrt(fsqrt(x->x_peaklist[j].p_pow));				stdev = (x->x_peaklist[j].p_width > MINBW ? x->x_peaklist[j].p_width : MINBW);				weight = 1.0f / ((stdev*fipnum) * (stdev*fipnum));				freqden += weight;				freqnum += weight * x->x_peaklist[j].p_freq/fipnum;			    	} // end if		} // end for			if (((nbelow8<4) || (npartials<DEFNPARTIAL)) && (cumpow < (0.01f * total_power))) {			x->x_histvec[i].h_value = 0;		} else {	  	  	t_float pitchpow = (cumstrength * cumstrength * cumstrength * cumstrength);			t_float freqinbins = freqnum/freqden;					// check for minimum output frequency			if (freqinbins < MINFREQINBINS) {				x->x_histvec[i].h_value = 0;			} else {    		    // we passed all tests... save the values we got	    		x->x_histvec[i].h_pitch = ftom(hzperbin * freqnum/freqden);	    		x->x_histvec[i].h_loud = (FIDDLEDB_REF-DBFUDGE) + LOGTODB*flog(pitchpow*coeff/n);	    	}			} // end else    } // end for    	// Now try to find continuous pitch tracks that match the new pitches. 	// First mark each peak unmatched.    for (i=0, hp1=x->x_histvec; i<npitch; i++, hp1++)		hp1->h_used = 0;	// For each old pitch, try to match a new one to it.    for (i=0, phist=x->x_hist; i<x->x_npitch; i++, phist++) {		t_float thispitch = phist->h_pitches[oldphase];		phist->h_pitch = 0;	    // no output, thanks...		phist->h_wherefrom = 0;		if (thispitch == 0.0f) continue;		for (j=0, hp1=x->x_histvec; j<npitch; j++, hp1++)	    	if ((hp1->h_value > 0) && (hp1->h_pitch > thispitch - GLISS) && (hp1->h_pitch < thispitch + GLISS)) {	    		phist->h_wherefrom = hp1;	    		hp1->h_used = 1;			}    }        for (i=0, hp1=x->x_histvec; i<npitch; i++, hp1++)		if ((hp1->h_value > 0) && !hp1->h_used) {			for (j=0, phist=x->x_hist; j<x->x_npitch; j++, phist++)	    		if (!phist->h_wherefrom) {	    			phist->h_wherefrom = hp1;					phist->h_age = 0;					phist->h_noted = 0;					hp1->h_used = 1;					goto happy;				}				break;    			happy: ;    	} // end if    		// Copy the pitch info into the history vector    for (i=0, phist=x->x_hist; i<x->x_npitch; i++, phist++) {		if (phist->h_wherefrom) {			phist->h_amps[newphase] = phist->h_wherefrom->h_loud;			phist->h_pitches[newphase] = phist->h_wherefrom->h_pitch;			(phist->h_age)++;		} else {			phist->h_age = 0;			phist->h_amps[newphase] = phist->h_pitches[newphase] = 0;		}    } // end for    		// For each current frequency track, test for a new note using a	// stability criterion. Later perhaps we should also do as in	// pitch~ and check for unstable notes a posteriori when	// there's a new attack with no note found since the last onset;	// but what's an attack &/or onset when we're polyphonic?    for (i=0, phist=x->x_hist; i<x->x_npitch; i++, phist++) {    	// if we've found a pitch but we've now strayed from it, turn it off		if (phist->h_noted) {	    	if (phist->h_pitches[newphase] > phist->h_noted + x->x_vibdepth				|| phist->h_pitches[newphase] < phist->h_noted - x->x_vibdepth)				phist->h_noted = 0;		} else {			if (phist->h_wherefrom && phist->h_age >= x->x_vibbins) {				t_float centroid = 0;				t_int not = 0;				for (j=0, k=newphase; j<x->x_vibbins; j++) {					centroid += phist->h_pitches[k];					k--;					if (k<0) k = HISTORY-1;				}				centroid /= x->x_vibbins;				for (j=0, k=newphase; j<x->x_vibbins; j++) {					// calculate deviation from norm					t_float dev = centroid - phist->h_pitches[k];					k--;		    		if (k<0) k = HISTORY-1;					if ((dev > x->x_vibdepth) || (-dev > x->x_vibdepth)) not = 1;				}				if (!not) {		    		phist->h_pitch = phist->h_noted = centroid;		    	}	    	} // end if	    } // end else	}    return;	nopow:    for (i=0; i<x->x_npitch; i++) {		x->x_hist[i].h_pitch = 		x->x_hist[i].h_noted =	    x->x_hist[i].h_pitches[newphase] =	    x->x_hist[i].h_amps[newphase] =		x->x_hist[i].h_age = 0;    }    x->x_dbage = 0;	return;}