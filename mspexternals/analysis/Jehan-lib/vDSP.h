/*     File:       vDSP.h      Contains:   AltiVec DSP Interfaces      Version:    Technology: 1.0                 Release:    Universal Interfaces 3.4      Copyright:  © 2000-2001 by Apple Computer, Inc., all rights reserved.      Bugs?:      For bug reports, consult the following page on                 the World Wide Web:                      http://developer.apple.com/bugreporter/ */#ifndef __VDSP__#define __VDSP__#ifndef __CONDITIONALMACROS__#include <ConditionalMacros.h>#endif#ifndef __MACTYPES__#include <MacTypes.h>#endif#if PRAGMA_ONCE#pragma once#endif#ifdef __cplusplusextern "C" {#endif#if PRAGMA_IMPORT#pragma import on#endif#if PRAGMA_STRUCT_ALIGN    #pragma options align=mac68k#elif PRAGMA_STRUCT_PACKPUSH    #pragma pack(push, 2)#elif PRAGMA_STRUCT_PACK    #pragma pack(2)#endifstruct DSPComplex {  float               real;  float               imag;};typedef struct DSPComplex               DSPComplex;struct DSPSplitComplex {  float *             realp;  float *             imagp;};typedef struct DSPSplitComplex          DSPSplitComplex;typedef struct OpaqueFFTSetup*          FFTSetup;typedef SInt32 FFTDirection;enum {  kFFTDirection_Forward         = 1,  kFFTDirection_Inverse         = -1};typedef SInt32 FFTRadix;enum {  kFFTRadix2                    = 0,  kFFTRadix3                    = 1,  kFFTRadix5                    = 2};/*ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ    The criteria to invoke the PowerPC vector implementation is subject to         change and become less restrictive in the future.                          ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ*//*ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ    Functions create_fftsetup and destroy_fftsetup.    create_fftsetup will allocate memory and setup a weight array used by          the FFT. The call destroy_fftsetup will free the array.                    ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ*//* *  create_fftsetup() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( FFTSetup )create_fftsetup(  UInt32     log2n,  FFTRadix   radix);/* *  destroy_fftsetup() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )destroy_fftsetup(FFTSetup setup);/*ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ    Functions ctoz and ztoc.        ctoz converts a complex array to a complex-split array    ztoc converts a complex-split array to a complex array        Criteria to invoke PowerPC vector code:            1. size > 3        2. strideC = 2        3. strideZ = 1        4. Z.realp and Z.imagp are relatively aligned.        5. C is 8-byte aligned if Z.realp and Z.imagp are 4-byte- aligned           or C is 16-byte aligned if Z.realp and Z.imagp are at least           8-byte aligned.ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ*//* *  ctoz() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )ctoz(  const DSPComplex   C[],  SInt32             strideC,  DSPSplitComplex *  Z,  SInt32             strideZ,  UInt32             size);/* *  ztoc() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )ztoc(  const DSPSplitComplex *  Z,  SInt32                   strideZ,  DSPComplex               C[],  SInt32                   strideC,  UInt32                   size);/*ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ    Functions fft_zip and fft_zipt         In-place Split Complex Fourier Transform with or without temporary memory.                  Criteria to invoke PowerPC vector code:                    1. ioData.realp and ioData.imagp must be 16-byte aligned.        2. stride = 1        3. 2 <= log2n <= 20        4. bufferTemp.realp and bufferTemp.imagp must be 16-byte aligned.            If any of the above criteria are not satisfied, the PowerPC scalor code      implementation will be used.  The size of temporary memory for each part      is the lower value of 4*n and 16k.  Direction can be either      kFFTDirection_Forward or kFFTDirection_Inverse.ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ*//* *  fft_zip() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )fft_zip(  FFTSetup           setup,  DSPSplitComplex *  ioData,  SInt32             stride,  UInt32             log2n,  FFTDirection       direction);/* *  fft_zipt() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )fft_zipt(  FFTSetup           setup,  DSPSplitComplex *  ioData,  SInt32             stride,  DSPSplitComplex *  bufferTemp,  UInt32             log2n,  FFTDirection       direction);/*ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ     Functions fft_zop and fft_zopt          Out-of-place Split Complex Fourier Transform with or without temporary     memory                  Criteria to invoke PowerPC vector code:                  1. signal.realp and signal.imagp must be 16-byte aligned.        2. signalStride = 1        3. result.realp and result.imagp must be 16-byte aligned.        4. strideResult = 1        5. 2 <= log2n <= 20        6. bufferTemp.realp and bufferTemp.imagp must be 16-byte aligned.            If any of the above criteria are not satisfied, the PowerPC scalor code      implementation will be used.  The size of temporary memory for each part      is the lower value of 4*n and 16k.  Direction can be either      kFFTDirection_Forward or kFFTDirection_Inverse.ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ*//* *  fft_zop() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )fft_zop(  FFTSetup           setup,  DSPSplitComplex *  signal,  SInt32             signalStride,  DSPSplitComplex *  result,  SInt32             strideResult,  UInt32             log2n,  FFTDirection       direction);/* *  fft_zopt() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )fft_zopt(  FFTSetup           setup,  DSPSplitComplex *  signal,  SInt32             signalStride,  DSPSplitComplex *  result,  SInt32             strideResult,  DSPSplitComplex *  bufferTemp,  UInt32             log2n,  FFTDirection       direction);/*ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ    Functions fft_zrip and fft_zript        In-Place Real Fourier Transform with or without temporary memory,    split Complex Format                  Criteria to invoke PowerPC vector code:            1. ioData.realp and ioData.imagp must be 16-byte aligned.        2. stride = 1        3. 3 <= log2n <= 13            If any of the above criteria are not satisfied, the PowerPC scalor code      implementation will be used.  The size of temporary memory for each part      is the lower value of 4*n and 16k.  Direction can be either      kFFTDirection_Forward or kFFTDirection_Inverse.ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ*//* *  fft_zrip() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )fft_zrip(  FFTSetup           setup,  DSPSplitComplex *  ioData,  SInt32             stride,  UInt32             log2n,  FFTDirection       direction);/* *  fft_zript() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )fft_zript(  FFTSetup           setup,  DSPSplitComplex *  ioData,  SInt32             stride,  DSPSplitComplex *  bufferTemp,  UInt32             log2n,  FFTDirection       direction);/*ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ    Functions fft_zrop and fft_zropt        Out-of-Place Real Fourier Transform with or without temporary memory,    split Complex Format                  Criteria to invoke PowerPC vector code:          1. signal.realp and signal.imagp must be 16-byte aligned.        2. signalStride = 1        3. result.realp and result.imagp must be be 16-byte aligned.        4. strideResult = 1        5. 3 <= log2n <= 13            If any of the above criteria are not satisfied, the PowerPC scalor code      implementation will be used.  The size of temporary memory for each part      is the lower value of 4*n and 16k.  Direction can be either      kFFTDirection_Forward or kFFTDirection_Inverse.ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ*//* *  fft_zrop() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )fft_zrop(  FFTSetup           setup,  DSPSplitComplex *  signal,  SInt32             signalStride,  DSPSplitComplex *  result,  SInt32             strideResult,  UInt32             log2n,  FFTDirection       direction);/* *  fft_zropt() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )fft_zropt(  FFTSetup           setup,  DSPSplitComplex *  signal,  SInt32             signalStride,  DSPSplitComplex *  result,  SInt32             strideResult,  DSPSplitComplex *  bufferTemp,  UInt32             log2n,  FFTDirection       direction);/*ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ    Functions fft2d_zip and fft2d_zipt        In-place two dimensional Split Complex Fourier Transform with or without    temporary memory                  Criteria to invoke PowerPC vector code:          1. ioData.realp and ioData.imagp must be 16-byte aligned.        2. strideInRow = 1;        3. strideInCol must be a multiple of 4        4. 2 <= log2nInRow <= 12        5. 2 <= log2nInCol <= 12        6. bufferTemp.realp and bufferTemp.imagp must be 16-byte aligned.            If any of the above criteria are not satisfied, the PowerPC scalor code      implementation will be used.  The size of temporary memory for each part      is the lower value of 4*n and 16k.  ( log2n = log2nInRow + log2nInCol )       Direction can be either kFFTDirection_Forward or kFFTDirection_Inverse.ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ*//* *  fft2d_zip() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )fft2d_zip(  FFTSetup           setup,  DSPSplitComplex *  ioData,  SInt32             strideInRow,  SInt32             strideInCol,  UInt32             log2nInCol,  UInt32             log2nInRow,  FFTDirection       direction);/* *  fft2d_zipt() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )fft2d_zipt(  FFTSetup           setup,  DSPSplitComplex *  ioData,  SInt32             strideInRow,  SInt32             strideInCol,  DSPSplitComplex *  bufferTemp,  UInt32             log2nInCol,  UInt32             log2nInRow,  FFTDirection       direction);/*ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ    Functions fft2d_zop and fft2d_zopt        Out-of-Place two dimemsional Split Complex Fourier Transform with or    without temporary memory                  Criteria to invoke PowerPC vector code:                  1. signal.realp and signal.imagp must be 16-byte aligned.        2. signalStrideInRow = 1;        3. signalStrideInCol must be a multiple of 4        4. result.realp and result.imagp must be 16-byte aligned.        5. strideResultInRow = 1;        6. strideResultInCol must be a multiple of 4        7. 2 <= log2nInRow <= 12        8. 2 <= log2nInCol <= 12        9. bufferTemp.realp and bufferTemp.imagp must be 16-byte aligned.      If any of the above criteria are not satisfied, the PowerPC scalor code      implementation will be used.  The size of temporary memory for each part      is the lower value of 4*n and 16k.  ( log2n = log2nInRow + log2nInCol )       Direction can be either kFFTDirection_Forward or kFFTDirection_Inverse.ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ*//* *  fft2d_zop() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )fft2d_zop(  FFTSetup           setup,  DSPSplitComplex *  signal,  SInt32             signalStrideInRow,  SInt32             signalStrideInCol,  DSPSplitComplex *  result,  SInt32             strideResultInRow,  SInt32             strideResultInCol,  UInt32             log2nInCol,  UInt32             log2nInRow,  SInt32             flag);/* *  fft2d_zopt() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )fft2d_zopt(  FFTSetup           setup,  DSPSplitComplex *  signal,  SInt32             signalStrideInRow,  SInt32             signalStrideInCol,  DSPSplitComplex *  result,  SInt32             strideResultInRow,  SInt32             strideResultInCol,  DSPSplitComplex *  bufferTemp,  UInt32             log2nInCol,  UInt32             log2nInRow,  SInt32             flag);/*ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ    Functions fft2d_zrip and fft2d_zript        In-place two dimensional Real Fourier Transform with or without temporary    memory, Split Complex Format                  Criteria to invoke PowerPC vector code:          1. ioData.realp and ioData.imagp must be 16-byte aligned.        2. strideInRow = 1;        3. strideInCol must be a multiple of 4        4. 3 <= log2nInRow <= 12        5. 3 <= log2nInCol <= 13        6. bufferTemp.realp and bufferTemp.imagp must be 16-byte aligned.      If any of the above criteria are not satisfied, the PowerPC scalor code      implementation will be used.  The size of temporary memory for each part      is the lower value of 4*n and 16k.  ( log2n = log2nInRow + log2nInCol )       Direction can be either kFFTDirection_Forward or kFFTDirection_Inverse.ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ*//* *  fft2d_zrip() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )fft2d_zrip(  FFTSetup           setup,  DSPSplitComplex *  ioData,  SInt32             strideInRow,  SInt32             strideInCol,  UInt32             log2nInCol,  UInt32             log2nInRow,  FFTDirection       direction);/* *  fft2d_zript() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )fft2d_zript(  FFTSetup           setup,  DSPSplitComplex *  ioData,  SInt32             strideInRow,  SInt32             strideInCol,  DSPSplitComplex *  bufferTemp,  UInt32             log2nInCol,  UInt32             log2nInRow,  FFTDirection       direction);/*ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ    Functions fft2d_zrop and fft2d_zropt        Out-of-Place Two-Dimemsional Real Fourier Transform with or without    temporary memory, Split Complex Format                  Criteria to invoke PowerPC vector code:          1. signal.realp and signal.imagp must be 16-byte aligned.        2. signalStrideInRow = 1;        3. signalStrideInCol must be a multiple of 4        4. result.realp and result.imagp must be 16-byte aligned.        5. strideResultInRow = 1;        6. strideResultInCol must be a multiple of 4        7. 3 <= log2nInRow <= 12        8. 3 <= log2nInCol <= 13        9. bufferTemp.realp and bufferTemp.imagp must be 16-byte aligned.      If any of the above criteria are not satisfied, the PowerPC scalor code      implementation will be used.  The size of temporary memory for each part      is the lower value of 4*n and 16k.  ( log2n = log2nInRow + log2nInCol )       Direction can be either kFFTDirection_Forward or kFFTDirection_Inverse.ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ*//* *  fft2d_zrop() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )fft2d_zrop(  FFTSetup           setup,  DSPSplitComplex *  signal,  SInt32             signalStrideInRow,  SInt32             signalStrideInCol,  DSPSplitComplex *  result,  SInt32             strideResultInRow,  SInt32             strideResultInCol,  UInt32             log2nInCol,  UInt32             log2nInRow,  SInt32             flag);/* *  fft2d_zropt() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )fft2d_zropt(  FFTSetup           setup,  DSPSplitComplex *  signal,  SInt32             signalStrideInRow,  SInt32             signalStrideInCol,  DSPSplitComplex *  result,  SInt32             strideResultInRow,  SInt32             strideResultInCol,  DSPSplitComplex *  bufferTemp,  UInt32             log2nInCol,  UInt32             log2nInRow,  SInt32             flag);/*ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ    Function conv        Floating Point Convolution and Correlation            Criteria to invoke PowerPC vector code:          1. signal and result must have relative alignement.        2. 4 <= lenFilter <= 256        3. lenResult > 36        4. signalStride = 1        5. strideResult = 1            If any of the above criteria are not satisfied, the PowerPC scalor code      implementation will be used.  strideFilter can be positive for      correlation or negative for convolution.ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ*//* *  conv() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )conv(  const float   signal[],  SInt32        signalStride,  const float   filter[],  SInt32        strideFilter,  float         result[],  SInt32        strideResult,  SInt32        lenResult,  SInt32        lenFilter);/*ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ    Function vadd        Floating Point Add          Criteria to invoke PowerPC vector code:          1. input1 and input2 and result are all relatively aligned.        2. size >= 8        3. stride1 = 1        4. stride2 = 1        5. strideResult = 1            If any of the above criteria are not satisfied, the PowerPC scalor code      implementation will be used.ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ*//* *  vadd() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )vadd(  const float   input1[],  SInt32        stride1,  const float   input2[],  SInt32        stride2,  float         result[],  SInt32        strideResult,  UInt32        size);/*ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ    Function vsub         Floating Point Substract            Criteria to invoke PowerPC vector code:          1. input1 and input2 and result are all relatively aligned.        2. size >= 8        3. stride1 = 1        4. stride2 = 1        5. strideResult = 1            If any of the above criteria are not satisfied, the PowerPC scalor code      implementation will be used.ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ*//* *  vsub() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )vsub(  const float   input1[],  SInt32        stride1,  const float   input2[],  SInt32        stride2,  float         result[],  SInt32        strideResult,  UInt32        size);/*ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ    Function vmul        Floating Point Multiply          Criteria to invoke PowerPC vector code:          1. input1 and input2 and result must be all relatively aligned.        2. size >= 8        3. stride1 = 1        4. stride2 = 1        5. strideResult = 1            If any of the above criteria are not satisfied, the PowerPC scalor code      implementation will be used.ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ*//* *  vmul() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )vmul(  const float   input1[],  SInt32        stride1,  const float   input2[],  SInt32        stride2,  float         result[],  SInt32        strideResult,  UInt32        size);/*ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ    Function vsmul        Floating Point - Scalar Multiply          Criteria to invoke PowerPC vector code:          1. input1 and result are all relatively aligned.        2. size >= 8        3. stride1 = 1        5. strideResult = 1            If any of the above criteria are not satisfied, the PowerPC scalor code      implementation will be used.ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ*//* *  vsmul() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )vsmul(  const float    input1[],  SInt32         stride1,  const float *  input2,  float          result[],  SInt32         strideResult,  UInt32         size);/*ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ    Function vsq        Floating Point Square            Criteria to invoke PowerPC vector code:          1. input and result are relatively aligned.        2. size >= 8        3. strideInput = 1        4. strideResult = 1            If any of the above criteria are not satisfied, the PowerPC scalor code      implementation will be used.ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ*//* *  vsq() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )vsq(  const float   input[],  SInt32        strideInput,  float         result[],  SInt32        strideResult,  UInt32        size);/*ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ    Function vssq        Floating Point Signed Square            Criteria to invoke PowerPC vector code:          1. input and result must be all relatively aligned.        2. size >= 8        3. strideInput = 1        4. strideResult = 1            If any of the above criteria are not satisfied, the PowerPC scalor code      implementation will be used.ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ*//* *  vssq() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )vssq(  const float   input[],  SInt32        strideInput,  float         result[],  SInt32        strideResult,  UInt32        size);/*ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ    Function dotpr        Floating Point Dot product          Criteria to invoke PowerPC vector code:          1. input1 and input2 are relatively aligned.        2. size >= 20        3. stride1 = 1        4. stride2 = 1            If any of the above criteria are not satisfied, the PowerPC scalor code      implementation will be used.ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ*//* *  dotpr() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )dotpr(  const float   input1[],  SInt32        stride1,  const float   input2[],  SInt32        stride2,  float *       result,  UInt32        size);/*ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ    Function vam        Floating Point vadd and Multiply          Criteria to invoke PowerPC vector code:          1. input1, input2, input_3 and result are all relatively aligned.        2. size >= 8        3. stride1 = 1        4. stride2 = 1        5. stride_3 = 1        6. strideResult = 1            If any of the above criteria are not satisfied, the PowerPC scalor code      implementation will be used.ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ*//* *  vam() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )vam(  const float   input1[],  SInt32        stride1,  const float   input2[],  SInt32        stride2,  const float   input3[],  SInt32        stride3,  float         result[],  SInt32        strideResult,  UInt32        size);/*ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ    Function zconv        Split Complex Convolution and Correlation            Criteria to invoke PowerPC vector code:          1. signal->realp, signal->imagp, result->realp, result->imagp           must be relatively aligned.        2. 4 <= lenFilter <= 128        3. lenResult > 20        4. signalStride = 1        5. strideResult = 1            If any of the above criteria are not satisfied, the PowerPC scalor code      implementation will be used.  strideFilter can be positive for correlation      or negative for convolutionÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ*//* *  zconv() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )zconv(  DSPSplitComplex *  signal,  SInt32             signalStride,  DSPSplitComplex *  filter,  SInt32             strideFilter,  DSPSplitComplex *  result,  SInt32             strideResult,  SInt32             lenResult,  SInt32             lenFilter);/*ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ    Function zvadd        Split Complex vadd            Criteria to invoke PowerPC vector code:          1. input1.realp, input1.imagp, input2.realp, input2.imagp,           result.realp, result.imagp must be all relatively aligned.        2. size >= 8        3. stride1 = 1        4. stride2 = 1        5. strideResult = 1            If any of the above criteria are not satisfied, the PowerPC scalor code      implementation will be used.ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ*//* *  zvadd() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )zvadd(  DSPSplitComplex *  input1,  SInt32             stride1,  DSPSplitComplex *  input2,  SInt32             stride2,  DSPSplitComplex *  result,  SInt32             strideResult,  UInt32             size);/*ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ    Function zvsub        Split Complex Substract            Criteria to invoke PowerPC vector code:          1. input1.realp, input1.imagp, input2.realp, input2.imagp,           result.realp, result.imagp must be all relatively aligned.        2. size >= 8        3. stride1 = 1        4. stride2 = 1        5. strideResult = 1            If any of the above criteria are not satisfied, the PowerPC scalor code      implementation will be used.ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ*//* *  zvsub() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )zvsub(  DSPSplitComplex *  input1,  SInt32             stride1,  DSPSplitComplex *  input2,  SInt32             stride2,  DSPSplitComplex *  result,  SInt32             strideResult,  UInt32             size);/*ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ    Function zvmul        Split Complex Multiply            Criteria to invoke PowerPC vector code:          1. input1.realp, input1.imagp, input2.realp, input2.imagp,           result.realp, result.imagp must be all relatively aligned.        2. size >= 8        3. stride1 = 1        4. stride2 = 1        5. strideResult = 1      If any of the above criteria are not satisfied, the PowerPC scalor code      implementation will be used.  The conjugate value can be 1 or -1.ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ*//* *  zvmul() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )zvmul(  DSPSplitComplex *  input1,  SInt32             stride1,  DSPSplitComplex *  input2,  SInt32             stride2,  DSPSplitComplex *  result,  SInt32             strideResult,  UInt32             size,  SInt32             conjugate);/*ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ    Function zdotpr        Split Complex Dot product          Criteria to invoke PowerPC vector code:          1. input1.realp, input1.imagp, input2.realp, input2.imagp are all           relatively aligned.        2. size >= 20        3. stride1 = 1        4. stride2 = 1            If any of the above criteria are not satisfied, the PowerPC scalor code      implementation will be used.ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ*//* *  zdotpr() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )zdotpr(  DSPSplitComplex *  input1,  SInt32             stride1,  DSPSplitComplex *  input2,  SInt32             stride2,  DSPSplitComplex *  result,  UInt32             size);/*ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ    Function zidotpr        Split Complex Inner Dot product          Criteria to invoke PowerPC vector code:          1. input1.realp, input1.imagp, input2.realp, input2.imagp must be           all relatively aligned.        2. size >= 20        3. stride1 = 1        4. stride2 = 1            If any of the above criteria are not satisfied, the PowerPC scalor code      implementation will be used.ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ*//* *  zidotpr() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )zidotpr(  DSPSplitComplex *  input1,  SInt32             stride1,  DSPSplitComplex *  input2,  SInt32             stride2,  DSPSplitComplex *  result,  UInt32             size);/*ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ    Function zrdotpr        Split Complex - Real Dot product            Criteria to invoke PowerPC vector code:          1. input1.realp, input1.imagp, input2 are must be relatively aligned.        2. size >= 16        3. stride1 = 1        4. stride2 = 1            If any of the above criteria are not satisfied, the PowerPC scalor code      implementation will be used.ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ*//* *  zrdotpr() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )zrdotpr(  DSPSplitComplex *  input1,  SInt32             stride1,  const float        input2[],  SInt32             stride2,  DSPSplitComplex *  result,  UInt32             size);/*ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ    Function zvcma        Split Complex Conjugate Multiply And vadd          Criteria to invoke PowerPC vector code:          1. input1.realp, input1.imagp, input2.realp, input2.imagp,          input_3.realp, input_3.imagp, result.realp, result.imagp          must be all relatively aligned.        2. size >= 8        3. stride1 = 1        4. stride2 = 1        5. stride_3 = 1        6. strideResult = 1            If any of the above criteria are not satisfied, the PowerPC scalor code      implementation will be used.ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ*//* *  zvcma() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )zvcma(  DSPSplitComplex *  input1,  SInt32             stride1,  DSPSplitComplex *  input2,  SInt32             stride2,  DSPSplitComplex *  input3,  SInt32             stride3,  DSPSplitComplex *  result,  SInt32             strideResult,  UInt32             size);/*ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ    Function zrvadd        Split Complex - Real Add            Criteria to invoke PowerPC vector code:          1. input1.realp, input1.imagp, input2, result.realp, result.imagp           are all relatively aligned.        2. size >= 8        3. stride1 = 1        4. stride2 = 1        5. strideResult = 1            If any of the above criteria are not satisfied, the PowerPC scalor code      implementation will be used.ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ*//* *  zrvadd() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )zrvadd(  DSPSplitComplex *  input1,  SInt32             stride1,  const float        input2[],  SInt32             stride2,  DSPSplitComplex *  result,  SInt32             strideResult,  UInt32             size);/*ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ    Function zrvsub        Split Complex - Real Substract          Criteria to invoke PowerPC vector code:          1. input1.realp, input1.imagp, input2, result.realp, result.imagp           must be all relatively aligned.        2. size >= 8        3. stride1 = 1        4. stride2 = 1        5. strideResult = 1            If any of the above criteria are not satisfied, the PowerPC scalor code      implementation will be used.ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ*//* *  zrvsub() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )zrvsub(  DSPSplitComplex *  input1,  SInt32             stride1,  const float        input2[],  SInt32             stride2,  DSPSplitComplex *  result,  SInt32             strideResult,  UInt32             size);/*ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ    Function zrvmul        Split Complex - Real Multiply          Criteria to invoke PowerPC vector code:          1. input1.realp, input1.imagp, input2, result.realp, result.imagp           must be all relatively aligned.        2. size >= 8        3. stride1 = 1        4. stride2 = 1        5. strideResult = 1            If any of the above criteria are not satisfied, the PowerPC scalor code      implementation will be used.ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ*//* *  zrvmul() *   *  Availability: *    Non-Carbon CFM:   in vecLib 1.0 and later *    CarbonLib:        not in Carbon, but vecLib is compatible with Carbon *    Mac OS X:         in version 10.0 or later */EXTERN_API_C( void )zrvmul(  DSPSplitComplex *  input1,  SInt32             stride1,  const float        input2[],  SInt32             stride2,  DSPSplitComplex *  result,  SInt32             strideResult,  UInt32             size);#ifndef USE_NONE_APPLE_STANDARD_DATATYPES#define USE_NONE_APPLE_STANDARD_DATATYPES 1#endif  /* !defined(USE_NONE_APPLE_STANDARD_DATATYPES) */#if USE_NONE_APPLE_STANDARD_DATATYPESenum {  FFT_FORWARD                   = kFFTDirection_Forward,  FFT_INVERSE                   = kFFTDirection_Inverse};enum {  FFT_RADIX2                    = kFFTRadix2,  FFT_RADIX3                    = kFFTRadix3,  FFT_RADIX5                    = kFFTRadix5};typedef DSPComplex                      COMPLEX;typedef DSPSplitComplex                 COMPLEX_SPLIT;#endif  /* USE_NONE_APPLE_STANDARD_DATATYPES */#if PRAGMA_STRUCT_ALIGN    #pragma options align=reset#elif PRAGMA_STRUCT_PACKPUSH    #pragma pack(pop)#elif PRAGMA_STRUCT_PACK    #pragma pack()#endif#ifdef PRAGMA_IMPORT_OFF#pragma import off#elif PRAGMA_IMPORT#pragma import reset#endif#ifdef __cplusplus}#endif#endif /* __VDSP__ */