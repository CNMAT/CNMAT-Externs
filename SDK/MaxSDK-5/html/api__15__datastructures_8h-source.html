<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
		<title>Max5 API Reference</title>
		<link href="c74-doxygen.css" rel="stylesheet" type="text/css">
	</head>
	<body>

		<div id="c74header">
			<img src="max5.png" />
			<p>Max 5 API Reference</p>
		</div>

<!-- Generated by Doxygen 1.5.6 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<h1>api_15_datastructures.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/** </span>
<a name="l00002"></a>00002 <span class="comment">    @page chapter_datastructures Data Structures</span>
<a name="l00003"></a>00003 <span class="comment"></span>
<a name="l00004"></a>00004 <span class="comment"></span>
<a name="l00005"></a>00005 <span class="comment">    @section chapter_datastructures_linkedlists Linked Lists</span>
<a name="l00006"></a>00006 <span class="comment"></span>
<a name="l00007"></a>00007 <span class="comment">    The Max #t_linklist data structure is useful for maintaining ordered lists of items where you want to be able to insert and delete items efficiently. Random access of individual items, however, gets appreciably slower as the list grows in size. The #t_linklist is thread-safe by default, but thread safety can be turned off for performance benefits in single-threaded applications. However, ensure that your use of the linked list is truly single-threaded (based on an understanding of Max's @ref chapter_threading model) before turning off the thread safety features.</span>
<a name="l00008"></a>00008 <span class="comment"></span>
<a name="l00009"></a>00009 <span class="comment">    By default, the #t_linklist holds pointers to Max objects. However, you can treat what the linklist holds as data rather than objects to be freed by using the linklist_flags() function.</span>
<a name="l00010"></a>00010 <span class="comment"></span>
<a name="l00011"></a>00011 <span class="comment">    Here is a simple example of the use of #t_linklist. The code below stores five symbols, sorts them, searches for a specific item, deletes an item, prints all items, and then frees the entire structure. Since symbols in Max are never freed, linklist_flags() is used to specify that data, rather than object pointers, are being stored.</span>
<a name="l00012"></a>00012 <span class="comment"></span>
<a name="l00013"></a>00013 <span class="comment">@code</span>
<a name="l00014"></a>00014 <span class="comment">    void mylistfun()</span>
<a name="l00015"></a>00015 <span class="comment">    {</span>
<a name="l00016"></a>00016 <span class="comment">    t_listlist *list;</span>
<a name="l00017"></a>00017 <span class="comment"></span>
<a name="l00018"></a>00018 <span class="comment">    list = (t_linklist *)linklist_new();</span>
<a name="l00019"></a>00019 <span class="comment"></span>
<a name="l00020"></a>00020 <span class="comment">    linklist_flags(list, OBJ_FLAG_DATA);</span>
<a name="l00021"></a>00021 <span class="comment"></span>
<a name="l00022"></a>00022 <span class="comment">    // add some data</span>
<a name="l00023"></a>00023 <span class="comment">    linklist_append(list, gensym("one"));</span>
<a name="l00024"></a>00024 <span class="comment">    linklist_append(list, gensym("two"));</span>
<a name="l00025"></a>00025 <span class="comment">    linklist_append(list, gensym("three"));</span>
<a name="l00026"></a>00026 <span class="comment">    linklist_append(list, gensym("four"));</span>
<a name="l00027"></a>00027 <span class="comment">    linklist_append(list, gensym("five"));</span>
<a name="l00028"></a>00028 <span class="comment"></span>
<a name="l00029"></a>00029 <span class="comment">    // sort</span>
<a name="l00030"></a>00030 <span class="comment"></span>
<a name="l00031"></a>00031 <span class="comment">    linklist_sort(list, (t_cmpfn)mysortfun);</span>
<a name="l00032"></a>00032 <span class="comment"></span>
<a name="l00033"></a>00033 <span class="comment">    // search</span>
<a name="l00034"></a>00034 <span class="comment"></span>
<a name="l00035"></a>00035 <span class="comment">    index = linklist_findfirst(list, &amp;found, mysearchfun, gensym("four"));  // find the "four" symbol</span>
<a name="l00036"></a>00036 <span class="comment"></span>
<a name="l00037"></a>00037 <span class="comment">    if (index != -1)    // found</span>
<a name="l00038"></a>00038 <span class="comment">        linklist_chuckindex(list, index);</span>
<a name="l00039"></a>00039 <span class="comment"></span>
<a name="l00040"></a>00040 <span class="comment">    // iterate</span>
<a name="l00041"></a>00041 <span class="comment"></span>
<a name="l00042"></a>00042 <span class="comment">    linklist_funall(list, myprintfun, NULL);</span>
<a name="l00043"></a>00043 <span class="comment"></span>
<a name="l00044"></a>00044 <span class="comment">    // delete</span>
<a name="l00045"></a>00045 <span class="comment"></span>
<a name="l00046"></a>00046 <span class="comment">    linklist_chuck(list);</span>
<a name="l00047"></a>00047 <span class="comment"></span>
<a name="l00048"></a>00048 <span class="comment">    }</span>
<a name="l00049"></a>00049 <span class="comment">@endcode</span>
<a name="l00050"></a>00050 <span class="comment"></span>
<a name="l00051"></a>00051 <span class="comment">    The sorting function compares two items in the list and returns non-zero if the first one should go before the second one.</span>
<a name="l00052"></a>00052 <span class="comment"></span>
<a name="l00053"></a>00053 <span class="comment">@code</span>
<a name="l00054"></a>00054 <span class="comment">    long mysortfun(void *a, void *b)</span>
<a name="l00055"></a>00055 <span class="comment">    {</span>
<a name="l00056"></a>00056 <span class="comment">        t_symbol *sa = (t_symbol *)a;</span>
<a name="l00057"></a>00057 <span class="comment">        t_symbol *sb = (t_symbol *)b;</span>
<a name="l00058"></a>00058 <span class="comment"></span>
<a name="l00059"></a>00059 <span class="comment">        return strcmp(sa-&gt;s_name, sb-&gt;s_name) &gt; 0;</span>
<a name="l00060"></a>00060 <span class="comment">    }</span>
<a name="l00061"></a>00061 <span class="comment">@endcode</span>
<a name="l00062"></a>00062 <span class="comment"></span>
<a name="l00063"></a>00063 <span class="comment">    The search function is passed the final argument to linklist_findfirst() and, in this case, just returns the symbol that matches, which is just testing for pointer equivalence since all Max symbols are unique. You could do more sophisticated searching if you store more complex data in a linklist.</span>
<a name="l00064"></a>00064 <span class="comment"></span>
<a name="l00065"></a>00065 <span class="comment">@code</span>
<a name="l00066"></a>00066 <span class="comment">    long mysearchfun(t_symbol *elem, t_symbol *match)</span>
<a name="l00067"></a>00067 <span class="comment">    {</span>
<a name="l00068"></a>00068 <span class="comment">        return elem == match;</span>
<a name="l00069"></a>00069 <span class="comment">    }</span>
<a name="l00070"></a>00070 <span class="comment">@endcode</span>
<a name="l00071"></a>00071 <span class="comment"></span>
<a name="l00072"></a>00072 <span class="comment">    The iteration function takes some action on all items in the list. The third argument to linklist_funall() is passed as the second argument to your iteration function. In this example, we don't do anything with it.</span>
<a name="l00073"></a>00073 <span class="comment"></span>
<a name="l00074"></a>00074 <span class="comment">@code</span>
<a name="l00075"></a>00075 <span class="comment">    void myprintfun(t_symbol *item, void *dummy)</span>
<a name="l00076"></a>00076 <span class="comment">    {</span>
<a name="l00077"></a>00077 <span class="comment">        post("%s",item-&gt;s_name);</span>
<a name="l00078"></a>00078 <span class="comment">    }</span>
<a name="l00079"></a>00079 <span class="comment">@endcode</span>
<a name="l00080"></a>00080 <span class="comment"></span>
<a name="l00081"></a>00081 <span class="comment">    There are many more functions for operating on linked lists you can read about by exploring the @ref linklist function reference.</span>
<a name="l00082"></a>00082 <span class="comment"></span>
<a name="l00083"></a>00083 <span class="comment"></span>
<a name="l00084"></a>00084 <span class="comment">    @section chapter_datastructures_hashtabs Hash Tables</span>
<a name="l00085"></a>00085 <span class="comment"></span>
<a name="l00086"></a>00086 <span class="comment">    A hash table is a data structure that associates some data with a unique key. If you know the key, you can get back the data much more quickly than with a linked list, particularly as the number of items stored grows larger. The Max hash table #t_hashtab is optimized to work with symbol pointers as keys, but you can use any pointer or number, as long as it is unique.</span>
<a name="l00087"></a>00087 <span class="comment"></span>
<a name="l00088"></a>00088 <span class="comment">    To create a #t_hashtab, you use hashtab_new(). To add items, use hashtab_store(). To find items that have been added, use hashtab_lookup().</span>
<a name="l00089"></a>00089 <span class="comment"></span>
<a name="l00090"></a>00090 <span class="comment">    By contrast with linked lists and arrays, hash tables do not have a strong sense of ordering. You can iterate through all items using hashtab_funall(), but the exact order is not under your control as items are added and removed. There is also no way to "sort" a hash table.</span>
<a name="l00091"></a>00091 <span class="comment"></span>
<a name="l00092"></a>00092 <span class="comment">    Example:</span>
<a name="l00093"></a>00093 <span class="comment"></span>
<a name="l00094"></a>00094 <span class="comment">    The following example creates a hashtab, shows how to add some data (in this case, just a number), look it up, and delete the hashtab.</span>
<a name="l00095"></a>00095 <span class="comment">@code</span>
<a name="l00096"></a>00096 <span class="comment">    t_hashtab *tab = (t_hashtab *)hashtab_new(0);</span>
<a name="l00097"></a>00097 <span class="comment">    long result, value;</span>
<a name="l00098"></a>00098 <span class="comment"></span>
<a name="l00099"></a>00099 <span class="comment">    hashtab_store(tab, gensym("a great number"), (t_object *)74);</span>
<a name="l00100"></a>00100 <span class="comment"></span>
<a name="l00101"></a>00101 <span class="comment">    result = hashtab_lookup(tab, gensym("a great number"), (t_object **)value);</span>
<a name="l00102"></a>00102 <span class="comment"></span>
<a name="l00103"></a>00103 <span class="comment">    if (!result)</span>
<a name="l00104"></a>00104 <span class="comment">        post("found the value and it is %ld",value);</span>
<a name="l00105"></a>00105 <span class="comment">    else</span>
<a name="l00106"></a>00106 <span class="comment">        post("did not find the value");</span>
<a name="l00107"></a>00107 <span class="comment"></span>
<a name="l00108"></a>00108 <span class="comment">    hashtab_chuck(tab);</span>
<a name="l00109"></a>00109 <span class="comment">@endcode</span>
<a name="l00110"></a>00110 <span class="comment"></span>
<a name="l00111"></a>00111 <span class="comment">    Note that the Max #t_dictionary used for managing patcher data is implemented as a #t_hashtab.</span>
<a name="l00112"></a>00112 <span class="comment"></span>
<a name="l00113"></a>00113 <span class="comment"></span>
<a name="l00114"></a>00114 <span class="comment">*/</span>
</pre></div></div>
		<div id="c74footer">
			<p>Copyright &copy; 2008, <a href="http://www.cycling74.com/">Cycling '74</a></p>
		</div>
	</body>
</html>
