<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
		<title>Max5 API Reference</title>
		<link href="c74-doxygen.css" rel="stylesheet" type="text/css">
	</head>
	<body>

		<div id="c74header">
			<img src="max5.png" />
			<p>Max 5 API Reference</p>
		</div>

<!-- Generated by Doxygen 1.5.6 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<h1>api_09_mspadvanced.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/** </span>
<a name="l00002"></a>00002 <span class="comment">    @page chapter_msp_advanced Advanced Signal Object Topics</span>
<a name="l00003"></a>00003 <span class="comment"></span>
<a name="l00004"></a>00004 <span class="comment">    Here are some techniques for implementing additional features found in most signal objects.</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment">    @section chapter_msp_advanced_internal_state Saving Internal State</span>
<a name="l00007"></a>00007 <span class="comment"></span>
<a name="l00008"></a>00008 <span class="comment">    To implement unit generators such as filters and ramp generators, you need to save internal state between calls to your object's perform routine. Here is a very simple low-pass filter (it just averages successive samples) that saves the value of the last sample in a vector to be averaged with the first sample of the next vector. First we add a field to our data structure to hold the value:</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">@code</span>
<a name="l00011"></a>00011 <span class="comment">    typedef struct _myfilter</span>
<a name="l00012"></a>00012 <span class="comment">    {</span>
<a name="l00013"></a>00013 <span class="comment">        t_pxobject f_obj;</span>
<a name="l00014"></a>00014 <span class="comment">        t_float f_sample;</span>
<a name="l00015"></a>00015 <span class="comment">    } t_myfilter;</span>
<a name="l00016"></a>00016 <span class="comment">@endcode</span>
<a name="l00017"></a>00017 <span class="comment"></span>
<a name="l00018"></a>00018 <span class="comment">    Then, in our dsp method (which has one input and one output), we pass a pointer to the object as one of the DSP chain arguments. The dsp method also initializes the value of the internal state, to avoid any noise when the audio starts.</span>
<a name="l00019"></a>00019 <span class="comment"></span>
<a name="l00020"></a>00020 <span class="comment">@code</span>
<a name="l00021"></a>00021 <span class="comment">    void myfilter_dsp(t_myfilter *x, t_signal **sp, short *count)</span>
<a name="l00022"></a>00022 <span class="comment">    {</span>
<a name="l00023"></a>00023 <span class="comment">        dsp_add(myfilter_perform, 4, x, sp[0]-&gt;s_vec, sp[1]-&gt;s_vec, sp[0]-&gt;s_n);</span>
<a name="l00024"></a>00024 <span class="comment">    </span>
<a name="l00025"></a>00025 <span class="comment">        x-&gt;f_sample = 0;</span>
<a name="l00026"></a>00026 <span class="comment">    }</span>
<a name="l00027"></a>00027 <span class="comment">@endcode</span>
<a name="l00028"></a>00028 <span class="comment"></span>
<a name="l00029"></a>00029 <span class="comment">    Here is the perform routine, which obtains the internal state before entering the processing loop, then stores the most recent value after the loop is finished.</span>
<a name="l00030"></a>00030 <span class="comment"></span>
<a name="l00031"></a>00031 <span class="comment">@code</span>
<a name="l00032"></a>00032 <span class="comment">    t_int *myfilter_perform(t_int *w)</span>
<a name="l00033"></a>00033 <span class="comment">    {</span>
<a name="l00034"></a>00034 <span class="comment">        t_myfilter *x = (t_myfilter *)w[1];</span>
<a name="l00035"></a>00035 <span class="comment">        t_float *in = (t_float *)w[2];</span>
<a name="l00036"></a>00036 <span class="comment">        t_float *out = (t_float *)w[3];</span>
<a name="l00037"></a>00037 <span class="comment">        int n = (int)w[4];</span>
<a name="l00038"></a>00038 <span class="comment">        t_float samp = x-&gt;f_sample; // read from internal state</span>
<a name="l00039"></a>00039 <span class="comment">        t_float val;</span>
<a name="l00040"></a>00040 <span class="comment"></span>
<a name="l00041"></a>00041 <span class="comment">        while (n--) {</span>
<a name="l00042"></a>00042 <span class="comment">            val = *in++;</span>
<a name="l00043"></a>00043 <span class="comment">            *out++ = (val + samp) * 0.5;</span>
<a name="l00044"></a>00044 <span class="comment">            samp = val;</span>
<a name="l00045"></a>00045 <span class="comment">        }</span>
<a name="l00046"></a>00046 <span class="comment">        x-&gt;f_sample = samp;     // save to internal state</span>
<a name="l00047"></a>00047 <span class="comment"></span>
<a name="l00048"></a>00048 <span class="comment">        return w + 5;</span>
<a name="l00049"></a>00049 <span class="comment">    }</span>
<a name="l00050"></a>00050 <span class="comment">@endcode</span>
<a name="l00051"></a>00051 <span class="comment"></span>
<a name="l00052"></a>00052 <span class="comment"></span>
<a name="l00053"></a>00053 <span class="comment">    @section chapter_msp_advanced_muting Observing Patcher Muting</span>
<a name="l00054"></a>00054 <span class="comment"></span>
<a name="l00055"></a>00055 <span class="comment">    The enable message to the thispatcher object, as well as the MSP mute object~ can be used to disable a subpatcher. If your object is at all computationally expensive in its perform routine, it should check to see whether it has been disabled. To do this, you'll need to pass a pointer to your object as one of the DSP chain arguments when calling dsp_add(). Here is a simple modification of our filter object's perform routine that checks to see if the object has been disabled.</span>
<a name="l00056"></a>00056 <span class="comment"></span>
<a name="l00057"></a>00057 <span class="comment">@code</span>
<a name="l00058"></a>00058 <span class="comment">    t_int *myfilter_perform(t_int *w)</span>
<a name="l00059"></a>00059 <span class="comment">    {</span>
<a name="l00060"></a>00060 <span class="comment">        t_myfilter *x = (t_myfilter *)w[1];</span>
<a name="l00061"></a>00061 <span class="comment">        t_float *in = (t_float *)w[2];</span>
<a name="l00062"></a>00062 <span class="comment">        t_float *out = (t_float *)w[3];</span>
<a name="l00063"></a>00063 <span class="comment">        int n = (int)w[4];</span>
<a name="l00064"></a>00064 <span class="comment">        t_float samp = x-&gt;f_sample; // read from internal state</span>
<a name="l00065"></a>00065 <span class="comment">        t_float val;</span>
<a name="l00066"></a>00066 <span class="comment"></span>
<a name="l00067"></a>00067 <span class="comment">        if (x-&gt;f_obj.z_disabled)    // check for object being disabled</span>
<a name="l00068"></a>00068 <span class="comment">            return w + 5;</span>
<a name="l00069"></a>00069 <span class="comment"> </span>
<a name="l00070"></a>00070 <span class="comment">        while (n--) {</span>
<a name="l00071"></a>00071 <span class="comment">            val = *in++;</span>
<a name="l00072"></a>00072 <span class="comment">            *out++ = (val + samp) * 0.5;</span>
<a name="l00073"></a>00073 <span class="comment">            samp = val;</span>
<a name="l00074"></a>00074 <span class="comment">        }</span>
<a name="l00075"></a>00075 <span class="comment">        x-&gt;f_sample = samp;     // save to internal state</span>
<a name="l00076"></a>00076 <span class="comment"></span>
<a name="l00077"></a>00077 <span class="comment">        return w + 5;</span>
<a name="l00078"></a>00078 <span class="comment">    }</span>
<a name="l00079"></a>00079 <span class="comment">@endcode</span>
<a name="l00080"></a>00080 <span class="comment"> </span>
<a name="l00081"></a>00081 <span class="comment"></span>
<a name="l00082"></a>00082 <span class="comment">    @section chapter_msp_advanced_connections Using Connection Information</span>
<a name="l00083"></a>00083 <span class="comment"></span>
<a name="l00084"></a>00084 <span class="comment">    The third argument to the dsp method is an array of numbers that enumerate the number of objects connected to each of your objects inputs and outputs. More advanced dsp methods can use this information for optimization purposes. For example, if you find that your object has no inputs or outputs, you could avoid calling dsp_add() altogether. The MSP signal operator objects (such as +~ and *~) to implement a basic polymorphism: they look at the connections count to determine whether the perform routine should use scalar or signal inputs. For example, if the right input has no connected signals, the user can add a scalar value sent to the right inlet.</span>
<a name="l00085"></a>00085 <span class="comment"> </span>
<a name="l00086"></a>00086 <span class="comment">    To implement this behavior, you have a few different options. The first option is to write two different perform methods, one which handles the two-signal case, and one which handles the scalar case. The dsp method looks at the count array and passes a different function to dsp_add(). The example below assumes that the second element in the signal and count arrays (sp[1]) is the right input:</span>
<a name="l00087"></a>00087 <span class="comment"></span>
<a name="l00088"></a>00088 <span class="comment">@code</span>
<a name="l00089"></a>00089 <span class="comment">        if (count[1])   // signal connected</span>
<a name="l00090"></a>00090 <span class="comment">            dsp_add(mydspobject_twosigperform, 5, x, sp[0]-&gt;s_vec, sp[1]-&gt;s_vec, sp[2]-&gt;s_vec, sp[0]-&gt;s_n);</span>
<a name="l00091"></a>00091 <span class="comment">        else</span>
<a name="l00092"></a>00092 <span class="comment">            dsp_add(mydspobject_scalarperform, 4, x, sp[0]-&gt;s_vec, sp[2]-&gt;s_vec, sp[0]-&gt;s_n);</span>
<a name="l00093"></a>00093 <span class="comment">@endcode</span>
<a name="l00094"></a>00094 <span class="comment"></span>
<a name="l00095"></a>00095 <span class="comment"></span>
<a name="l00096"></a>00096 <span class="comment">    The second option is to pass the value of the count array for a particular signal to the perform method, which can make the decision whether to use the signal value or a scalar value that has been stored inside the object. In this case, many objects use a single sample value from the signal as a substitute for the scalar. Using the first sample (i.e., the value at index 0) is a technique that works for any vector size, since vector sizes could be as small as a single sample. Here is an example of this technique for an object that has two inputs and one output. The connection count for the right input signal is passed as the second argument on the DSP chain, and the right input signal vector is passed even if it not connected:</span>
<a name="l00097"></a>00097 <span class="comment"></span>
<a name="l00098"></a>00098 <span class="comment">@code</span>
<a name="l00099"></a>00099 <span class="comment">        dsp_add(mydspobject_perform, 6, x, count[1], sp[0]-&gt;s_vec, sp[1]-&gt;s_vec, sp[2]-&gt;s_vec, sp[0]-&gt;s_n);</span>
<a name="l00100"></a>00100 <span class="comment">@endcode</span>
<a name="l00101"></a>00101 <span class="comment"></span>
<a name="l00102"></a>00102 <span class="comment">    Here is a perform routine that uses the connection count information as passed in format shown above:</span>
<a name="l00103"></a>00103 <span class="comment"></span>
<a name="l00104"></a>00104 <span class="comment">@code</span>
<a name="l00105"></a>00105 <span class="comment">    t_int mydspobject_perform(t_int *w)</span>
<a name="l00106"></a>00106 <span class="comment">    {</span>
<a name="l00107"></a>00107 <span class="comment">        t_mydspobject *x = (t_mydspobject *)w[1];</span>
<a name="l00108"></a>00108 <span class="comment">        int connected = (int)w[2];</span>
<a name="l00109"></a>00109 <span class="comment">        t_float *in = (t_float *)w[3];</span>
<a name="l00110"></a>00110 <span class="comment">        t_float *in2 = (t_float *)w[4];</span>
<a name="l00111"></a>00111 <span class="comment">        t_float *out = (t_float *)w[5];</span>
<a name="l00112"></a>00112 <span class="comment">        int n = (int)w[6];</span>
<a name="l00113"></a>00113 <span class="comment"></span>
<a name="l00114"></a>00114 <span class="comment">        double in2value;</span>
<a name="l00115"></a>00115 <span class="comment"></span>
<a name="l00116"></a>00116 <span class="comment">        // get scalar sample or use signal depending on whether signal is connected</span>
<a name="l00117"></a>00117 <span class="comment"></span>
<a name="l00118"></a>00118 <span class="comment">        in2value = connected? *in2 : x-&gt;m_scalarvalue;</span>
<a name="l00119"></a>00119 <span class="comment"></span>
<a name="l00120"></a>00120 <span class="comment">        // do calculation here</span>
<a name="l00121"></a>00121 <span class="comment"></span>
<a name="l00122"></a>00122 <span class="comment">        return w + 7;</span>
<a name="l00123"></a>00123 <span class="comment">    }</span>
<a name="l00124"></a>00124 <span class="comment">@endcode</span>
<a name="l00125"></a>00125 <span class="comment"></span>
<a name="l00126"></a>00126 <span class="comment">*/</span>
</pre></div></div>
		<div id="c74footer">
			<p>Copyright &copy; 2008, <a href="http://www.cycling74.com/">Cycling '74</a></p>
		</div>
	</body>
</html>
