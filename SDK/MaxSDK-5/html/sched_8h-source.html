<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
		<title>Max5 API Reference</title>
		<link href="c74-doxygen.css" rel="stylesheet" type="text/css">
	</head>
	<body>

		<div id="c74header">
			<img src="max5.png" />
			<p>Max 5 API Reference</p>
		</div>

<!-- Generated by Doxygen 1.5.6 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<h1>sched.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/**</span>
<a name="l00002"></a>00002 <span class="comment">    </span>
<a name="l00003"></a>00003 <span class="comment">    @defgroup sched Timing</span>
<a name="l00004"></a>00004 <span class="comment">    </span>
<a name="l00005"></a>00005 <span class="comment">    </span>
<a name="l00006"></a>00006 <span class="comment">*/</span>
<a name="l00007"></a>00007 
<a name="l00008"></a>00008 <span class="comment"></span>
<a name="l00009"></a>00009 <span class="comment">/**</span>
<a name="l00010"></a>00010 <span class="comment">    @defgroup clocks Clocks</span>
<a name="l00011"></a>00011 <span class="comment">    @ingroup sched</span>
<a name="l00012"></a>00012 <span class="comment">    </span>
<a name="l00013"></a>00013 <span class="comment">    Clock objects are your interface to Max’s scheduler. To use the </span>
<a name="l00014"></a>00014 <span class="comment">    scheduler, you create a new Clock object using clock_new in your </span>
<a name="l00015"></a>00015 <span class="comment">    instance creation function. You also have to write a clock function that </span>
<a name="l00016"></a>00016 <span class="comment">    will be executed when the clock goes off, declared as follows: </span>
<a name="l00017"></a>00017 <span class="comment">    </span>
<a name="l00018"></a>00018 <span class="comment">    @code</span>
<a name="l00019"></a>00019 <span class="comment">    void myobject_tick (myobject *x); </span>
<a name="l00020"></a>00020 <span class="comment">    @endcode</span>
<a name="l00021"></a>00021 <span class="comment">    </span>
<a name="l00022"></a>00022 <span class="comment">    The argument x is determined by the arg argument to clock_new(). </span>
<a name="l00023"></a>00023 <span class="comment">    Almost always it will be pointer to your object. </span>
<a name="l00024"></a>00024 <span class="comment">    Then, in one of your methods, use clock_delay() or clock_fdelay() to </span>
<a name="l00025"></a>00025 <span class="comment">    schedule yourself. If you want unschedule yourself, call </span>
<a name="l00026"></a>00026 <span class="comment">    clock_unset(). To find out what time it is now, use gettime() or </span>
<a name="l00027"></a>00027 <span class="comment">    clock_getftime(). More advanced clock operations are possible with </span>
<a name="l00028"></a>00028 <span class="comment">    the setclock object interface described in Chapter 9. We suggest you </span>
<a name="l00029"></a>00029 <span class="comment">    take advantage of the higher timing precision of the floating-point </span>
<a name="l00030"></a>00030 <span class="comment">    clock routines—all standard Max 4 timing objects such as metro use </span>
<a name="l00031"></a>00031 <span class="comment">    them. </span>
<a name="l00032"></a>00032 <span class="comment">    </span>
<a name="l00033"></a>00033 <span class="comment">    When the user has Overdrive mode enabled, your clock function will </span>
<a name="l00034"></a>00034 <span class="comment">    execute at interrupt level. </span>
<a name="l00035"></a>00035 <span class="comment">    </span>
<a name="l00036"></a>00036 <span class="comment">    </span>
<a name="l00037"></a>00037 <span class="comment">    @section clocks_using_clocks Using Clocks</span>
<a name="l00038"></a>00038 <span class="comment">    </span>
<a name="l00039"></a>00039 <span class="comment">    Under normal circumstances, gettime or clock_getftime will not </span>
<a name="l00040"></a>00040 <span class="comment">    be necessary for scheduling purposes if you use clock_delay or </span>
<a name="l00041"></a>00041 <span class="comment">    clock_fdelay, but it may be useful for recording the timing of </span>
<a name="l00042"></a>00042 <span class="comment">    messages or events.</span>
<a name="l00043"></a>00043 <span class="comment">     </span>
<a name="l00044"></a>00044 <span class="comment">    As an example, here’s a fragment of how one might go about writing a </span>
<a name="l00045"></a>00045 <span class="comment">    metronome using the Max scheduler. First, here’s the data structure </span>
<a name="l00046"></a>00046 <span class="comment">    we’ll use. </span>
<a name="l00047"></a>00047 <span class="comment"></span>
<a name="l00048"></a>00048 <span class="comment">    @code</span>
<a name="l00049"></a>00049 <span class="comment">    typedef struct mymetro { </span>
<a name="l00050"></a>00050 <span class="comment">        t_object *m_obj; </span>
<a name="l00051"></a>00051 <span class="comment">        void *m_clock; </span>
<a name="l00052"></a>00052 <span class="comment">        double m_interval; </span>
<a name="l00053"></a>00053 <span class="comment">        void *m_outlet; </span>
<a name="l00054"></a>00054 <span class="comment">    } t_mymetro;</span>
<a name="l00055"></a>00055 <span class="comment">    @endcode</span>
<a name="l00056"></a>00056 <span class="comment">    </span>
<a name="l00057"></a>00057 <span class="comment">    We’ll assume that the class has been initialized already. Here’s the </span>
<a name="l00058"></a>00058 <span class="comment">    instance creation function that will allocate a new Clock. </span>
<a name="l00059"></a>00059 <span class="comment">    </span>
<a name="l00060"></a>00060 <span class="comment">    @code</span>
<a name="l00061"></a>00061 <span class="comment">    void *mymetro_create (double defaultInterval) </span>
<a name="l00062"></a>00062 <span class="comment">    { </span>
<a name="l00063"></a>00063 <span class="comment">        t_mymetro *x; </span>
<a name="l00064"></a>00064 <span class="comment">        x = (t_mymetro *)newobject(mymetro_class); // allocate space</span>
<a name="l00065"></a>00065 <span class="comment">        x-&gt;m_clock = clock_new(x,(method)mymetro_tick); // make a clock</span>
<a name="l00066"></a>00066 <span class="comment">        x-&gt;m_interval = defaultInterval; // store the interval </span>
<a name="l00067"></a>00067 <span class="comment">        x-&gt;m_outlet = bangout(x); // outlet for ticks</span>
<a name="l00068"></a>00068 <span class="comment">        return x; // return the new object</span>
<a name="l00069"></a>00069 <span class="comment">    } </span>
<a name="l00070"></a>00070 <span class="comment">    @endcode</span>
<a name="l00071"></a>00071 <span class="comment">    </span>
<a name="l00072"></a>00072 <span class="comment">    Here’s the method written to respond to the bang message that starts </span>
<a name="l00073"></a>00073 <span class="comment">    the metronome. </span>
<a name="l00074"></a>00074 <span class="comment">    </span>
<a name="l00075"></a>00075 <span class="comment">    @code</span>
<a name="l00076"></a>00076 <span class="comment">    void mymetro_bang (t_mymetro *x) </span>
<a name="l00077"></a>00077 <span class="comment">    { </span>
<a name="l00078"></a>00078 <span class="comment">        clock_fdelay(x-&gt;m_clock,0.); </span>
<a name="l00079"></a>00079 <span class="comment">    } </span>
<a name="l00080"></a>00080 <span class="comment">    @endcode</span>
<a name="l00081"></a>00081 <span class="comment">    </span>
<a name="l00082"></a>00082 <span class="comment">    Here’s the Clock function. </span>
<a name="l00083"></a>00083 <span class="comment">    </span>
<a name="l00084"></a>00084 <span class="comment">    @code</span>
<a name="l00085"></a>00085 <span class="comment">    void mymetro_tick(t_mymetro *x) </span>
<a name="l00086"></a>00086 <span class="comment">    { </span>
<a name="l00087"></a>00087 <span class="comment">        clock_fdelay(x-&gt;m_clock, x-&gt;m_interval); </span>
<a name="l00088"></a>00088 <span class="comment">        // schedule another metronome tick</span>
<a name="l00089"></a>00089 <span class="comment">        outlet_bang(x-&gt;m_outlet); // send out a bang</span>
<a name="l00090"></a>00090 <span class="comment">    } </span>
<a name="l00091"></a>00091 <span class="comment">    @endcode</span>
<a name="l00092"></a>00092 <span class="comment">    </span>
<a name="l00093"></a>00093 <span class="comment">    You may also want to stop the metronome at some point. Here’s a </span>
<a name="l00094"></a>00094 <span class="comment">    method written to respond to the message stop. It uses clock_unset. </span>
<a name="l00095"></a>00095 <span class="comment">    </span>
<a name="l00096"></a>00096 <span class="comment">    @code</span>
<a name="l00097"></a>00097 <span class="comment">    void mymetro_stop (t_mymetro *x) </span>
<a name="l00098"></a>00098 <span class="comment">    { </span>
<a name="l00099"></a>00099 <span class="comment">        clock_unset(x-&gt;m_clock); </span>
<a name="l00100"></a>00100 <span class="comment">    }</span>
<a name="l00101"></a>00101 <span class="comment">    @endcode</span>
<a name="l00102"></a>00102 <span class="comment">    </span>
<a name="l00103"></a>00103 <span class="comment">    In your object’s free function, you should call freeobject on any </span>
<a name="l00104"></a>00104 <span class="comment">    Clocks you’ve created. </span>
<a name="l00105"></a>00105 <span class="comment">    </span>
<a name="l00106"></a>00106 <span class="comment">    @code</span>
<a name="l00107"></a>00107 <span class="comment">    void mymetro_free (MyMetro *x) </span>
<a name="l00108"></a>00108 <span class="comment">    { </span>
<a name="l00109"></a>00109 <span class="comment">        freeobject((t_object *)x-&gt;m_clock); </span>
<a name="l00110"></a>00110 <span class="comment">    }</span>
<a name="l00111"></a>00111 <span class="comment">    @endcode</span>
<a name="l00112"></a>00112 <span class="comment"></span>
<a name="l00113"></a>00113 <span class="comment"></span>
<a name="l00114"></a>00114 <span class="comment">    @section setclock Scheduling with setclock Objects</span>
<a name="l00115"></a>00115 <span class="comment">    </span>
<a name="l00116"></a>00116 <span class="comment">    The setclock object allows a more general way of scheduling Clocks by </span>
<a name="l00117"></a>00117 <span class="comment">    generalizing the advancement of the time associated with a scheduler. </span>
<a name="l00118"></a>00118 <span class="comment">    Each setclock object’s “time” can be changed by a process other than the </span>
<a name="l00119"></a>00119 <span class="comment">    internal millisecond clock. In addition, the object implements routines </span>
<a name="l00120"></a>00120 <span class="comment">    that modify the mapping of the internal millisecond clock onto the </span>
<a name="l00121"></a>00121 <span class="comment">    current value of time in an object. Your object can call a set of routines </span>
<a name="l00122"></a>00122 <span class="comment">    that use either setclock or the normal millisecond clock transparently. </span>
<a name="l00123"></a>00123 <span class="comment">    Many Max objects accept the message clock followed by an optional </span>
<a name="l00124"></a>00124 <span class="comment">    symbol to set their internal scheduling to a named setclock object. The </span>
<a name="l00125"></a>00125 <span class="comment">    typical implementation passes the binding of a Symbol (the s_thing </span>
<a name="l00126"></a>00126 <span class="comment">    field) to the Setclock functions. By default, the empty symbol is passed. </span>
<a name="l00127"></a>00127 <span class="comment">    If the binding has been linked to a setclock object, it will be used to </span>
<a name="l00128"></a>00128 <span class="comment">    schedule the Clock. Otherwise, the Clock is scheduled using the main </span>
<a name="l00129"></a>00129 <span class="comment">    internal millisecond scheduler. The Setclock data structure is a </span>
<a name="l00130"></a>00130 <span class="comment">    replacement for void * since there will be no reason for external </span>
<a name="l00131"></a>00131 <span class="comment">    objects to access it directly.</span>
<a name="l00132"></a>00132 <span class="comment">    </span>
<a name="l00133"></a>00133 <span class="comment">    @subsection setclock_using_the_routines Using the setclock Object Routines</span>
<a name="l00134"></a>00134 <span class="comment">    </span>
<a name="l00135"></a>00135 <span class="comment">    Here’s an example implementation of the relevant methods of a </span>
<a name="l00136"></a>00136 <span class="comment">    metronome object using the Setclock routines.</span>
<a name="l00137"></a>00137 <span class="comment">    </span>
<a name="l00138"></a>00138 <span class="comment">    @code</span>
<a name="l00139"></a>00139 <span class="comment">    typedef struct metro </span>
<a name="l00140"></a>00140 <span class="comment">    { </span>
<a name="l00141"></a>00141 <span class="comment">        t_object m_ob; </span>
<a name="l00142"></a>00142 <span class="comment">        long m_interval; </span>
<a name="l00143"></a>00143 <span class="comment">        long m_running; </span>
<a name="l00144"></a>00144 <span class="comment">        void *m_clock; </span>
<a name="l00145"></a>00145 <span class="comment">        t_symbol *m_setclock; </span>
<a name="l00146"></a>00146 <span class="comment">    } t_metro;</span>
<a name="l00147"></a>00147 <span class="comment">    @endcode</span>
<a name="l00148"></a>00148 <span class="comment">    </span>
<a name="l00149"></a>00149 <span class="comment">    Here’s the implementation of the routines for turning the metronome </span>
<a name="l00150"></a>00150 <span class="comment">    on and off. Assume that in the instance creation function, the </span>
<a name="l00151"></a>00151 <span class="comment">    #t_symbol m_setclock has been set to the empty symbol (gensym </span>
<a name="l00152"></a>00152 <span class="comment">    ("")) and m_clock has been created; the clock function </span>
<a name="l00153"></a>00153 <span class="comment">    metro_tick() is defined further on.</span>
<a name="l00154"></a>00154 <span class="comment">    </span>
<a name="l00155"></a>00155 <span class="comment">    @code</span>
<a name="l00156"></a>00156 <span class="comment">    void metro_bang(Metro *x) // turn metronome on</span>
<a name="l00157"></a>00157 <span class="comment">    { </span>
<a name="l00158"></a>00158 <span class="comment">        x-&gt;m_running = 1; </span>
<a name="l00159"></a>00159 <span class="comment">        setclock_delay(x-&gt;m_setclock-&gt;s_thing,x-&gt;m_clock,0); </span>
<a name="l00160"></a>00160 <span class="comment">    } </span>
<a name="l00161"></a>00161 <span class="comment"></span>
<a name="l00162"></a>00162 <span class="comment">    void metro_stop(Metro *x) </span>
<a name="l00163"></a>00163 <span class="comment">    { </span>
<a name="l00164"></a>00164 <span class="comment">        x-&gt;m_running = 0; </span>
<a name="l00165"></a>00165 <span class="comment">        setclock_unset(x-&gt;m_setclock-&gt;s_thing,x-&gt;m_clock); </span>
<a name="l00166"></a>00166 <span class="comment">    }</span>
<a name="l00167"></a>00167 <span class="comment">    @endcode</span>
<a name="l00168"></a>00168 <span class="comment">    </span>
<a name="l00169"></a>00169 <span class="comment">    Here is the implementation of the clock function metro_tick() that </span>
<a name="l00170"></a>00170 <span class="comment">    runs periodically.</span>
<a name="l00171"></a>00171 <span class="comment">    </span>
<a name="l00172"></a>00172 <span class="comment">    @code</span>
<a name="l00173"></a>00173 <span class="comment">    void metro_tick(Metro *x) </span>
<a name="l00174"></a>00174 <span class="comment">    { </span>
<a name="l00175"></a>00175 <span class="comment">        outlet_bang(x-&gt;m_ob.o_outlet); </span>
<a name="l00176"></a>00176 <span class="comment">        if (x-&gt;m_running) </span>
<a name="l00177"></a>00177 <span class="comment">            setclock_delay(x-&gt;m_setclock-&gt;s_thing,x-&gt;m_clock,x-&gt;m_interval); </span>
<a name="l00178"></a>00178 <span class="comment">    } </span>
<a name="l00179"></a>00179 <span class="comment">    @endcode</span>
<a name="l00180"></a>00180 <span class="comment"></span>
<a name="l00181"></a>00181 <span class="comment">    Finally, here is an implementation of the method to respond to the </span>
<a name="l00182"></a>00182 <span class="comment">    clock message. Note that the function tries to verify that a non-zero </span>
<a name="l00183"></a>00183 <span class="comment">    value bound to the #t_symbol passed as an argument is in fact an </span>
<a name="l00184"></a>00184 <span class="comment">    instance of setclock by checking to see if it responds to the unset </span>
<a name="l00185"></a>00185 <span class="comment">    message. If not, the metronome refuses to assign the #t_symbol to its </span>
<a name="l00186"></a>00186 <span class="comment">    internal m_setclock field. </span>
<a name="l00187"></a>00187 <span class="comment"></span>
<a name="l00188"></a>00188 <span class="comment">    @code</span>
<a name="l00189"></a>00189 <span class="comment">    void metro_clock(Metro *x, t_symbol *s) </span>
<a name="l00190"></a>00190 <span class="comment">    { </span>
<a name="l00191"></a>00191 <span class="comment">        void *old = x-&gt;m_setclock-&gt;s_thing; </span>
<a name="l00192"></a>00192 <span class="comment">        void *c = 0; </span>
<a name="l00193"></a>00193 <span class="comment"></span>
<a name="l00194"></a>00194 <span class="comment">        // the line below can be restated as: </span>
<a name="l00195"></a>00195 <span class="comment">        //  if s is the empty symbol </span>
<a name="l00196"></a>00196 <span class="comment">        //  or s-&gt;s_thing is zero </span>
<a name="l00197"></a>00197 <span class="comment">        //  or s-&gt;s_thing is non-zero and a setclock object  </span>
<a name="l00198"></a>00198 <span class="comment">        if ((s == gensym("")) || ((c = s-&gt;s_thing) &amp;&amp; zgetfn(c,&amp;s_unset))) </span>
<a name="l00199"></a>00199 <span class="comment">        { </span>
<a name="l00200"></a>00200 <span class="comment">            if (old) </span>
<a name="l00201"></a>00201 <span class="comment">                setclock_unset(old,x-&gt;m_clock); </span>
<a name="l00202"></a>00202 <span class="comment">            x-&gt;m_setclock = s; </span>
<a name="l00203"></a>00203 <span class="comment">            if (x-&gt;m_running) </span>
<a name="l00204"></a>00204 <span class="comment">                setclock_delay(c,x-&gt;m_clock,0L); </span>
<a name="l00205"></a>00205 <span class="comment">        } </span>
<a name="l00206"></a>00206 <span class="comment">    } </span>
<a name="l00207"></a>00207 <span class="comment">    @endcode</span>
<a name="l00208"></a>00208 <span class="comment"></span>
<a name="l00209"></a>00209 <span class="comment"></span>
<a name="l00210"></a>00210 <span class="comment"></span>
<a name="l00211"></a>00211 <span class="comment">    @section creating_schedulers Creating Schedulers</span>
<a name="l00212"></a>00212 <span class="comment">    </span>
<a name="l00213"></a>00213 <span class="comment">    If you want to schedule events independently of the time of the global </span>
<a name="l00214"></a>00214 <span class="comment">    Max scheduler, you can create your own scheduler with </span>
<a name="l00215"></a>00215 <span class="comment">    scheduler_new(). By calling scheduler_set() with the newly created </span>
<a name="l00216"></a>00216 <span class="comment">    scheduler, calls to clock_new() will create Clocks tied to your scheduler </span>
<a name="l00217"></a>00217 <span class="comment">    instead of Max’s global one. You can then control the time of the </span>
<a name="l00218"></a>00218 <span class="comment">    scheduler (using scheduler_settime()) as well as when it executes </span>
<a name="l00219"></a>00219 <span class="comment">    clock functions (using scheduler_run()). This is a more general </span>
<a name="l00220"></a>00220 <span class="comment">    facility than the setclock object routines, but unlike using the time </span>
<a name="l00221"></a>00221 <span class="comment">    from a setclock object to determine when a Clock function runs, once </span>
<a name="l00222"></a>00222 <span class="comment">    a Clock is tied to a scheduler. </span>
<a name="l00223"></a>00223 <span class="comment"></span>
<a name="l00224"></a>00224 <span class="comment">*/</span>
<a name="l00225"></a>00225 
<a name="l00226"></a>00226 
<a name="l00227"></a>00227 
<a name="l00228"></a>00228 <span class="comment"></span>
<a name="l00229"></a>00229 <span class="comment">/**</span>
<a name="l00230"></a>00230 <span class="comment">    @defgroup qelems Qelems</span>
<a name="l00231"></a>00231 <span class="comment">    @ingroup sched</span>
<a name="l00232"></a>00232 <span class="comment">    </span>
<a name="l00233"></a>00233 <span class="comment">    Your object’s methods may be called at interrupt level. This happens </span>
<a name="l00234"></a>00234 <span class="comment">    when the user has Overdrive mode enabled and one of your methods is </span>
<a name="l00235"></a>00235 <span class="comment">    called, directly or indirectly, from a scheduler Clock function. This </span>
<a name="l00236"></a>00236 <span class="comment">    means that you cannot count on doing certain things—like drawing, </span>
<a name="l00237"></a>00237 <span class="comment">    asking the user what file they would like opened, or calling any </span>
<a name="l00238"></a>00238 <span class="comment">    Macintosh toolbox trap that allocates or purges memory—from within </span>
<a name="l00239"></a>00239 <span class="comment">    any method that responds to any message that could be sent directly </span>
<a name="l00240"></a>00240 <span class="comment">    from another Max object. The mechanism you’ll use to get around this </span>
<a name="l00241"></a>00241 <span class="comment">    limitation is the Qelem (queue element) structure. Qelems also allow </span>
<a name="l00242"></a>00242 <span class="comment">    processor-intensive tasks to be done at a lower priority than in an </span>
<a name="l00243"></a>00243 <span class="comment">    interrupt. As an example, drawing on the screen, especially in color, </span>
<a name="l00244"></a>00244 <span class="comment">    takes a long time in comparison with a task like sending MIDI data. </span>
<a name="l00245"></a>00245 <span class="comment">    </span>
<a name="l00246"></a>00246 <span class="comment">    A Qelem works very much like a Clock. You create a new Qelem in </span>
<a name="l00247"></a>00247 <span class="comment">    your creation function with qelem_new and store a pointer to it in </span>
<a name="l00248"></a>00248 <span class="comment">    your object. Then you write a queue function, very much like the clock </span>
<a name="l00249"></a>00249 <span class="comment">    function (it takes the same single argument that will usually be a </span>
<a name="l00250"></a>00250 <span class="comment">    pointer to your object) that will be called when the Qelem has been set. </span>
<a name="l00251"></a>00251 <span class="comment">    You set the Qelem to run its function by calling qelem_set(). </span>
<a name="l00252"></a>00252 <span class="comment">    </span>
<a name="l00253"></a>00253 <span class="comment">    Often you’ll want to use Qelems and Clocks together. For example, </span>
<a name="l00254"></a>00254 <span class="comment">    suppose you want to update the display for a counter that changes 20 </span>
<a name="l00255"></a>00255 <span class="comment">    times a second. This can be accomplished by writing a Clock function </span>
<a name="l00256"></a>00256 <span class="comment">    that calls qelem_set() and then reschedules itself for 50 milliseconds </span>
<a name="l00257"></a>00257 <span class="comment">    later using the technique shown in the metronome example above. </span>
<a name="l00258"></a>00258 <span class="comment">    This scheme works even if you call qelem_set() faster than the </span>
<a name="l00259"></a>00259 <span class="comment">    computer can draw the counter, because if a Qelem is already set, </span>
<a name="l00260"></a>00260 <span class="comment">    qelem_set() will not set it again. However, when drawing the counter, </span>
<a name="l00261"></a>00261 <span class="comment">    you’ll display its current value, not a specific value generated in the </span>
<a name="l00262"></a>00262 <span class="comment">    Clock function. </span>
<a name="l00263"></a>00263 <span class="comment">    </span>
<a name="l00264"></a>00264 <span class="comment">    Note that the Qelem-based defer mechanism discussed later in this </span>
<a name="l00265"></a>00265 <span class="comment">    chapter may be easier for lowering the priority of one-time events, </span>
<a name="l00266"></a>00266 <span class="comment">    such as opening a standard file dialog box in response to a read </span>
<a name="l00267"></a>00267 <span class="comment">    message. </span>
<a name="l00268"></a>00268 <span class="comment">    </span>
<a name="l00269"></a>00269 <span class="comment">    If your Qelem routine sends messages using outlet_int() or any other </span>
<a name="l00270"></a>00270 <span class="comment">    of the outlet functions, it needs to use the lockout mechanism </span>
<a name="l00271"></a>00271 <span class="comment">    described in the Interrupt Level Considerations section.</span>
<a name="l00272"></a>00272 <span class="comment">*/</span>
<a name="l00273"></a>00273 
<a name="l00274"></a>00274 
<a name="l00275"></a>00275 
<a name="l00276"></a>00276 <span class="comment"></span>
<a name="l00277"></a>00277 <span class="comment">/**</span>
<a name="l00278"></a>00278 <span class="comment">    @defgroup systime Systime API</span>
<a name="l00279"></a>00279 <span class="comment">    @ingroup sched</span>
<a name="l00280"></a>00280 <span class="comment">    </span>
<a name="l00281"></a>00281 <span class="comment">    The Systime API provides the means of getting the system time, </span>
<a name="l00282"></a>00282 <span class="comment">    instead of the scheduler time as you would with functions like gettime().</span>
<a name="l00283"></a>00283 <span class="comment">*/</span>
<a name="l00284"></a>00284 
<a name="l00285"></a>00285 <span class="comment"></span>
<a name="l00286"></a>00286 <span class="comment">/**</span>
<a name="l00287"></a>00287 <span class="comment"> @defgroup time ITM Time Objects</span>
<a name="l00288"></a>00288 <span class="comment"> @ingroup sched</span>
<a name="l00289"></a>00289 <span class="comment"> </span>
<a name="l00290"></a>00290 <span class="comment"> ITM Time Objects are a high-level interface to ITM, a tempo-based scheduler API. They provide an abtraction so your object can schedule events either in milliseconds (as traditional clock objects) or ticks (tempo-relative units).</span>
<a name="l00291"></a>00291 <span class="comment"></span>
<a name="l00292"></a>00292 <span class="comment">*/</span>
<a name="l00293"></a>00293 
</pre></div></div>
		<div id="c74footer">
			<p>Copyright &copy; 2008, <a href="http://www.cycling74.com/">Cycling '74</a></p>
		</div>
	</body>
</html>
