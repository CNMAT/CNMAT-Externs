<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
		<title>Max5 API Reference</title>
		<link href="c74-doxygen.css" rel="stylesheet" type="text/css">
	</head>
	<body>

		<div id="c74header">
			<img src="max5.png" />
			<p>Max 5 API Reference</p>
		</div>

<!-- Generated by Doxygen 1.5.6 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<h1>api_04_inout.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/** </span>
<a name="l00002"></a>00002 <span class="comment">    @page chapter_inout Inlets and Outlets</span>
<a name="l00003"></a>00003 <span class="comment"></span>
<a name="l00004"></a>00004 <span class="comment">    You are familiar with inlets and outlets when connecting two objects together in a patcher. To receive data in your object or send data to other objects, you need to create the C versions of inlets and outlets. In this section, we'll explain what inlets and outlets are, how to create them, and how to use them. We'll also discuss a more advanced type of inlet called a proxy that permits a message to be received in any of your object's inlets. Proxies are used by audio objects to permit inlets to handle both signals and normal Max messages.</span>
<a name="l00005"></a>00005 <span class="comment"> </span>
<a name="l00006"></a>00006 <span class="comment">    By default, every object shows one inlet. Additional inlets appear to the right of the default inlet, with the rightmost inlet being created last.</span>
<a name="l00007"></a>00007 <span class="comment"></span>
<a name="l00008"></a>00008 <span class="comment">    Inlets are essentially message translators. For example, if you create an int inlet, your object will receive the "in1" message instead of the "int" message when a number arrives at this newly created inlet. You can use the different message name to define special behavior for numbers arriving at each inlet. For example, a basic arithmetic object in Max such as + stores the number to be added when it arrives in the right inlet, but performs the computation and outputs the result when a number arrives in the left inlet. </span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">    Outlets define connections between objects and are used to send messages from your object to the objects to which it is connected. What is not obvious about an outlet, however, is that when you send a number out an outlet, the outlet-sending function does not return until all computation "below" the outlet has completed. This stack-based execution model is best illustrated by observing a patch with the Max debugger window. To understand this stack-based model it may be helpful to use the breakpoint and debugging features in Max and follow the stack display as you step through the execution of a patch.  Outlets, like inlets, appear in the order you create them from right-to-left. In other words, the first inlet or outlet you create will be the visually farthest to the right.</span>
<a name="l00011"></a>00011 <span class="comment"></span>
<a name="l00012"></a>00012 <span class="comment"></span>
<a name="l00013"></a>00013 <span class="comment">    @section chapter_inout_inlets Creating and Using Inlets</span>
<a name="l00014"></a>00014 <span class="comment"></span>
<a name="l00015"></a>00015 <span class="comment">    Proper use of an inlet involves two steps: first, add a method that will respond to the message sent via the inlet in your initialization routine, and second, create the inlet in your new instance routine. (Creating inlets at any other time is not supported.)</span>
<a name="l00016"></a>00016 <span class="comment"></span>
<a name="l00017"></a>00017 <span class="comment">    There are three types of inlets: int, float, and custom. We'll only describe int and float inlets here because proxies are generally a better way to create an inlet that can respond to any message. For int inlets, you'll bind a function to a message "in1", "in2", "in3" etc. depending on the inlet number you assign. Here's how to create a single inlet using "in1"...</span>
<a name="l00018"></a>00018 <span class="comment"></span>
<a name="l00019"></a>00019 <span class="comment">    In your initialization routine:</span>
<a name="l00020"></a>00020 <span class="comment">@code</span>
<a name="l00021"></a>00021 <span class="comment">        class_addmethod(c, (method)myobject_in1, "in1", A_LONG, 0);</span>
<a name="l00022"></a>00022 <span class="comment">@endcode</span>
<a name="l00023"></a>00023 <span class="comment"></span>
<a name="l00024"></a>00024 <span class="comment">    In your new instance routine, after calling object_alloc() to create your instance:</span>
<a name="l00025"></a>00025 <span class="comment">@code</span>
<a name="l00026"></a>00026 <span class="comment">        intin(x, 1);</span>
<a name="l00027"></a>00027 <span class="comment">@endcode</span>
<a name="l00028"></a>00028 <span class="comment"></span>
<a name="l00029"></a>00029 <span class="comment">    The method that will be called when an int is received in the right inlet:</span>
<a name="l00030"></a>00030 <span class="comment">@code</span>
<a name="l00031"></a>00031 <span class="comment">    void myobject_in1(t_myobject *x, long n)</span>
<a name="l00032"></a>00032 <span class="comment">    {</span>
<a name="l00033"></a>00033 <span class="comment">        // do something with n</span>
<a name="l00034"></a>00034 <span class="comment">    }</span>
<a name="l00035"></a>00035 <span class="comment">@endcode</span>
<a name="l00036"></a>00036 <span class="comment"></span>
<a name="l00037"></a>00037 <span class="comment">    Creating a single inlet in this way gives your object two inlets (remember that it always has one by default).</span>
<a name="l00038"></a>00038 <span class="comment">    If you want to create multiple inlets, you'll need to create them in order from right to left, as shown below:</span>
<a name="l00039"></a>00039 <span class="comment">@code</span>
<a name="l00040"></a>00040 <span class="comment">        intin(x, 2);        // creates an inlet (the right inlet) that will send your object the "in2" message</span>
<a name="l00041"></a>00041 <span class="comment">        intin(x, 1);        // creates an inlet (the middle inlet) that will send your object the "in1" message</span>
<a name="l00042"></a>00042 <span class="comment">@endcode</span>
<a name="l00043"></a>00043 <span class="comment"></span>
<a name="l00044"></a>00044 <span class="comment">    Inlets that send float messages to your object are created with floatin() and translate the float message into "ft1","ft2","ft3" etc. Example:</span>
<a name="l00045"></a>00045 <span class="comment"></span>
<a name="l00046"></a>00046 <span class="comment">    In initialization routine:</span>
<a name="l00047"></a>00047 <span class="comment">@code</span>
<a name="l00048"></a>00048 <span class="comment">        class_addmethod(c, (method)myobject_ft1, "ft1", A_FLOAT, 0);</span>
<a name="l00049"></a>00049 <span class="comment">@endcode</span>
<a name="l00050"></a>00050 <span class="comment"></span>
<a name="l00051"></a>00051 <span class="comment">    In new instance routine:</span>
<a name="l00052"></a>00052 <span class="comment">@code</span>
<a name="l00053"></a>00053 <span class="comment">        floatin(x, 1);</span>
<a name="l00054"></a>00054 <span class="comment">@endcode</span>
<a name="l00055"></a>00055 <span class="comment"></span>
<a name="l00056"></a>00056 <span class="comment">    Method:</span>
<a name="l00057"></a>00057 <span class="comment">@code</span>
<a name="l00058"></a>00058 <span class="comment">    void myobject_ft1(t_myobject *x, double f)</span>
<a name="l00059"></a>00059 <span class="comment">    {</span>
<a name="l00060"></a>00060 <span class="comment">        post("float %.2f received in right inlet,f);</span>
<a name="l00061"></a>00061 <span class="comment">    }</span>
<a name="l00062"></a>00062 <span class="comment">@endcode</span>
<a name="l00063"></a>00063 <span class="comment"></span>
<a name="l00064"></a>00064 <span class="comment">    Note that you can mix int and float inlets, but each inlet must have a unique number. Example:</span>
<a name="l00065"></a>00065 <span class="comment">@code</span>
<a name="l00066"></a>00066 <span class="comment">        intin(x, 2);</span>
<a name="l00067"></a>00067 <span class="comment">        floatin(x, 1);</span>
<a name="l00068"></a>00068 <span class="comment">@endcode</span>
<a name="l00069"></a>00069 <span class="comment"></span>
<a name="l00070"></a>00070 <span class="comment"></span>
<a name="l00071"></a>00071 <span class="comment">    @section chapter_inout_outlets Creating and Using Outlets</span>
<a name="l00072"></a>00072 <span class="comment"></span>
<a name="l00073"></a>00073 <span class="comment">    You create outlets in your new instance routine. Outlet creators return a pointer that you should store for later use when you want to send a message. As with inlets, outlets are created from right to left.</span>
<a name="l00074"></a>00074 <span class="comment"></span>
<a name="l00075"></a>00075 <span class="comment">    Here's a simple example. First we'll add two void pointers to our data structure to store the outlets for each instance.</span>
<a name="l00076"></a>00076 <span class="comment">@code</span>
<a name="l00077"></a>00077 <span class="comment">    typedef struct _myobject</span>
<a name="l00078"></a>00078 <span class="comment">    {</span>
<a name="l00079"></a>00079 <span class="comment">        t_object m_ob;</span>
<a name="l00080"></a>00080 <span class="comment">        void *m_outlet1;</span>
<a name="l00081"></a>00081 <span class="comment">        void *m_outlet2;</span>
<a name="l00082"></a>00082 <span class="comment">    } t_myobject;</span>
<a name="l00083"></a>00083 <span class="comment">@endcode</span>
<a name="l00084"></a>00084 <span class="comment"></span>
<a name="l00085"></a>00085 <span class="comment">    Then we'll create the outlets in our new instance routine.</span>
<a name="l00086"></a>00086 <span class="comment">@code</span>
<a name="l00087"></a>00087 <span class="comment">        x = (t_myobject *)object_alloc(s_myobject_class);</span>
<a name="l00088"></a>00088 <span class="comment">        x-&gt;m_outlet2 = bangout((t_object *)x);</span>
<a name="l00089"></a>00089 <span class="comment">        x-&gt;m_outlet1 = intout((t_object *)x);</span>
<a name="l00090"></a>00090 <span class="comment">        return x;</span>
<a name="l00091"></a>00091 <span class="comment">@endcode</span>
<a name="l00092"></a>00092 <span class="comment"></span>
<a name="l00093"></a>00093 <span class="comment">    These outlets are type-specific, meaning that we will always send the same type of message through them. If you want to create outlets that can send any message, use outlet_new(). Type-specific outlets execute faster, because they make a direct connection to the method handler that will be called at the time you send a message. When we want to send messages out these outlets, say, in our bang method, we do the following:</span>
<a name="l00094"></a>00094 <span class="comment"></span>
<a name="l00095"></a>00095 <span class="comment">@code</span>
<a name="l00096"></a>00096 <span class="comment">    void myobject_bang(t_myobject *x)</span>
<a name="l00097"></a>00097 <span class="comment">    {</span>
<a name="l00098"></a>00098 <span class="comment">        outlet_bang(x-&gt;m_outlet2);</span>
<a name="l00099"></a>00099 <span class="comment">        outlet_int(x-&gt;m_outlet1, 74);</span>
<a name="l00100"></a>00100 <span class="comment">    }</span>
<a name="l00101"></a>00101 <span class="comment">@endcode</span>
<a name="l00102"></a>00102 <span class="comment"></span>
<a name="l00103"></a>00103 <span class="comment">    The bang method above sends the bang message out the m_outlet2 outlet first, then sends the number 74 out the m_outlet1. This is consistent with the general design in Max to send values out outlets from right to left. However, there is nothing enforcing this design, and you could reverse the statements if you felt like it.</span>
<a name="l00104"></a>00104 <span class="comment"></span>
<a name="l00105"></a>00105 <span class="comment">    A more general message-sending routine, outlet_anything(), will be shown in the @ref chapter_atoms section.</span>
<a name="l00106"></a>00106 <span class="comment"></span>
<a name="l00107"></a>00107 <span class="comment"></span>
<a name="l00108"></a>00108 <span class="comment">    @section chapter_inout_proxies Creating and Using Proxies</span>
<a name="l00109"></a>00109 <span class="comment"></span>
<a name="l00110"></a>00110 <span class="comment">    A proxy is a small object that controls an inlet, but does not translate the message it receives. Instead it sets a location inside your object's data structure to a value you associate with the inlet. If the message comes "directly" to your object via the left inlet, the value will be 0.  However, in order to be thread-safe, you should not read the value of this "inlet number" directly. Instead, you'll use the proxy_getinlet() routine to determine the inlet that has received the message.</span>
<a name="l00111"></a>00111 <span class="comment"></span>
<a name="l00112"></a>00112 <span class="comment">    The advantage of proxies over regular inlets is that your object can respond to any message in all of its inlets, not just the left inlet. As a Max user, you may already appreciate the proxy feature without knowing it. For example, the pack object can combine ints, floats, lists, or symbols arriving in any of its inlets. It uses proxies to make this happen. MSP audio objects that accept signals in more than one inlet use proxies as well. In fact, the proxy capability is built into the way you create audio objects, as will be discussed in the @ref chapter_msp_anatomy section.</span>
<a name="l00113"></a>00113 <span class="comment"></span>
<a name="l00114"></a>00114 <span class="comment">    If your object's non-left inlets will only respond to ints or floats, implementing proxies is usually overkill.</span>
<a name="l00115"></a>00115 <span class="comment"></span>
<a name="l00116"></a>00116 <span class="comment">    @section chapter_inout_example Example</span>
<a name="l00117"></a>00117 <span class="comment"></span>
<a name="l00118"></a>00118 <span class="comment">    First, add a place in your object to store the proxy value. You shouldn't access this directly, but the proxy needs it. Second, you'll need to store the proxy, because you need to free it when your object goes away. If you create many proxies, you'll need to store pointers to all of them, but all proxies share the same long integer value field.</span>
<a name="l00119"></a>00119 <span class="comment"></span>
<a name="l00120"></a>00120 <span class="comment">@code</span>
<a name="l00121"></a>00121 <span class="comment">    typedef struct _myobject</span>
<a name="l00122"></a>00122 <span class="comment">    {</span>
<a name="l00123"></a>00123 <span class="comment">        t_object m_obj;</span>
<a name="l00124"></a>00124 <span class="comment">        long m_in;          // space for the inlet number used by all the proxies</span>
<a name="l00125"></a>00125 <span class="comment">        void *m_proxy;</span>
<a name="l00126"></a>00126 <span class="comment">    } t_myobject;</span>
<a name="l00127"></a>00127 <span class="comment">@endcode</span>
<a name="l00128"></a>00128 <span class="comment"></span>
<a name="l00129"></a>00129 <span class="comment">    In your new instance routine, create the proxy, passing your object, a non-zero code value associated with the proxy, and a pointer to your object's inlet number location.</span>
<a name="l00130"></a>00130 <span class="comment"> </span>
<a name="l00131"></a>00131 <span class="comment">@code</span>
<a name="l00132"></a>00132 <span class="comment">        x-&gt;m_proxy = proxy_new((t_object *)x, 1, &amp;x-&gt;m_in);</span>
<a name="l00133"></a>00133 <span class="comment">@endcode</span>
<a name="l00134"></a>00134 <span class="comment"></span>
<a name="l00135"></a>00135 <span class="comment">    If you want to create regular inlets for your object, you can do so. Proxies and regular inlets can be mixed, although such a design might confuse a user of your object.</span>
<a name="l00136"></a>00136 <span class="comment"></span>
<a name="l00137"></a>00137 <span class="comment">    Finally, here is a method that takes a different action depending on the value of x-&gt;m_in that we check using proxy_getinlet().</span>
<a name="l00138"></a>00138 <span class="comment"></span>
<a name="l00139"></a>00139 <span class="comment">@code</span>
<a name="l00140"></a>00140 <span class="comment">     void myobject_bang(t_myobject *x)</span>
<a name="l00141"></a>00141 <span class="comment">    {</span>
<a name="l00142"></a>00142 <span class="comment">        switch (proxy_getinlet((t_object *)x)) {</span>
<a name="l00143"></a>00143 <span class="comment">            case 0:</span>
<a name="l00144"></a>00144 <span class="comment">                post("bang received in left inlet");</span>
<a name="l00145"></a>00145 <span class="comment">                break;</span>
<a name="l00146"></a>00146 <span class="comment">            case 1:</span>
<a name="l00147"></a>00147 <span class="comment">                post("bang received in right inlet");</span>
<a name="l00148"></a>00148 <span class="comment">                break;</span>
<a name="l00149"></a>00149 <span class="comment">        }</span>
<a name="l00150"></a>00150 <span class="comment">    }</span>
<a name="l00151"></a>00151 <span class="comment">@endcode</span>
<a name="l00152"></a>00152 <span class="comment"></span>
<a name="l00153"></a>00153 <span class="comment">*/</span>
</pre></div></div>
		<div id="c74footer">
			<p>Copyright &copy; 2008, <a href="http://www.cycling74.com/">Cycling '74</a></p>
		</div>
	</body>
</html>
