<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
		<title>Max5 API Reference</title>
		<link href="c74-doxygen.css" rel="stylesheet" type="text/css">
	</head>
	<body>

		<div id="c74header">
			<img src="max5.png" />
			<p>Max 5 API Reference</p>
		</div>

<!-- Generated by Doxygen 1.5.6 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<h1>api_18_itm.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/** </span>
<a name="l00002"></a>00002 <span class="comment">    @page chapter_itm ITM</span>
<a name="l00003"></a>00003 <span class="comment"></span>
<a name="l00004"></a>00004 <span class="comment">    ITM is the tempo-based timing system introduced with Max 5. It allows users to express time in tempo-relative units as well as milliseconds, samples, and an ISO 8601 hour-minute-second format. In addition, ITM supports one or more transports, which can be synchronized to external sources. An ITM-aware object can schedule events to occur when the transport reaches a specific time, or find out the current transport state.</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment">    The ITM API is provided on two different levels. The  @ref time interface provides a higher-level way to parse time format information and schedule events. For more control, you can use lower-level routines to access ITM objects directly. An ITM object is responsible for maintaining the current time and scheduling events. There can be multiple ITM objects in Max, each running independently of the others.</span>
<a name="l00007"></a>00007 <span class="comment"></span>
<a name="l00008"></a>00008 <span class="comment"> </span>
<a name="l00009"></a>00009 <span class="comment">@section chapter_itm_temp Scheduling Temporary Events</span>
<a name="l00010"></a>00010 <span class="comment"></span>
<a name="l00011"></a>00011 <span class="comment"></span>
<a name="l00012"></a>00012 <span class="comment">    There are two kinds of events in ITM. Temporary events are analogous to Max clock objects in that they are scheduled and fire at a dynamically assigned time. Once they have executed, they are removed from the scheduler. Permanent events always fire when the transport reaches a specific time, and are not removed from the scheduler. The ITM-aware metro is an example of an object that uses temporary events, while the timepoint object uses permanent events. We'll show how to work both types using an example included in the SDK called delay2. The existing Max delay object provides this capability, but this example shows most of the things you can do with the time object interface. To see the complete object, look at the &lt;a href="delay2_8c-source.html"&gt;delay2 example&lt;/a&gt;. We'll introduce a simpler version of the object, then proceed to add the quantization and the additional outlet that generates a delayed bang based on low-level ITM calls.</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment">    The ITM time object API is based on a Max object you create that packages up common ways you will be using ITM, including attribute support, quantization, and, if you want it, the ability to switch between traditional millisecond-based timing and tempo-based timing using an interface that is consistent with the existing Max objects such as metro and delay. (If you haven't familiarized yourself with attributes, you may want to read through the discussion about them in @ref attr before reading further.) </span>
<a name="l00015"></a>00015 <span class="comment"> </span>
<a name="l00016"></a>00016 <span class="comment">    To use the time object, you'll first need to provide some space in your object to hold a pointer to the object(s) you'll be creating.</span>
<a name="l00017"></a>00017 <span class="comment"></span>
<a name="l00018"></a>00018 <span class="comment">@code</span>
<a name="l00019"></a>00019 <span class="comment">    typedef struct _delay2simple</span>
<a name="l00020"></a>00020 <span class="comment">    {</span>
<a name="l00021"></a>00021 <span class="comment">        t_object m_ob;</span>
<a name="l00022"></a>00022 <span class="comment">        t_object *m_timeobj;</span>
<a name="l00023"></a>00023 <span class="comment">        void *m_outlet;</span>
<a name="l00024"></a>00024 <span class="comment">    } _delay2simple;</span>
<a name="l00025"></a>00025 <span class="comment">@endcode</span>
<a name="l00026"></a>00026 <span class="comment"></span>
<a name="l00027"></a>00027 <span class="comment">    Next, in your main routine, you'll create attributes associated with the time object using the class_time_addattr() function.</span>
<a name="l00028"></a>00028 <span class="comment">@code</span>
<a name="l00029"></a>00029 <span class="comment">        class_time_addattr(c, "delaytime", "Delay Time", TIME_FLAGS_TICKSONLY | TIME_FLAGS_USECLOCK | TIME_FLAGS_TRANSPORT);</span>
<a name="l00030"></a>00030 <span class="comment">@endcode</span>
<a name="l00031"></a>00031 <span class="comment"></span>
<a name="l00032"></a>00032 <span class="comment">    The second argument, "delaytime", is a string that names the attribute. Users of your object will be able to change the delay value by sending a delaytime message. "Delay Time" is the label users see for the attribute in the inspector. The flags argument permits you to customize the type of time object you'd like. #TIME_FLAGS_TICKSONLY means that the object can only be specified in tempo-relative units. You would not use this flag if you want the object to use the regular Max scheduler if the user specifies an absolute time (such as milliseconds). #TIME_FLAGS_USECLOCK means that it is a time object that will actually schedule events. If you do not use this flag, you can use the time object to hold and convert time values, which you use to schedule events manually. #TIME_FLAGS_TRANSPORT means that an additional attribute for specifying the transport name is added to your object automatically (it's called "transport" and has the label "Transport Name"). The combination of flags above is appropriate for an object that will be scheduling events on a temporary basis that are only synchronized with the transport and specified in tempo-relative units.</span>
<a name="l00033"></a>00033 <span class="comment"></span>
<a name="l00034"></a>00034 <span class="comment">    The next step is to create a time object in your new instance routine using time_new. The time_new function is something like clock_new -- you pass it a task function that will be executed when the scheduler reaches a certain time (in this case, delay2simple_tick, which will send out a bang). The first argument to time_new is a pointer to your object, the second is the name of the attribute created via class_time_addattr, the third is your task function, and the fourth are flags to control the behavior of the time object, as explained above for class_time_addattr.</span>
<a name="l00035"></a>00035 <span class="comment"> </span>
<a name="l00036"></a>00036 <span class="comment">    Finally, we use time_setvalue to set the initial delay value to 0.</span>
<a name="l00037"></a>00037 <span class="comment">@code</span>
<a name="l00038"></a>00038 <span class="comment">    void *delay2simple_new()</span>
<a name="l00039"></a>00039 <span class="comment">    {</span>
<a name="l00040"></a>00040 <span class="comment">        t_delay2simple *x;</span>
<a name="l00041"></a>00041 <span class="comment">        t_atom a;</span>
<a name="l00042"></a>00042 <span class="comment"> </span>
<a name="l00043"></a>00043 <span class="comment">        x = (t_delay2simple *)object_alloc(s_delay2simple_class);</span>
<a name="l00044"></a>00044 <span class="comment">        x-&gt;m_timeobj = (t_object *)time_new((t_object *)x, gensym("delaytime"), (method)delay2simple_tick, TIME_FLAGS_TICKSONLY | TIME_FLAGS_USECLOCK);</span>
<a name="l00045"></a>00045 <span class="comment">        x-&gt;m_outlet = bangout((t_object *)x);</span>
<a name="l00046"></a>00046 <span class="comment">        atom_setfloat(&amp;a, 0.);</span>
<a name="l00047"></a>00047 <span class="comment">        time_setvalue(x-&gt;d_timeobj, NULL, 1, &amp;a);</span>
<a name="l00048"></a>00048 <span class="comment">        return x;</span>
<a name="l00049"></a>00049 <span class="comment">    }</span>
<a name="l00050"></a>00050 <span class="comment">@endcode</span>
<a name="l00051"></a>00051 <span class="comment"></span>
<a name="l00052"></a>00052 <span class="comment">    To make a delayed bang, we need a delay2simple_bang function that causes our time object to put its task function into the ITM scheduler. This is accomplished using time_schedule. Note that unlike the roughly equivalent clock_fdelay, where the delay time is an argument, the time value must already be stored inside the time object using time_setvalue. The second argument to time_schedule is another time object that can be used to control quantization of an event. Since we aren't using quantization in this simple version of delay2, we pass NULL.</span>
<a name="l00053"></a>00053 <span class="comment">@code</span>
<a name="l00054"></a>00054 <span class="comment">    void delay2simple_bang(t_delay2 *x)</span>
<a name="l00055"></a>00055 <span class="comment">    {</span>
<a name="l00056"></a>00056 <span class="comment">        time_schedule(x-&gt;d_timeobj, NULL);</span>
<a name="l00057"></a>00057 <span class="comment">    }</span>
<a name="l00058"></a>00058 <span class="comment">@endcode</span>
<a name="l00059"></a>00059 <span class="comment"></span>
<a name="l00060"></a>00060 <span class="comment">    Next, our simple task routine, delay2simple_tick. After the specified number of ticks in the time object has elapsed after the call to time_schedule, the task routine will be executed.</span>
<a name="l00061"></a>00061 <span class="comment">@code</span>
<a name="l00062"></a>00062 <span class="comment">    void delay2_tick(t_delay2 *x)</span>
<a name="l00063"></a>00063 <span class="comment">    {</span>
<a name="l00064"></a>00064 <span class="comment">        outlet_bang(x-&gt;d_outlet);</span>
<a name="l00065"></a>00065 <span class="comment">    }</span>
<a name="l00066"></a>00066 <span class="comment">@endcode</span>
<a name="l00067"></a>00067 <span class="comment"> </span>
<a name="l00068"></a>00068 <span class="comment">    Now let's add the two more advanced features found in delay2: quantization and a second (unquantized) bang output using low-level ITM routines. Here is the delay2 data structure. The new elements are a proxy (for receiving a delay time), a time object for quantization (d_quantize), a clock to be used for low-level ITM scheduling, and an outlet for the use of the low-level clock's task.</span>
<a name="l00069"></a>00069 <span class="comment"></span>
<a name="l00070"></a>00070 <span class="comment">@code</span>
<a name="l00071"></a>00071 <span class="comment">    typedef struct delay2</span>
<a name="l00072"></a>00072 <span class="comment">    {</span>
<a name="l00073"></a>00073 <span class="comment">        t_object d_obj;</span>
<a name="l00074"></a>00074 <span class="comment">        void *d_outlet;</span>
<a name="l00075"></a>00075 <span class="comment">        void *d_proxy;</span>
<a name="l00076"></a>00076 <span class="comment">        long d_inletnum;</span>
<a name="l00077"></a>00077 <span class="comment">        t_object *d_timeobj;</span>
<a name="l00078"></a>00078 <span class="comment">        t_object *d_outlet2;</span>
<a name="l00079"></a>00079 <span class="comment">        t_object *d_quantize;</span>
<a name="l00080"></a>00080 <span class="comment">        void *d_clock;</span>
<a name="l00081"></a>00081 <span class="comment"> } t_delay2;</span>
<a name="l00082"></a>00082 <span class="comment">@endcode</span>
<a name="l00083"></a>00083 <span class="comment"> </span>
<a name="l00084"></a>00084 <span class="comment">    In the initialization routine, we'll define a quantization time attribute to work in conjunction with the d_quantize time object we'll be creating. This attribute does not have its own clock to worry about. It just holds a time value, which we specify will only be in ticks (quantizing in milliseconds doesn't make sense in the ITM context). If you build delay2 and open the inspector, you will see time attributes for both Delay Time and Quantization.</span>
<a name="l00085"></a>00085 <span class="comment">@code</span>
<a name="l00086"></a>00086 <span class="comment">    class_time_addattr(c, "quantize", "Quantization", TIME_FLAGS_TICKSONLY);</span>
<a name="l00087"></a>00087 <span class="comment">@endcode</span>
<a name="l00088"></a>00088 <span class="comment"> </span>
<a name="l00089"></a>00089 <span class="comment">Here is part of the revised delay2 new instance routine. It now creates two time objects, plus a regular clock object.</span>
<a name="l00090"></a>00090 <span class="comment"> </span>
<a name="l00091"></a>00091 <span class="comment">@code</span>
<a name="l00092"></a>00092 <span class="comment">    x-&gt;d_inletnum = 0;</span>
<a name="l00093"></a>00093 <span class="comment">    x-&gt;d_proxy = proxy_new(x, 1, &amp;x-&gt;d_inletnum);</span>
<a name="l00094"></a>00094 <span class="comment">    x-&gt;d_outlet2 = bangout(x);</span>
<a name="l00095"></a>00095 <span class="comment">    x-&gt;d_outlet = bangout(x);</span>
<a name="l00096"></a>00096 <span class="comment"></span>
<a name="l00097"></a>00097 <span class="comment">    x-&gt;d_timeobj = (t_object*) time_new((t_object *)x, gensym("delaytime"), (method)delay2_tick, TIME_FLAGS_TICKSONLY | TIME_FLAGS_USECLOCK);</span>
<a name="l00098"></a>00098 <span class="comment">    x-&gt;d_quantize = (t_object*) time_new((t_object *)x, gensym("quantize"), NULL, TIME_FLAGS_TICKSONLY);</span>
<a name="l00099"></a>00099 <span class="comment">    x-&gt;d_clock = clock_new((t_object *)x, (method)delay2_clocktick);</span>
<a name="l00100"></a>00100 <span class="comment">@endcode</span>
<a name="l00101"></a>00101 <span class="comment"> </span>
<a name="l00102"></a>00102 <span class="comment">To use the quantization time object, we can pass it as the second argument to time_schedule. If the value of the quantization is 0, there is no effect. Otherwise, time_schedule will move the event time so it lies on a quantization boundary. For example, if the quantization value is 4n (480 ticks), the delay time is 8n (240 ticks) and current time is 650 ticks, the delay time will be adjusted so that the bang comes out of the delay2 object at 980 ticks instead of 890 ticks.</span>
<a name="l00103"></a>00103 <span class="comment"> </span>
<a name="l00104"></a>00104 <span class="comment">In addition to using quantization with time_schedule, delay2_bang shows how to calculate a millisecond equivalent for an ITM time value using itm_tickstoms. This delay value is not quantized, although you read the time value from the d_quantize object and calculate your own quantized delay if wanted. The "calculated" delay is sent out the right outlet, since the clock we created uses delay2_clocktick.</span>
<a name="l00105"></a>00105 <span class="comment"> </span>
<a name="l00106"></a>00106 <span class="comment">@code</span>
<a name="l00107"></a>00107 <span class="comment">    void delay2_bang(t_delay2 *x)</span>
<a name="l00108"></a>00108 <span class="comment">    {</span>
<a name="l00109"></a>00109 <span class="comment">        double ms, tix;</span>
<a name="l00110"></a>00110 <span class="comment"> </span>
<a name="l00111"></a>00111 <span class="comment">        time_schedule(x-&gt;d_timeobj, x-&gt;d_quantize);</span>
<a name="l00112"></a>00112 <span class="comment"> </span>
<a name="l00113"></a>00113 <span class="comment">        tix = time_getticks(x-&gt;d_timeobj);</span>
<a name="l00114"></a>00114 <span class="comment">        tix += (tix / 2);</span>
<a name="l00115"></a>00115 <span class="comment">        ms = itm_tickstoms(time_getitm(x-&gt;d_timeobj), tix);</span>
<a name="l00116"></a>00116 <span class="comment">        clock_fdelay(x-&gt;d_clock, ms);</span>
<a name="l00117"></a>00117 <span class="comment">    }</span>
<a name="l00118"></a>00118 <span class="comment"> </span>
<a name="l00119"></a>00119 <span class="comment">    void delay2_clocktick(t_delay2 *x)</span>
<a name="l00120"></a>00120 <span class="comment">    {</span>
<a name="l00121"></a>00121 <span class="comment">        outlet_bang(x-&gt;d_outlet2);</span>
<a name="l00122"></a>00122 <span class="comment">    }</span>
<a name="l00123"></a>00123 <span class="comment">@endcode</span>
<a name="l00124"></a>00124 <span class="comment"></span>
<a name="l00125"></a>00125 <span class="comment">@section chapter_itm_permanent Permanent Events</span>
<a name="l00126"></a>00126 <span class="comment"> </span>
<a name="l00127"></a>00127 <span class="comment">    A permanent event in ITM is one that has been scheduled to occur when the transport reaches a specific time. You can schedule a permanent event in terms of ticks or bars/beats/units. An event based in ticks will occur when the transport reaches the specified tick value, and it will not be affected by changes in time signature. An event specified for a time in bars/beats/units will be affected by the time signature. As an example, consider an event scheduled for bar 2, beat 1, unit 0. If the time signature of the ITM object on which the event has been scheduled is 3/4, the event will occur at 480 times 3 or 1440 ticks. But if the time signature is 4/4, the event will occur at 1920 ticks. If, as an alternative, you had scheduled the event to occur at 1920 ticks, setting the time signature to 3/4 would not have affected when it occurred.</span>
<a name="l00128"></a>00128 <span class="comment"> </span>
<a name="l00129"></a>00129 <span class="comment">    You don't "schedule" a permanent event. Once it is created, it is always in an ITM object's list of permanent events. To specify when the event should occur, use time_setvalue.</span>
<a name="l00130"></a>00130 <span class="comment"> </span>
<a name="l00131"></a>00131 <span class="comment">    The high-level time object interface handles permanent events. Let's say we want to have a time value called "targettime." First, we declare an attribute using class_time_addattr. The flags used are #TIME_FLAGS_TICKSONLY (required because you can't specify a permanent event in milliseconds), #TIME_FLAGS_LOCATION (which interprets the bar/beat/unit times where 1 1 0 is zero ticks), #TIME_FLAGS_PERMANENT (for a permanent event), and #TIME_FLAGS_TRANSPORT (which adds a transport attribute permitting a user to choose a transport object as a destination for the event) and #TIME_FLAGS_POSITIVE (constrains the event to happen only for positive tick and bar/beat/unit values).</span>
<a name="l00132"></a>00132 <span class="comment"> </span>
<a name="l00133"></a>00133 <span class="comment">@code</span>
<a name="l00134"></a>00134 <span class="comment">    class_time_addattr(c, "targettime", "Target Time", TIME_FLAGS_TICKSONLY | TIME_FLAGS_LOCATION | TIME_FLAGS_PERMANENT | TIME_FLAGS_TRANSPORT | TIME_FLAGS_POSITIVE);</span>
<a name="l00135"></a>00135 <span class="comment">@endcode</span>
<a name="l00136"></a>00136 <span class="comment"></span>
<a name="l00137"></a>00137 <span class="comment">The #TIME_FLAGS_TRANSPORT flag is particularly nice. Without any intervention on your part, it creates a transport attribute for your object, and takes care of scheduling the permanent event on the transport the user specifies, with a default value of the global ITM object. If you want to cause your event to be rescheduled dynamically when the user changes the transport, your object can respond to the reschedule message as follows.</span>
<a name="l00138"></a>00138 <span class="comment"> </span>
<a name="l00139"></a>00139 <span class="comment">@code</span>
<a name="l00140"></a>00140 <span class="comment">    class_addmethod(c, (method)myobject_reschedule, "reschedule",   A_CANT, 0);         // for dynamic transport reassignment</span>
<a name="l00141"></a>00141 <span class="comment">@endcode</span>
<a name="l00142"></a>00142 <span class="comment"> </span>
<a name="l00143"></a>00143 <span class="comment">All you need to do in your reschedule method is just act as if the user has changed the time value, and use the current time value to call time_setvalue.</span>
<a name="l00144"></a>00144 <span class="comment"> </span>
<a name="l00145"></a>00145 <span class="comment">In your new instance routine, creating a permanent event with time_new uses the same flags as were passed to class_time_addattr:</span>
<a name="l00146"></a>00146 <span class="comment"> </span>
<a name="l00147"></a>00147 <span class="comment">@code</span>
<a name="l00148"></a>00148 <span class="comment">    x-&gt;t_time = (t_object*) time_new((t_object *)x, gensym("targettime"), (method)myobject_tick, TIME_FLAGS_TICKSONLY | TIME_FLAGS_USECLOCK | TIME_FLAGS_PERMANENT | TIME_FLAGS_LOCATION | TIME_FLAGS_POSITIVE);</span>
<a name="l00149"></a>00149 <span class="comment">@endcode</span>
<a name="l00150"></a>00150 <span class="comment"> </span>
<a name="l00151"></a>00151 <span class="comment">The task called by the permanent time object is identical to a clock task or an ITM temporary event task.</span>
<a name="l00152"></a>00152 <span class="comment"> </span>
<a name="l00153"></a>00153 <span class="comment">@section chapter_itm_clean Cleaning Up</span>
<a name="l00154"></a>00154 <span class="comment"></span>
<a name="l00155"></a>00155 <span class="comment">With all time objects, both permanent and temporary, it's necessary to free the objects in your object's free method. Failure to do so will lead to crashes if your object is freed but its events remain in the ITM scheduler. For example, here is the delay2 free routine:</span>
<a name="l00156"></a>00156 <span class="comment"> </span>
<a name="l00157"></a>00157 <span class="comment">@code</span>
<a name="l00158"></a>00158 <span class="comment">    void delay2_free(t_delay2 *x)</span>
<a name="l00159"></a>00159 <span class="comment">    {</span>
<a name="l00160"></a>00160 <span class="comment">        freeobject(x-&gt;d_timeobj);</span>
<a name="l00161"></a>00161 <span class="comment">        freeobject(x-&gt;d_quantize);</span>
<a name="l00162"></a>00162 <span class="comment">        freeobject((t_object *) x-&gt;d_proxy);</span>
<a name="l00163"></a>00163 <span class="comment">        freeobject((t_object *)x-&gt;d_clock);</span>
<a name="l00164"></a>00164 <span class="comment">    }</span>
<a name="l00165"></a>00165 <span class="comment">@endcode </span>
<a name="l00166"></a>00166 <span class="comment"></span>
<a name="l00167"></a>00167 <span class="comment"></span>
<a name="l00168"></a>00168 <span class="comment"></span>
<a name="l00169"></a>00169 <span class="comment"> </span>
<a name="l00170"></a>00170 <span class="comment">*/</span>
</pre></div></div>
		<div id="c74footer">
			<p>Copyright &copy; 2008, <a href="http://www.cycling74.com/">Cycling '74</a></p>
		</div>
	</body>
</html>
