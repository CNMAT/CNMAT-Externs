<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
		<title>Max5 API Reference</title>
		<link href="c74-doxygen.css" rel="stylesheet" type="text/css">
	</head>
	<body>

		<div id="c74header">
			<img src="max5.png" />
			<p>Max 5 API Reference</p>
		</div>

<!-- Generated by Doxygen 1.5.6 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<h1>api_08_mspanatomy.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/** </span>
<a name="l00002"></a>00002 <span class="comment">    @page chapter_msp_anatomy Anatomy of a MSP Object</span>
<a name="l00003"></a>00003 <span class="comment"></span>
<a name="l00004"></a>00004 <span class="comment">    An MSP object that handles audio signals is a regular Max object with a few extras. Refer to the &lt;a href="plussz~_8c-source.html"&gt;plussz~&lt;/a&gt; example project source as we detail these additions. plussz~ is simply an object that adds 1 to a signal, identical in function to the regular MSP +~ object if you were to give it an argument of 1.</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment">    Here is an enumeration of the basic tasks:</span>
<a name="l00007"></a>00007 <span class="comment"></span>
<a name="l00008"></a>00008 <span class="comment">    1) additional header files</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">    After including ext.h and ext_obex.h, include z_dsp.h</span>
<a name="l00011"></a>00011 <span class="comment">@code</span>
<a name="l00012"></a>00012 <span class="comment">    #include "z_dsp.h"</span>
<a name="l00013"></a>00013 <span class="comment">@endcode</span>
<a name="l00014"></a>00014 <span class="comment"></span>
<a name="l00015"></a>00015 <span class="comment">    2) C structure declaration</span>
<a name="l00016"></a>00016 <span class="comment"></span>
<a name="l00017"></a>00017 <span class="comment">    The C structure declaration must begin with a #t_pxobject, not a #t_object:</span>
<a name="l00018"></a>00018 <span class="comment">@code</span>
<a name="l00019"></a>00019 <span class="comment">    typedef struct _mydspobject</span>
<a name="l00020"></a>00020 <span class="comment">    {</span>
<a name="l00021"></a>00021 <span class="comment">        t_pxobject m_obj;</span>
<a name="l00022"></a>00022 <span class="comment">        // rest of the structure's fields</span>
<a name="l00023"></a>00023 <span class="comment">    } t_mydspobject;</span>
<a name="l00024"></a>00024 <span class="comment">@endcode</span>
<a name="l00025"></a>00025 <span class="comment"></span>
<a name="l00026"></a>00026 <span class="comment">    3) initialization routine</span>
<a name="l00027"></a>00027 <span class="comment"></span>
<a name="l00028"></a>00028 <span class="comment">    When creating the class with class_new(), you must have a free function. If you have nothing special to do, use dsp_free(), which is defined for this purpose. If you write your own free function, the first thing it should do is call dsp_free(). This is essential to avoid crashes when freeing your object when audio processing is turned on.</span>
<a name="l00029"></a>00029 <span class="comment">@code</span>
<a name="l00030"></a>00030 <span class="comment">        c = class_new("mydspobject", (method)mydspobject_new, (method)dsp_free, sizeof(t_mydspobject), NULL, 0);</span>
<a name="l00031"></a>00031 <span class="comment">@endcode</span>
<a name="l00032"></a>00032 <span class="comment"></span>
<a name="l00033"></a>00033 <span class="comment">    After creating your class with class_new(), you must call class_dspinit(), which will add some standard method handlers for internal messages used by all signal objects.</span>
<a name="l00034"></a>00034 <span class="comment">@code</span>
<a name="l00035"></a>00035 <span class="comment">        class_dspinit(c);</span>
<a name="l00036"></a>00036 <span class="comment">@endcode</span>
<a name="l00037"></a>00037 <span class="comment"></span>
<a name="l00038"></a>00038 <span class="comment">    Your signal object needs a method that is bound to the symbol "dsp" -- we'll detail what this method does below, but the following line needs to be added while initializing the class:</span>
<a name="l00039"></a>00039 <span class="comment">@code</span>
<a name="l00040"></a>00040 <span class="comment">        class_addmethod(c, (method)mydspobject_dsp, "dsp", A_CANT, 0);</span>
<a name="l00041"></a>00041 <span class="comment">@endcode</span>
<a name="l00042"></a>00042 <span class="comment"></span>
<a name="l00043"></a>00043 <span class="comment">    4) new instance routine</span>
<a name="l00044"></a>00044 <span class="comment"></span>
<a name="l00045"></a>00045 <span class="comment">    The new instance routine must call dsp_setup(), passing a pointer to the newly allocated object pointer plus a number of signal inlets the object will have. If the object has no signal inlets, you may pass 0. The plusz~ object (as an example) has a single signal inlet:</span>
<a name="l00046"></a>00046 <span class="comment">@code</span>
<a name="l00047"></a>00047 <span class="comment">        dsp_setup((t_pxobject *)x, 1);</span>
<a name="l00048"></a>00048 <span class="comment">@endcode</span>
<a name="l00049"></a>00049 <span class="comment"></span>
<a name="l00050"></a>00050 <span class="comment">    dsp_setup() will make the signal inlets (as proxies) so you need not make them yourself.</span>
<a name="l00051"></a>00051 <span class="comment"></span>
<a name="l00052"></a>00052 <span class="comment">    If your object will have audio signal outputs, they need to be created in the new instance routine with outlet_new(). However, you will never access them directly, so you don't need to store pointers to them as you do with regular outlets. Here is an example of creating two signal outlets:</span>
<a name="l00053"></a>00053 <span class="comment">@code</span>
<a name="l00054"></a>00054 <span class="comment">        outlet_new((t_object *)x, "signal");</span>
<a name="l00055"></a>00055 <span class="comment">        outlet_new((t_object *)x, "signal");</span>
<a name="l00056"></a>00056 <span class="comment">@endcode</span>
<a name="l00057"></a>00057 <span class="comment"></span>
<a name="l00058"></a>00058 <span class="comment">    5) The dsp method and perform routine</span>
<a name="l00059"></a>00059 <span class="comment"></span>
<a name="l00060"></a>00060 <span class="comment">    The dsp method specifies the signal processing function your object defines along with its arguments. Your object's dsp method will be called when the MSP signal compiler is building a sequence of operations (known as the DSP Chain) that will be performed on each set of audio samples. The operation sequence consists of a pointers to functions (called perform routines) followed by arguments to those functions.</span>
<a name="l00061"></a>00061 <span class="comment"></span>
<a name="l00062"></a>00062 <span class="comment">    The dsp method is declared as follows:</span>
<a name="l00063"></a>00063 <span class="comment">@code</span>
<a name="l00064"></a>00064 <span class="comment">    void mydspobject_dsp(t_mydspobject *x, t_signal **sp, short *count);</span>
<a name="l00065"></a>00065 <span class="comment">@endcode</span>
<a name="l00066"></a>00066 <span class="comment"></span>
<a name="l00067"></a>00067 <span class="comment">    To add an entry to the DSP chain, your dsp method uses dsp_add(). The dsp method is passed an array of signals (#t_signal pointers), which contain pointers to the actual sample memory your object's perform routine will be using for input and output. The array of signals starts with the inputs (from left to right), followed by the outputs. For example, if your object has two inputs (because your new instance routine called dsp_setup(x, 2)) and three outputs (because your new instance created three signal outlets), the signal array sp would contain five items as follows:</span>
<a name="l00068"></a>00068 <span class="comment">@code</span>
<a name="l00069"></a>00069 <span class="comment">    sp[0] // left input</span>
<a name="l00070"></a>00070 <span class="comment">    sp[1] // right input</span>
<a name="l00071"></a>00071 <span class="comment">    sp[2] // left output</span>
<a name="l00072"></a>00072 <span class="comment">    sp[3] // middle output</span>
<a name="l00073"></a>00073 <span class="comment">    sp[4] // right output</span>
<a name="l00074"></a>00074 <span class="comment">@endcode</span>
<a name="l00075"></a>00075 <span class="comment"></span>
<a name="l00076"></a>00076 <span class="comment">    The #t_signal data structure (defined in z_dsp.h), contains two important elements: the s_n field, which is the size of the signal vector, and s_vec, which is a pointer to an array of 32-bit floats containing the signal data. All t_signals your object will receive have the same size. This size is not necessarily the same as the global MSP signal vector size, because your object might be inside a patcher within a poly~ object that defines its own size. Therefore it is important to use the s_n field of a signal passed to your object's dsp method.</span>
<a name="l00077"></a>00077 <span class="comment"></span>
<a name="l00078"></a>00078 <span class="comment">    You can use a variety of strategies to pass arguments to your perform routine via dsp_add(). For simple unit generators that don't store any internal state between computing vectors, it is sufficient to pass the inputs, outputs, and vector size. For objects that need to store internal state between computing vectors such as filters or ramp generators, you will pass a pointer to your object, whose data structure should contain space to store this state. The plus1~ object does not need to store internal state. It passes the input, output, and vector size to its perform routine. The plus1~ dsp method is shown below:</span>
<a name="l00079"></a>00079 <span class="comment"></span>
<a name="l00080"></a>00080 <span class="comment">@code</span>
<a name="l00081"></a>00081 <span class="comment">    void plus1_dsp(t_plus1 *x, t_signal **sp, short count)</span>
<a name="l00082"></a>00082 <span class="comment">    {</span>
<a name="l00083"></a>00083 <span class="comment">        dsp_add(plus1_perform, 3, sp[0]-&gt;s_vec, sp[1]-&gt;s_vec, sp[0]-&gt;s_n);</span>
<a name="l00084"></a>00084 <span class="comment">    }</span>
<a name="l00085"></a>00085 <span class="comment">@endcode</span>
<a name="l00086"></a>00086 <span class="comment"></span>
<a name="l00087"></a>00087 <span class="comment">    The first argument to dsp_add() is your perform routine, followed by the number of additional arguments you wish to copy to the DSP chain, and then the arguments.</span>
<a name="l00088"></a>00088 <span class="comment"></span>
<a name="l00089"></a>00089 <span class="comment">    The perform routine is not a "method" in the traditional sense. It will be called within the callback of an audio driver, which, unless the user is employing the Non-Real Time audio driver, will typically be in a high-priority thread. Thread protection inside the perform routine is minimal. You can use a clock, but you cannot use qelems or outlets. The design of the perform routine is somewhat unlike other Max methods. It receives a pointer to a piece of the DSP chain and it is expected to return the location of the next perform routine on the chain. The next location is determined by the number of arguments you specified for your perform routine with your call to dsp_add(). For example, if you will pass three arguments, you need to return w + 4.</span>
<a name="l00090"></a>00090 <span class="comment"> </span>
<a name="l00091"></a>00091 <span class="comment">    Here is the plus1 perform routine:</span>
<a name="l00092"></a>00092 <span class="comment"></span>
<a name="l00093"></a>00093 <span class="comment">@code</span>
<a name="l00094"></a>00094 <span class="comment">    t_int *plus1_perform(t_int *w)</span>
<a name="l00095"></a>00095 <span class="comment">    {</span>
<a name="l00096"></a>00096 <span class="comment">        t_float *in, *out;</span>
<a name="l00097"></a>00097 <span class="comment">        int n;</span>
<a name="l00098"></a>00098 <span class="comment"></span>
<a name="l00099"></a>00099 <span class="comment">        in = (t_float *)w[1];       // get input signal vector</span>
<a name="l00100"></a>00100 <span class="comment">        out = (t_float *)w[2];      // get output signal vector</span>
<a name="l00101"></a>00101 <span class="comment">        n = (int)w[3];          // vector size</span>
<a name="l00102"></a>00102 <span class="comment"></span>
<a name="l00103"></a>00103 <span class="comment">    </span>
<a name="l00104"></a>00104 <span class="comment">        while (n--)         // perform calculation on all samples</span>
<a name="l00105"></a>00105 <span class="comment">            *out++ = *in++ + 1.;</span>
<a name="l00106"></a>00106 <span class="comment">    </span>
<a name="l00107"></a>00107 <span class="comment">        return w + 4;           // must return next DSP chain location</span>
<a name="l00108"></a>00108 <span class="comment">    }</span>
<a name="l00109"></a>00109 <span class="comment">@endcode</span>
<a name="l00110"></a>00110 <span class="comment"></span>
<a name="l00111"></a>00111 <span class="comment">    6) Free function</span>
<a name="l00112"></a>00112 <span class="comment"></span>
<a name="l00113"></a>00113 <span class="comment">    The free function for the class must either be dsp_free() or it must be written to call dsp_free() as shown in the example below:</span>
<a name="l00114"></a>00114 <span class="comment"></span>
<a name="l00115"></a>00115 <span class="comment">@code</span>
<a name="l00116"></a>00116 <span class="comment">    void mydspobject_free(t_mydspobject *x)</span>
<a name="l00117"></a>00117 <span class="comment">    {</span>
<a name="l00118"></a>00118 <span class="comment">        dsp_free((t_pxobject *)x);</span>
<a name="l00119"></a>00119 <span class="comment"></span>
<a name="l00120"></a>00120 <span class="comment">        // can do other stuff here</span>
<a name="l00121"></a>00121 <span class="comment">    }</span>
<a name="l00122"></a>00122 <span class="comment">@endcode</span>
<a name="l00123"></a>00123 <span class="comment"></span>
<a name="l00124"></a>00124 <span class="comment">*/</span>
</pre></div></div>
		<div id="c74footer">
			<p>Copyright &copy; 2008, <a href="http://www.cycling74.com/">Cycling '74</a></p>
		</div>
	</body>
</html>
