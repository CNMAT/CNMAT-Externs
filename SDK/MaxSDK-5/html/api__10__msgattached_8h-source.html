<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
		<title>Max5 API Reference</title>
		<link href="c74-doxygen.css" rel="stylesheet" type="text/css">
	</head>
	<body>

		<div id="c74header">
			<img src="max5.png" />
			<p>Max 5 API Reference</p>
		</div>

<!-- Generated by Doxygen 1.5.6 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<h1>api_10_msgattached.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/** </span>
<a name="l00002"></a>00002 <span class="comment">    @page chapter_msgattached Sending Messages, Calling Methods</span>
<a name="l00003"></a>00003 <span class="comment"></span>
<a name="l00004"></a>00004 <span class="comment">    Max objects, such as the one you write, are C data structures in which methods are dynamically bound to functions. Your object's methods are called by Max, but your object can also call methods itself. When you call a method, it is essential to know whether the method you are calling is &lt;strong&gt;typed&lt;/strong&gt; or not.</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment">    Calling a typed method requires passing arguments as an array of atoms. Calling an untyped method requires that you know the exact arguments of the C function implementing the method. In both cases, you supply a symbol that names the method.</span>
<a name="l00007"></a>00007 <span class="comment"></span>
<a name="l00008"></a>00008 <span class="comment">    In the typed method case, Max will take the array of atoms and pass the arguments to the object according to the method's argument type specifier list. For example, if the method is declared to have an argument type specifier list of #A_LONG, 0, the first atom in the array you pass will be converted to an int and passed to the function on the stack. If there are no arguments supplied, invoking a typed method that has #A_LONG, 0 as an argument type specifier will fail. To make typed method calls, use object_method_typed() or typedmess().</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">    In the untyped method case, Max merely does a lookup of the symbol in the object, and, if a matching function is found, calls the function with the arguments you pass. </span>
<a name="l00011"></a>00011 <span class="comment"></span>
<a name="l00012"></a>00012 <span class="comment">    Certain methods you write for your object, such as the assist method for describing your object and the DSP method in audio objects, are declared as untyped using the #A_CANT argument type specifier. This means that Max will not typecheck the arguments you pass to these methods, but, most importantly, a user cannot hook up a message box to your object and send it a message to invoke an untyped method. (Try this for yourself -- send the assist message to a standard Max object.)</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment">    When you use an outlet, you're effectively making a typed method call on any objects connected to the outlet.</span>
<a name="l00015"></a>00015 <span class="comment"></span>
<a name="l00016"></a>00016 <span class="comment"></span>
<a name="l00017"></a>00017 <span class="comment">    @section chapter_msgattached_attrs Attributes</span>
<a name="l00018"></a>00018 <span class="comment"></span>
<a name="l00019"></a>00019 <span class="comment">    Attributes are descriptions of data in your object. The standardization of these descriptions permits Max to provide a rich interface to object data, including the pattr system, inspectors, the quick reference menu, @ arguments, etc.</span>
<a name="l00020"></a>00020 <span class="comment"></span>
<a name="l00021"></a>00021 <span class="comment">    It is essential that you have some understanding of attributes if you are going to write a UI object. But non-UI objects can make use of attributes as well. The discussion below is not specific to UI objects. It does however, use the recently introduced system of macros in ext_obex_util.h (included in ext_obex.h) for defining attributes, as well as describing them using attributes of attributes (attr attrs). You can read more detailed descriptions of the underlying attribute definition mechanisms on a per-function basis in the @ref attr reference.</span>
<a name="l00022"></a>00022 <span class="comment"></span>
<a name="l00023"></a>00023 <span class="comment"></span>
<a name="l00024"></a>00024 <span class="comment">    @subsection chapter_msgattached_attr_basics Attribute Basics</span>
<a name="l00025"></a>00025 <span class="comment"></span>
<a name="l00026"></a>00026 <span class="comment">    While attributes can be defined for a specific instance of an object, it's much more common to define an attribute for a class. In such a case, each instance of the class will have the attribute description, but the value will be instance specific. The discussion here focuses only on class attributes.</span>
<a name="l00027"></a>00027 <span class="comment"></span>
<a name="l00028"></a>00028 <span class="comment">    When an attribute is declared and is made user-settable, a user can send a message to your object consisting of the attribute name and arguments that represent the new value of the attribute. For example, if you declare an attribute called trackcount, the message trackcount 20 will set it to 20. You don't need to do anything special to obtain this behavior. In addition, user-settable attributes will appear when the user opens the inspector on your object.</span>
<a name="l00029"></a>00029 <span class="comment"></span>
<a name="l00030"></a>00030 <span class="comment">    If you define your attribute as an offset attribute, you describe its location (and size) within your object's C data structure. Max can then read and write the data directly. You can also define custom getter and setter routines if the attribute's value is more complex than simply a stored number. As a theoretical example, you could have an object with an attribute representing the Earth's population. If this value was not able to be stored inside your object, your custom getter routine could initiate a global census before returning the result. A custom setter for the earth's population might do something nasty if the value was set to zero. If you are not a misanthrope, you can take advantage of the ability to set such an attribute to be read-only.</span>
<a name="l00031"></a>00031 <span class="comment"></span>
<a name="l00032"></a>00032 <span class="comment"></span>
<a name="l00033"></a>00033 <span class="comment">    @subsection chapter_msgattached_attr_def Defining Attributes</span>
<a name="l00034"></a>00034 <span class="comment"></span>
<a name="l00035"></a>00035 <span class="comment">    Attributes are defined when you are defining methods in your initialization routine. You can define your attributes before your methods if you like, but by convention, they are typically defined after the methods. For each definition, you'll specify the name, size, and offset of the corresponding member in your object's data structure that will hold the data. For example, let's say we have an object defined as follows:</span>
<a name="l00036"></a>00036 <span class="comment"> </span>
<a name="l00037"></a>00037 <span class="comment">@code</span>
<a name="l00038"></a>00038 <span class="comment">    typedef struct _myobject {</span>
<a name="l00039"></a>00039 <span class="comment">        t_object m_ob;</span>
<a name="l00040"></a>00040 <span class="comment">        long m_targetaddress;</span>
<a name="l00041"></a>00041 <span class="comment">        t_symbol *m_shipname;</span>
<a name="l00042"></a>00042 <span class="comment">        char m_compatmode;</span>
<a name="l00043"></a>00043 <span class="comment">    } t_myobject;</span>
<a name="l00044"></a>00044 <span class="comment">@endcode</span>
<a name="l00045"></a>00045 <span class="comment"> </span>
<a name="l00046"></a>00046 <span class="comment">    We want to create attributes for m_targetaddress, m_shipname, and m_compatmode. For each data type (and a few others), there are macros in ext_obex_util.h that will save a fair amount of typing. So, for example, we can define an attribute for m_targetaddress that uses CLASS_ATTR_LONG. Here are attribute definitions for all of the members of our data structure above.</span>
<a name="l00047"></a>00047 <span class="comment"> </span>
<a name="l00048"></a>00048 <span class="comment">@code</span>
<a name="l00049"></a>00049 <span class="comment">    CLASS_ATTR_LONG(c, "targetaddress", 0, t_myobject, m_targetaddress);</span>
<a name="l00050"></a>00050 <span class="comment">    CLASS_ATTR_SYM(c, "shipname", 0, t_myobject, m_shipname);</span>
<a name="l00051"></a>00051 <span class="comment">    CLASS_ATTR_CHAR(c, "compatibilitymode", 0, t_myobject, m_compatmode);</span>
<a name="l00052"></a>00052 <span class="comment">@endcode</span>
<a name="l00053"></a>00053 <span class="comment"> </span>
<a name="l00054"></a>00054 <span class="comment"> @subsection chapter_msgattached_attr_custom Attributes With Custom Getters and Setters</span>
<a name="l00055"></a>00055 <span class="comment"></span>
<a name="l00056"></a>00056 <span class="comment">    In some cases, it is not enough to have Max read and write data in your object directly. In some cases (as in the world population example above) you may have data you need to calculate before it can be returned as a value. In other cases, you may need to do something to update other object state when an attribute value changes. To handle these challenges, you can define custom attribute getter and setter routines. The getter will be called when the value of your attribute is accessed. The setter will be called when someone changes the value of your attribute.</span>
<a name="l00057"></a>00057 <span class="comment"> </span>
<a name="l00058"></a>00058 <span class="comment">    As an example, suppose we have an object that holds onto an array of numbers, and we want to create an attribute for the size of the array. Since we'll want to resize the array when the attribute value changes, we will define a custom setter for our attribute. The default getter is adequate if we store the array size in our object, but since we want to illustrate how to write an attribute getter, we'll write the code so that the array size is computed from the size of the memory pointer we allocate. First, here is our object's data structure:</span>
<a name="l00059"></a>00059 <span class="comment"> </span>
<a name="l00060"></a>00060 <span class="comment">@code</span>
<a name="l00061"></a>00061 <span class="comment">    typedef struct _myobject {</span>
<a name="l00062"></a>00062 <span class="comment">        t_object m_ob;</span>
<a name="l00063"></a>00063 <span class="comment">        long *m_data;</span>
<a name="l00064"></a>00064 <span class="comment">    } t_myobject;</span>
<a name="l00065"></a>00065 <span class="comment">@endcode</span>
<a name="l00066"></a>00066 <span class="comment"></span>
<a name="l00067"></a>00067 <span class="comment">We also have prototypes for our custom attribute setter and getter:</span>
<a name="l00068"></a>00068 <span class="comment"> </span>
<a name="l00069"></a>00069 <span class="comment">@code</span>
<a name="l00070"></a>00070 <span class="comment">    t_max_err myobject_size_get(t_myobject *x, t_object *attr, long *argc, t_atom **argv);</span>
<a name="l00071"></a>00071 <span class="comment">    t_max_err myobject_size_set(t_myobject *x, t_object *attr, long argc, t_atom *argv);</span>
<a name="l00072"></a>00072 <span class="comment">@endcode</span>
<a name="l00073"></a>00073 <span class="comment"> </span>
<a name="l00074"></a>00074 <span class="comment">Here is how we define our attribute using CLASS_ATTR_ACCESSORS macro to define the custom setter and getter. Because we aren't really using an "offset" due to the custom setter and getter, we can pass any data structure member as a dummy. (Only the default attribute getter and setter will use this offset, and they are out of the picture.)</span>
<a name="l00075"></a>00075 <span class="comment"></span>
<a name="l00076"></a>00076 <span class="comment">@code</span>
<a name="l00077"></a>00077 <span class="comment">    CLASS_ATTR_LONG(c, "size", 0, t_myobject, m_ob);</span>
<a name="l00078"></a>00078 <span class="comment">    CLASS_ATTR_ACCESSORS(c, "size", myobject_size_get, myobject_size_set);</span>
<a name="l00079"></a>00079 <span class="comment">@endcode</span>
<a name="l00080"></a>00080 <span class="comment"> </span>
<a name="l00081"></a>00081 <span class="comment">Now, here is an implementation of the custom setter for the array size. For the setter, we use the handy Max API function sysmem_resizeptr so we can effectively "resize" our array and copy the data into it in one step. The setter uses atoms, so we have to obtain the value from the first item in the argv array.</span>
<a name="l00082"></a>00082 <span class="comment"> </span>
<a name="l00083"></a>00083 <span class="comment">@code</span>
<a name="l00084"></a>00084 <span class="comment">    t_max_err myobject_size_set(t_myobject *x, t_object *attr, long argc, t_atom *argv)</span>
<a name="l00085"></a>00085 <span class="comment">    {</span>
<a name="l00086"></a>00086 <span class="comment">        long size = atom_getlong(argv);</span>
<a name="l00087"></a>00087 <span class="comment"> </span>
<a name="l00088"></a>00088 <span class="comment">        if (size &lt; 0)       // bad size, don't change anything</span>
<a name="l00089"></a>00089 <span class="comment">            return 0;</span>
<a name="l00090"></a>00090 <span class="comment"> </span>
<a name="l00091"></a>00091 <span class="comment">        if (x-&gt;m_data)</span>
<a name="l00092"></a>00092 <span class="comment">            x-&gt;m_data = (long *)sysmem_resizeptr((char *)x-&gt;m_data, size * sizeof(long));</span>
<a name="l00093"></a>00093 <span class="comment">        else    // first time alloc</span>
<a name="l00094"></a>00094 <span class="comment">            x-&gt;m_data = (long *)sysmem_newptr(size * sizeof(long));</span>
<a name="l00095"></a>00095 <span class="comment">        return 0;</span>
<a name="l00096"></a>00096 <span class="comment">    }</span>
<a name="l00097"></a>00097 <span class="comment"> @endcode</span>
<a name="l00098"></a>00098 <span class="comment"> </span>
<a name="l00099"></a>00099 <span class="comment"> The getter also uses atoms for access, but we are returning a pointer to an array of atoms. The caller of the getter has the option to pre-allocate the memory (passing in the length in argc and the pointer to the memory in argv) or pass in 0 for argc and set the contents of argv to NULL and have the getter allocate the memory. The easiest way to handle this case is to call the utility function atom_alloc, which will figure out what was passed in and allocate memory for a returned atom if necessary.</span>
<a name="l00100"></a>00100 <span class="comment"> </span>
<a name="l00101"></a>00101 <span class="comment">@code</span>
<a name="l00102"></a>00102 <span class="comment">    t_max_err myobject_size_get(t_myobject *x, t_object *attr, long *argc, t_atom **argv)</span>
<a name="l00103"></a>00103 <span class="comment">    {</span>
<a name="l00104"></a>00104 <span class="comment">        char alloc;</span>
<a name="l00105"></a>00105 <span class="comment">        long size = 0;</span>
<a name="l00106"></a>00106 <span class="comment"> </span>
<a name="l00107"></a>00107 <span class="comment">        atom_alloc(argc, argv, &amp;alloc);     // allocate return atom</span>
<a name="l00108"></a>00108 <span class="comment"> </span>
<a name="l00109"></a>00109 <span class="comment">        if (x-&gt;m_data)</span>
<a name="l00110"></a>00110 <span class="comment">            size = sysmem_ptrsize((char *)x-&gt;m_data) / sizeof(long);    // calculate array size based on ptr size</span>
<a name="l00111"></a>00111 <span class="comment"> </span>
<a name="l00112"></a>00112 <span class="comment">        atom_setlong(*argv, size);</span>
<a name="l00113"></a>00113 <span class="comment">        return 0;</span>
<a name="l00114"></a>00114 <span class="comment">    }</span>
<a name="l00115"></a>00115 <span class="comment"> @endcode</span>
<a name="l00116"></a>00116 <span class="comment"> </span>
<a name="l00117"></a>00117 <span class="comment">    @section chapter_msgattached_receiving Receiving Notifications</span>
<a name="l00118"></a>00118 <span class="comment"></span>
<a name="l00119"></a>00119 <span class="comment">    As an alternative to writing a custom setter, you can take advantage of the fact that objects receive a "notify" message whenever one of their attributes is changed. The prototype for a notify method is as follows:</span>
<a name="l00120"></a>00120 <span class="comment"> </span>
<a name="l00121"></a>00121 <span class="comment">@code</span>
<a name="l00122"></a>00122 <span class="comment">    t_max_err myobject_notify(t_myobject *x, t_symbol *s, t_symbol *msg, void *sender, void *data);</span>
<a name="l00123"></a>00123 <span class="comment">@endcode</span>
<a name="l00124"></a>00124 <span class="comment"> </span>
<a name="l00125"></a>00125 <span class="comment">    Add the following to your class initialization so your notification method will be called:</span>
<a name="l00126"></a>00126 <span class="comment"> </span>
<a name="l00127"></a>00127 <span class="comment">@code</span>
<a name="l00128"></a>00128 <span class="comment">    class_addmethod(c, (method)myobject_notify, "notify", A_CANT, 0);</span>
<a name="l00129"></a>00129 <span class="comment">@endcode</span>
<a name="l00130"></a>00130 <span class="comment"> </span>
<a name="l00131"></a>00131 <span class="comment">    The notify method can handle a variety of notifications (more documentation on this is coming soon!), but the one we're interested in is "attr_modified" -- the notification type is passed to the notify method in the msg argument. Here is an example of a notify method that prints out the name of the attribute that has been modified. You could take any action instead. To obtain the name, we interpret the data argument to the notify method as an attribute object. As an attribute is a regular Max object, we can use object_method to send it a message. In the case we are sending the message getname to the attribute object to obtain its name.</span>
<a name="l00132"></a>00132 <span class="comment"> </span>
<a name="l00133"></a>00133 <span class="comment">@code</span>
<a name="l00134"></a>00134 <span class="comment">    t_max_err myobject_notify(t_myobject *x, t_symbol *s, t_symbol *msg, void *sender, void *data)</span>
<a name="l00135"></a>00135 <span class="comment">    {</span>
<a name="l00136"></a>00136 <span class="comment">        t_symbol *attrname;</span>
<a name="l00137"></a>00137 <span class="comment"> </span>
<a name="l00138"></a>00138 <span class="comment">        if (msg == gensym("attr_modified")) {       // check notification type</span>
<a name="l00139"></a>00139 <span class="comment">            attrname = (t_symbol *)object_method((t_object *)data, gensym("getname"));      // ask attribute object for name</span>
<a name="l00140"></a>00140 <span class="comment">            object_post((t_object *)x, "changed attr name is %s",attrname-&gt;s_name);</span>
<a name="l00141"></a>00141 <span class="comment">        }</span>
<a name="l00142"></a>00142 <span class="comment">        return 0;</span>
<a name="l00143"></a>00143 <span class="comment">    }</span>
<a name="l00144"></a>00144 <span class="comment">@endcode</span>
<a name="l00145"></a>00145 <span class="comment"> </span>
<a name="l00146"></a>00146 <span class="comment"></span>
<a name="l00147"></a>00147 <span class="comment">*/</span>
</pre></div></div>
		<div id="c74footer">
			<p>Copyright &copy; 2008, <a href="http://www.cycling74.com/">Cycling '74</a></p>
		</div>
	</body>
</html>
