<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
		<title>Max5 API Reference</title>
		<link href="c74-doxygen.css" rel="stylesheet" type="text/css">
	</head>
	<body>

		<div id="c74header">
			<img src="max5.png" />
			<p>Max 5 API Reference</p>
		</div>

<!-- Generated by Doxygen 1.5.6 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<h1>api_05_atoms.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/** </span>
<a name="l00002"></a>00002 <span class="comment">    @page chapter_atoms Atoms and Messages</span>
<a name="l00003"></a>00003 <span class="comment"></span>
<a name="l00004"></a>00004 <span class="comment">    When a Max object receives a message, it uses its class to look up the message selector ("int", "bang", "set" etc.) and invoke the associated C function (method). This association is what you are creating when you use class_addmethod() in the initialization routine. If the lookup fails, you'll see an "object doesn't understand message" error in the Max window.</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment">    Message selectors are not character strings, but a special data structure called a symbol (#t_symbol). A symbol holds a string and a value, but what is more important is that every symbol in Max is unique. This permits you to compare two symbols for equivalence by comparing pointers, rather than having to compare each character in two strings.</span>
<a name="l00007"></a>00007 <span class="comment"></span>
<a name="l00008"></a>00008 <span class="comment">    The "data" or argument part of a message, if it exists, is transmitted in the form of an array of atoms (#t_atom). The atom is a structure that can hold integers, floats, symbols, or even pointers to other objects, identified by a tag. You'll use symbols and atoms both in sending messages and receiving them.</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">    To illustrate the use of symbols and atoms, here is how you would send a message out an outlet. Let's say we want to send the message "green 43 crazy 8.34." This message consists of a selector "green" plus an array of three atoms.</span>
<a name="l00011"></a>00011 <span class="comment"></span>
<a name="l00012"></a>00012 <span class="comment">    First, we'll need to create a generic outlet with outlet_new in our new instance routine.</span>
<a name="l00013"></a>00013 <span class="comment">@code</span>
<a name="l00014"></a>00014 <span class="comment">        x-&gt;m_outlet = outlet_new((t_object *)x, NULL);</span>
<a name="l00015"></a>00015 <span class="comment">@endcode</span>
<a name="l00016"></a>00016 <span class="comment"></span>
<a name="l00017"></a>00017 <span class="comment">    The second argument being NULL indicates that the outlet can be used to send any message. If the second argument had been a character string such as "int" or "set" only that specific message could be sent out the outlet. You'd be correct if you wondered whether intout() is actually just outlet_new(x, "int").</span>
<a name="l00018"></a>00018 <span class="comment"></span>
<a name="l00019"></a>00019 <span class="comment">    Now that we have our generic outlet, we'll call outlet_anything() on it in a method. The first step, however, is to assemble our message, with a selector "green" plus an array of atoms. Assigning ints and floats to an atom is relatively simple, but to assign a symbol, we need to transform a character string into a symbol using gensym(). The gensym() function returns a pointer to a symbol that is guaranteed to be unique for the string you supply. This means the string is compared with other symbols to ensure its uniqueness. If it already exists, gensym() will supply a pointer to the symbol. Otherwise it will create a new one and store it in a table so it can be found the next time someone asks for it.</span>
<a name="l00020"></a>00020 <span class="comment"></span>
<a name="l00021"></a>00021 <span class="comment">@code</span>
<a name="l00022"></a>00022 <span class="comment">    void myobject_bang(t_object *x)</span>
<a name="l00023"></a>00023 <span class="comment">    {</span>
<a name="l00024"></a>00024 <span class="comment">        t_atom argv[3];</span>
<a name="l00025"></a>00025 <span class="comment"></span>
<a name="l00026"></a>00026 <span class="comment">        atom_setlong(argv, 43);</span>
<a name="l00027"></a>00027 <span class="comment">        atom_setsym(argv + 1, gensym("crazy"));</span>
<a name="l00028"></a>00028 <span class="comment">        atom_setfloat(argv + 2, 8.34);</span>
<a name="l00029"></a>00029 <span class="comment"></span>
<a name="l00030"></a>00030 <span class="comment">        outlet_anything(x-&gt;m_outlet, gensym("green"), 3, argv);</span>
<a name="l00031"></a>00031 <span class="comment">    }</span>
<a name="l00032"></a>00032 <span class="comment">@endcode</span>
<a name="l00033"></a>00033 <span class="comment"></span>
<a name="l00034"></a>00034 <span class="comment">    In the call to outlet_anything() above, gensym("green") represents the message selector. The outlet_anything() function will try to find a message "green" in each of the objects connected to the inlet. If outlet_anything() finds such a message, it will execute it, passing it the array of atoms it received.</span>
<a name="l00035"></a>00035 <span class="comment"></span>
<a name="l00036"></a>00036 <span class="comment">    If it cannot find a match for the symbol green, it does one more thing, which allows objects to handle messages generically. Your object can define a special method bound to the symbol "anything" that will be invoked if no other match is found for a selector. We'll discuss the anything method in a moment, but first, we need to return to class_addmethod() and explain the final arguments it accepts. </span>
<a name="l00037"></a>00037 <span class="comment"></span>
<a name="l00038"></a>00038 <span class="comment">    To access atoms, you can use the functions atom_setlong(), atom_getlong() etc. or you can access the #t_atom structure directly. We recommend using the accessor functions, as they lead to both cleaner code and will permit your source to work without modifications when changes to the #t_atom structure occur over time.</span>
<a name="l00039"></a>00039 <span class="comment">    </span>
<a name="l00040"></a>00040 <span class="comment"></span>
<a name="l00041"></a>00041 <span class="comment">    @section chapter_atoms_types Argument Type Specifiers</span>
<a name="l00042"></a>00042 <span class="comment"></span>
<a name="l00043"></a>00043 <span class="comment">    In the simp example, you saw the int method defined as follows:</span>
<a name="l00044"></a>00044 <span class="comment">@code</span>
<a name="l00045"></a>00045 <span class="comment">        class_addmethod(c, (method)simp_int, A_LONG, 0);</span>
<a name="l00046"></a>00046 <span class="comment">@endcode</span>
<a name="l00047"></a>00047 <span class="comment"></span>
<a name="l00048"></a>00048 <span class="comment">    The #A_LONG, 0 arguments to class_addmethod() specify the type of arguments expected by the C function you have written. #A_LONG means that the C function accepts a long integer argument. The 0 terminates the argument specifier list, so for the int message, there is a single long integer argument.</span>
<a name="l00049"></a>00049 <span class="comment"></span>
<a name="l00050"></a>00050 <span class="comment">    The other options are #A_FLOAT for doubles, #A_SYM for symbols, and #A_GIMME, which passes the raw list of atoms that were originally used to send the Max message in the first place. These argument type specifiers define what are known as "typed" methods in Max. Typed methods are those where Max checks the type of each atom in a message to ensure it is consistent with what the receiving object has said it expects for a given selector.</span>
<a name="l00051"></a>00051 <span class="comment"></span>
<a name="l00052"></a>00052 <span class="comment">    If the atoms cannot be coerced into the format of the argument type specifier, a bad arguments error is printed in the Max window.</span>
<a name="l00053"></a>00053 <span class="comment"></span>
<a name="l00054"></a>00054 <span class="comment">    There is a limit to the number of specifiers you can use, and in general, multiple #A_FLOAT specifiers should be avoided due to the historically unpredictable nature of compiler implementations when passing floating-point values on the stack. Use #A_GIMME for more than four arguments or with multiple floating-point arguments.</span>
<a name="l00055"></a>00055 <span class="comment"></span>
<a name="l00056"></a>00056 <span class="comment">    You can also specify that missing arguments to a message be filled in with default values before your C function receives them. #A_DEFLONG will put a 0 in place of a missing long argument, #A_DEFFLOAT will put 0.0 in place of a missing float argument, and #A_DEFSYM will put the empty symbol (equal to gensym("")) in place of a missing symbol argument.</span>
<a name="l00057"></a>00057 <span class="comment"></span>
<a name="l00058"></a>00058 <span class="comment"></span>
<a name="l00059"></a>00059 <span class="comment">    @section chapter_atoms_gimme_funcs Writing A_GIMME Functions</span>
<a name="l00060"></a>00060 <span class="comment"></span>
<a name="l00061"></a>00061 <span class="comment">    A method that uses #A_GIMME is declared as follows:</span>
<a name="l00062"></a>00062 <span class="comment">@code</span>
<a name="l00063"></a>00063 <span class="comment">    void myobject_message(t_myobject *x, t_symbol *s, long argc, t_atom *argv);</span>
<a name="l00064"></a>00064 <span class="comment">@endcode</span>
<a name="l00065"></a>00065 <span class="comment"></span>
<a name="l00066"></a>00066 <span class="comment">    The symbol argument s is the message selector. Ordinarily this might seem redundant, but it is useful for the "anything" method as we'll discuss below.</span>
<a name="l00067"></a>00067 <span class="comment"></span>
<a name="l00068"></a>00068 <span class="comment">    argc is the number of atoms in the argv array. It could be 0 if the message was sent without arguments. argv is the array of atoms holding the arguments.</span>
<a name="l00069"></a>00069 <span class="comment"></span>
<a name="l00070"></a>00070 <span class="comment">    For typed messages, the atoms will be of type #A_SYM, #A_FLOAT, or #A_LONG. Here is an example of a method that merely prints all of the arguments.</span>
<a name="l00071"></a>00071 <span class="comment"></span>
<a name="l00072"></a>00072 <span class="comment">@code</span>
<a name="l00073"></a>00073 <span class="comment">    void myobject_printargs(t_myobject *x, t_symbol *s, long argc, t_atom *argv)</span>
<a name="l00074"></a>00074 <span class="comment">    {</span>
<a name="l00075"></a>00075 <span class="comment">        long i;</span>
<a name="l00076"></a>00076 <span class="comment">        t_atom *ap;</span>
<a name="l00077"></a>00077 <span class="comment"></span>
<a name="l00078"></a>00078 <span class="comment">        post("message selector is %s",s-&gt;s_name);</span>
<a name="l00079"></a>00079 <span class="comment">        post("there are %ld arguments",argc);</span>
<a name="l00080"></a>00080 <span class="comment">        for (i = 0, ap = argv; i &lt; argc; i++, ap++) {       // increment ap each time to get to the next atom</span>
<a name="l00081"></a>00081 <span class="comment">            switch (atom_gettype(ap)) {</span>
<a name="l00082"></a>00082 <span class="comment">                case A_LONG:</span>
<a name="l00083"></a>00083 <span class="comment">                    post("%ld: %ld",i+1,atom_getlong(ap));</span>
<a name="l00084"></a>00084 <span class="comment">                    break;</span>
<a name="l00085"></a>00085 <span class="comment">                case A_FLOAT:</span>
<a name="l00086"></a>00086 <span class="comment">                    post("%ld: %.2f",i+1,atom_getfloat(ap));</span>
<a name="l00087"></a>00087 <span class="comment">                    break;</span>
<a name="l00088"></a>00088 <span class="comment">                case A_SYM:</span>
<a name="l00089"></a>00089 <span class="comment">                    post("%ld: %s",i+1, atom_getsym(ap)-&gt;s_name);</span>
<a name="l00090"></a>00090 <span class="comment">                    break;</span>
<a name="l00091"></a>00091 <span class="comment">                default:</span>
<a name="l00092"></a>00092 <span class="comment">                    post("%ld: unknown atom type (%ld)", i+1, atom_gettype(ap));</span>
<a name="l00093"></a>00093 <span class="comment">                    break;</span>
<a name="l00094"></a>00094 <span class="comment">            }</span>
<a name="l00095"></a>00095 <span class="comment">        }</span>
<a name="l00096"></a>00096 <span class="comment">    }</span>
<a name="l00097"></a>00097 <span class="comment">@endcode        </span>
<a name="l00098"></a>00098 <span class="comment"></span>
<a name="l00099"></a>00099 <span class="comment">    You can interpret the arguments in whatever manner you wish. You cannot, however, modify the arguments as they may be about to be passed to another object.</span>
<a name="l00100"></a>00100 <span class="comment"></span>
<a name="l00101"></a>00101 <span class="comment">*/</span>
</pre></div></div>
		<div id="c74footer">
			<p>Copyright &copy; 2008, <a href="http://www.cycling74.com/">Cycling '74</a></p>
		</div>
	</body>
</html>
