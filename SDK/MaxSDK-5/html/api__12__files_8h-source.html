<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
		<title>Max5 API Reference</title>
		<link href="c74-doxygen.css" rel="stylesheet" type="text/css">
	</head>
	<body>

		<div id="c74header">
			<img src="max5.png" />
			<p>Max 5 API Reference</p>
		</div>

<!-- Generated by Doxygen 1.5.6 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<h1>api_12_files.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/** </span>
<a name="l00002"></a>00002 <span class="comment">    @page chapter_files File Handling</span>
<a name="l00003"></a>00003 <span class="comment"></span>
<a name="l00004"></a>00004 <span class="comment">    Max contains a cross-platform set of routines for handling files. These routines permit you to search for files, show file open and save dialogs, as well as open, read, write, and close them. The file API is based around a "path identifier" -- a number that describes the location of a file. When searching or reading a file, path identifiers can be either a folders or collectives. Path identifiers that are negative (or zero) describe actual folders in the computer's file system, while path identifiers that are positive refer to collectives.</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment">    A basic thing you might want to do make your object accept the read message in a manner similar to existing Max objects. If the word read is followed by no arguments, a file dialog appears for the user to choose a file. If read is followed by an argument, your object will search for the file. If a file is found (or chosen), your object will open it and read data from it.</span>
<a name="l00007"></a>00007 <span class="comment"></span>
<a name="l00008"></a>00008 <span class="comment">    First, make your object accept the read message. The simplest way to make the filename argument optional is to use the #A_DEFSYM argument type specifier. When the symbol argument is not present, Max passes your method the empty symbol.</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">@code</span>
<a name="l00011"></a>00011 <span class="comment">        class_addmethod(c, (method)myobject_read, "read", A_DEFSYM, 0);</span>
<a name="l00012"></a>00012 <span class="comment">@endcode</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment">    The next requirement for any method that reads files is that it must defer execution to the low-priority thread, as shown in the following implementation, where the filename argument is passed as the symbol argument to defer.</span>
<a name="l00015"></a>00015 <span class="comment"></span>
<a name="l00016"></a>00016 <span class="comment">@code</span>
<a name="l00017"></a>00017 <span class="comment">    void myobject_read(t_myobject *x, t_symbol *s)</span>
<a name="l00018"></a>00018 <span class="comment">    {</span>
<a name="l00019"></a>00019 <span class="comment">        defer(x, (method)myobject_doread, s, 0, NULL);</span>
<a name="l00020"></a>00020 <span class="comment">    }</span>
<a name="l00021"></a>00021 <span class="comment">@endcode</span>
<a name="l00022"></a>00022 <span class="comment"></span>
<a name="l00023"></a>00023 <span class="comment">    The myobject_doread() function compares the filename argument with the empty symbol -- if the argument was not supplied, the open_dialog() is used, otherwise, we call locatefile_extended() to search for the file. This object looks for text files, so we use a four-character code 'TEXT' as our file type to either open or locate. File type codes define a set of acceptable extensions. The file max-fileformats.txt permits contains standard definitions, and you can add your own by creating a similar text file and placing it in the init folder inside the Cycling '74 folder.</span>
<a name="l00024"></a>00024 <span class="comment"></span>
<a name="l00025"></a>00025 <span class="comment">@code</span>
<a name="l00026"></a>00026 <span class="comment">    void myobject_doread(t_myobject *x, t_symbol *s)</span>
<a name="l00027"></a>00027 <span class="comment">    {</span>
<a name="l00028"></a>00028 <span class="comment">        long filetype = 'TEXT', outtype;</span>
<a name="l00029"></a>00029 <span class="comment">        short numtypes = 1;</span>
<a name="l00030"></a>00030 <span class="comment">        char filename[512];</span>
<a name="l00031"></a>00031 <span class="comment">        short path;</span>
<a name="l00032"></a>00032 <span class="comment"></span>
<a name="l00033"></a>00033 <span class="comment">        if (s == gensym("")) {      // if no argument supplied, ask for file</span>
<a name="l00034"></a>00034 <span class="comment">            if (open_dialog(filename, &amp;path, &amp;outtype, &amp;filetype, 1))       // non-zero: user cancelled</span>
<a name="l00035"></a>00035 <span class="comment">                return;</span>
<a name="l00036"></a>00036 <span class="comment">        } else {</span>
<a name="l00037"></a>00037 <span class="comment">            strcpy(filename, s-&gt;s_name);    // must copy symbol before calling locatefile_extended</span>
<a name="l00038"></a>00038 <span class="comment">            if (locatefile_extended(filename, &amp;path, &amp;outtype, &amp;filetype, 1)) { // non-zero: not found</span>
<a name="l00039"></a>00039 <span class="comment">                object_error(x, "%s: not found", s-&gt;s_name);</span>
<a name="l00040"></a>00040 <span class="comment">                return;</span>
<a name="l00041"></a>00041 <span class="comment">            }</span>
<a name="l00042"></a>00042 <span class="comment">        }</span>
<a name="l00043"></a>00043 <span class="comment">        // we have a file</span>
<a name="l00044"></a>00044 <span class="comment">        myobject_openfile(x, filename, path);</span>
<a name="l00045"></a>00045 <span class="comment">    }</span>
<a name="l00046"></a>00046 <span class="comment">@endcode</span>
<a name="l00047"></a>00047 <span class="comment"></span>
<a name="l00048"></a>00048 <span class="comment">    To open and read files, you can use the cross-platform sysfile API. Files can be opened using a filename plus path identifier. If successfully opened, the file can be accessed using a #t_filehandle. Note that "files" inside collective files are treated identically to regular files, with the exception that they are read-only.</span>
<a name="l00049"></a>00049 <span class="comment"></span>
<a name="l00050"></a>00050 <span class="comment"></span>
<a name="l00051"></a>00051 <span class="comment">    @section chapter_files_reading_text_files Reading Text Files</span>
<a name="l00052"></a>00052 <span class="comment"></span>
<a name="l00053"></a>00053 <span class="comment">    First, we'll implement reading the text file whose name and path identifier are passed to myobject_openfile() using a high-level routine sysfile_readtextfile() specifically for reading text files that handles text encoding conversion for you. If you are reading text files, using this routine is strongly recommended since converting text encodings is unpleasant to say the least.</span>
<a name="l00054"></a>00054 <span class="comment"></span>
<a name="l00055"></a>00055 <span class="comment">@code</span>
<a name="l00056"></a>00056 <span class="comment">    void myobject_openfile(t_myobject *x, char *filename, short path)</span>
<a name="l00057"></a>00057 <span class="comment">    {</span>
<a name="l00058"></a>00058 <span class="comment">        t_filehandle fh;</span>
<a name="l00059"></a>00059 <span class="comment">        char **texthandle;</span>
<a name="l00060"></a>00060 <span class="comment"></span>
<a name="l00061"></a>00061 <span class="comment">        if (path_opensysfile(filename, path, &amp;fh, READ_PERM)) {</span>
<a name="l00062"></a>00062 <span class="comment">            object_error(x, "error opening %s", filename);</span>
<a name="l00063"></a>00063 <span class="comment">            return</span>
<a name="l00064"></a>00064 <span class="comment">        }</span>
<a name="l00065"></a>00065 <span class="comment">        // allocate some empty memory to receive text</span>
<a name="l00066"></a>00066 <span class="comment">        texthandle = sysmem_newhandle(0);</span>
<a name="l00067"></a>00067 <span class="comment">        sysfile_readtextfile(fh, texthandle, 0, 0);     // see flags explanation below</span>
<a name="l00068"></a>00068 <span class="comment">        post("the file has %ld characters",sysmem_gethandlesize(texthandle));</span>
<a name="l00069"></a>00069 <span class="comment">        sysfile_close(fh);</span>
<a name="l00070"></a>00070 <span class="comment">        sysmem_freehandle(texthandle);</span>
<a name="l00071"></a>00071 <span class="comment">    }</span>
<a name="l00072"></a>00072 <span class="comment">@endcode</span>
<a name="l00073"></a>00073 <span class="comment"></span>
<a name="l00074"></a>00074 <span class="comment">    In most situations, you will pass 0 for the final two arguments to sysfile_readtextfile(). The third argument specifies a maximum length to read, but if the value is 0, the entire file is read in, regardless of its size. The final argument is a set of flags specifying options for reading in the text. The options concern the conversion of line breaks, text encoding, and the ability to add a null character to the end of the data returned. </span>
<a name="l00075"></a>00075 <span class="comment"></span>
<a name="l00076"></a>00076 <span class="comment">    Line breaks are converted on the basis of any line break flags. When reading text files, Max converts line breaks to "native" format, which is </span>
<a name="l00077"></a>00077 <span class="comment">    @code \r\n @endcode </span>
<a name="l00078"></a>00078 <span class="comment">    on Windows and </span>
<a name="l00079"></a>00079 <span class="comment">    @code \n @endcode </span>
<a name="l00080"></a>00080 <span class="comment">    on the Mac; this is the behavior you get if you either pass no line break flags or use #TEXT_LB_NATIVE. Other options include #TEXT_LB_MAC, #TEXT_LB_UNIX, or #TEXT_LB_PC.</span>
<a name="l00081"></a>00081 <span class="comment"></span>
<a name="l00082"></a>00082 <span class="comment">    By default, text files are converted from their source encoding to UTF-8. If you do not want this conversion to occur, you can use the #TEXT_ENCODING_USE_FILE flag. This puts the burden on determining the encoding on you, which is probably not what you want. For example, the source text file might use UTF-16 encoding, which requires very different parsing than an 8-bit encoding.</span>
<a name="l00083"></a>00083 <span class="comment"></span>
<a name="l00084"></a>00084 <span class="comment">    Finally, you can have the memory returned from sysfile_readtextfile() terminated with a NULL character if you use the #TEXT_NULL_TERMINATE flag.</span>
<a name="l00085"></a>00085 <span class="comment"></span>
<a name="l00086"></a>00086 <span class="comment"></span>
<a name="l00087"></a>00087 <span class="comment">    @section chapter_files_reading_data_files Reading Data Files</span>
<a name="l00088"></a>00088 <span class="comment"></span>
<a name="l00089"></a>00089 <span class="comment">    To read data files where you do not want to do text encoding conversion or worry about line breaks, you can use the same technique shown above for text files, but write the myobject_openfile function using sysfile_read() instead of sysfile_readtextfile(). This example shows how to read an entire file into a single block of memory.</span>
<a name="l00090"></a>00090 <span class="comment"></span>
<a name="l00091"></a>00091 <span class="comment">@code</span>
<a name="l00092"></a>00092 <span class="comment">    void myobject_openfile(t_myobject *x, char *filename, short path)</span>
<a name="l00093"></a>00093 <span class="comment">    {</span>
<a name="l00094"></a>00094 <span class="comment">        t_filehandle fh;</span>
<a name="l00095"></a>00095 <span class="comment">        char *buffer;</span>
<a name="l00096"></a>00096 <span class="comment">        long size;</span>
<a name="l00097"></a>00097 <span class="comment"></span>
<a name="l00098"></a>00098 <span class="comment">        if (path_opensysfile(filename, path, &amp;fh, READ_PERM)) {</span>
<a name="l00099"></a>00099 <span class="comment">            object_error(x, "error opening %s", filename);</span>
<a name="l00100"></a>00100 <span class="comment">            return</span>
<a name="l00101"></a>00101 <span class="comment">        }</span>
<a name="l00102"></a>00102 <span class="comment">        // allocate memory block that is the size of the file</span>
<a name="l00103"></a>00103 <span class="comment">        sysfile_geteof(fh, &amp;size);</span>
<a name="l00104"></a>00104 <span class="comment">        buffer = sysmem_newptr(size);</span>
<a name="l00105"></a>00105 <span class="comment"></span>
<a name="l00106"></a>00106 <span class="comment">        // read in the file</span>
<a name="l00107"></a>00107 <span class="comment">        sysfile_read(fh, &amp;size, buffer);</span>
<a name="l00108"></a>00108 <span class="comment"></span>
<a name="l00109"></a>00109 <span class="comment">        sysfile_close(fh);</span>
<a name="l00110"></a>00110 <span class="comment"></span>
<a name="l00111"></a>00111 <span class="comment">        // do something with data in buffer here</span>
<a name="l00112"></a>00112 <span class="comment"></span>
<a name="l00113"></a>00113 <span class="comment">        sysmem_freeptr(buffer);     // must free allocated memory</span>
<a name="l00114"></a>00114 <span class="comment">    }</span>
<a name="l00115"></a>00115 <span class="comment">@endcode</span>
<a name="l00116"></a>00116 <span class="comment"></span>
<a name="l00117"></a>00117 <span class="comment"></span>
<a name="l00118"></a>00118 <span class="comment">    @section chapter_files_writing_files Writing Files</span>
<a name="l00119"></a>00119 <span class="comment"></span>
<a name="l00120"></a>00120 <span class="comment">    Some Max objects respond to the write message to save data into a file. If there is no argument present after the word write, a save file dialog is shown and the user specifies a file name and location. If an argument is present, it can either specify a complete path name or a filename. In the filename case, the file is written to the current "default" directory, which is the location where a patcher was last opened. In the full pathname case, the file is written to the location specified by the pathname.</span>
<a name="l00121"></a>00121 <span class="comment"></span>
<a name="l00122"></a>00122 <span class="comment">    Here's how to implement this behavior. We'll show how to handle the message arguments, then provide text and data file writing examples.</span>
<a name="l00123"></a>00123 <span class="comment"></span>
<a name="l00124"></a>00124 <span class="comment">    Message and argument handling is very similar to the way we implemented the read message above, including the use of deferred execution.</span>
<a name="l00125"></a>00125 <span class="comment"></span>
<a name="l00126"></a>00126 <span class="comment">@code</span>
<a name="l00127"></a>00127 <span class="comment">    class_addmethod(c, (method)myobject_write, "write", A_DEFSYM, 0);</span>
<a name="l00128"></a>00128 <span class="comment"></span>
<a name="l00129"></a>00129 <span class="comment">    void myobject_write(t_myobject *x, t_symbol *s)</span>
<a name="l00130"></a>00130 <span class="comment">    {</span>
<a name="l00131"></a>00131 <span class="comment">        defer(x, (method)myobject_dowrite, s, 0, NULL);</span>
<a name="l00132"></a>00132 <span class="comment">    }</span>
<a name="l00133"></a>00133 <span class="comment">@endcode</span>
<a name="l00134"></a>00134 <span class="comment"></span>
<a name="l00135"></a>00135 <span class="comment">    The myobject_dowrite() function compares the filename argument with the empty symbol -- if the argument was not supplied, saveasdialog_extended() is used to obtain the user's choice for filename and location. Our first example looks for text files, so we use a four-character code 'TEXT' as our file type for saving. File type codes define a set of acceptable extensions. The file max-fileformats.txt permits contains standard definitions, and you can add your own by creating a similar text file and placing it in the init folder inside the Cycling '74 folder.</span>
<a name="l00136"></a>00136 <span class="comment"></span>
<a name="l00137"></a>00137 <span class="comment">@code</span>
<a name="l00138"></a>00138 <span class="comment">    void myobject_dowrite(t_myobject *x, t_symbol *s)</span>
<a name="l00139"></a>00139 <span class="comment">    {</span>
<a name="l00140"></a>00140 <span class="comment">        long filetype = 'TEXT', outtype;</span>
<a name="l00141"></a>00141 <span class="comment">        short numtypes = 1;</span>
<a name="l00142"></a>00142 <span class="comment">        char filename[512];</span>
<a name="l00143"></a>00143 <span class="comment">        short path;</span>
<a name="l00144"></a>00144 <span class="comment"></span>
<a name="l00145"></a>00145 <span class="comment">        if (s == gensym("")) {      // if no argument supplied, ask for file</span>
<a name="l00146"></a>00146 <span class="comment">            if (saveasdialog_extended(filename, &amp;path, &amp;outtype, &amp;filetype, 1))     // non-zero: user cancelled</span>
<a name="l00147"></a>00147 <span class="comment">                return;</span>
<a name="l00148"></a>00148 <span class="comment">        } else {</span>
<a name="l00149"></a>00149 <span class="comment">            strcpy(filename, s-&gt;s_name);</span>
<a name="l00150"></a>00150 <span class="comment">            path = path_getdefault();</span>
<a name="l00151"></a>00151 <span class="comment">        }</span>
<a name="l00152"></a>00152 <span class="comment">        myobject_writefile(x, filename, path);</span>
<a name="l00153"></a>00153 <span class="comment">    }</span>
<a name="l00154"></a>00154 <span class="comment">@endcode</span>
<a name="l00155"></a>00155 <span class="comment"></span>
<a name="l00156"></a>00156 <span class="comment">    Here is the text file variant of myobject_writefile() using the high-level sysfile_writetextfile() routine. We just write a sentence as our "text file" but your object will presumably have some text data stored internally that it will write. The buffer passed to sysfile_writetextfile() must be NULL-terminated, and will be assumed to be UTF-8 encoded.</span>
<a name="l00157"></a>00157 <span class="comment"></span>
<a name="l00158"></a>00158 <span class="comment">    Note that path_createsysfile() can accept a full path in the filename argument, in which case, the path argument is ignored. This means your object's write message can either accept a filename or full pathname and you needn't do anything special to accept both.</span>
<a name="l00159"></a>00159 <span class="comment"></span>
<a name="l00160"></a>00160 <span class="comment">@code</span>
<a name="l00161"></a>00161 <span class="comment">    void myobject_writefile(t_myobject *x, char *filename, short path)</span>
<a name="l00162"></a>00162 <span class="comment">    {</span>
<a name="l00163"></a>00163 <span class="comment">        char *buf = "write me into a file";</span>
<a name="l00164"></a>00164 <span class="comment">        long err;</span>
<a name="l00165"></a>00165 <span class="comment">        t_filehandle fh;</span>
<a name="l00166"></a>00166 <span class="comment"></span>
<a name="l00167"></a>00167 <span class="comment">        err = path_createsysfile(filename, path, 'TEXT', &amp;fh); </span>
<a name="l00168"></a>00168 <span class="comment">        if (err)</span>
<a name="l00169"></a>00169 <span class="comment">            return;</span>
<a name="l00170"></a>00170 <span class="comment">        err = sysfile_writetextfile(fh, &amp;buf, TEXT_LB_NATIVE);</span>
<a name="l00171"></a>00171 <span class="comment">        sysfile_close(fh);</span>
<a name="l00172"></a>00172 <span class="comment">    }</span>
<a name="l00173"></a>00173 <span class="comment">@endcode</span>
<a name="l00174"></a>00174 <span class="comment"></span>
<a name="l00175"></a>00175 <span class="comment">    Here is a data file variant of myobject_writefile(). It writes a small buffer of ten numbers to a file.</span>
<a name="l00176"></a>00176 <span class="comment"></span>
<a name="l00177"></a>00177 <span class="comment">@code</span>
<a name="l00178"></a>00178 <span class="comment">    void myobject_writefile(t_myobject *x, char *filename, short path)</span>
<a name="l00179"></a>00179 <span class="comment">    {</span>
<a name="l00180"></a>00180 <span class="comment">        char *buf[10];</span>
<a name="l00181"></a>00181 <span class="comment">        long count, i;</span>
<a name="l00182"></a>00182 <span class="comment">        long err;</span>
<a name="l00183"></a>00183 <span class="comment">        t_filehandle fh;</span>
<a name="l00184"></a>00184 <span class="comment"></span>
<a name="l00185"></a>00185 <span class="comment">        // create some data</span>
<a name="l00186"></a>00186 <span class="comment"></span>
<a name="l00187"></a>00187 <span class="comment">        for (i = 0; i &lt; 10; i++)</span>
<a name="l00188"></a>00188 <span class="comment">            buf[i] = i + 1;</span>
<a name="l00189"></a>00189 <span class="comment"></span>
<a name="l00190"></a>00190 <span class="comment">        count = 10;</span>
<a name="l00191"></a>00191 <span class="comment"></span>
<a name="l00192"></a>00192 <span class="comment">        err = path_createsysfile(filename, path, 'TEXT', &amp;fh); </span>
<a name="l00193"></a>00193 <span class="comment">        if (err)</span>
<a name="l00194"></a>00194 <span class="comment">            return;</span>
<a name="l00195"></a>00195 <span class="comment">        err = sysfile_write(fh, &amp;count, buf);</span>
<a name="l00196"></a>00196 <span class="comment">        sysfile_close(fh);</span>
<a name="l00197"></a>00197 <span class="comment">    }</span>
<a name="l00198"></a>00198 <span class="comment">@endcode</span>
<a name="l00199"></a>00199 <span class="comment"></span>
<a name="l00200"></a>00200 <span class="comment"></span>
<a name="l00201"></a>00201 <span class="comment">*/</span>
</pre></div></div>
		<div id="c74footer">
			<p>Copyright &copy; 2008, <a href="http://www.cycling74.com/">Cycling '74</a></p>
		</div>
	</body>
</html>
