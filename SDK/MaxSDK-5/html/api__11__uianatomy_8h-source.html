<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
		<title>Max5 API Reference</title>
		<link href="c74-doxygen.css" rel="stylesheet" type="text/css">
	</head>
	<body>

		<div id="c74header">
			<img src="max5.png" />
			<p>Max 5 API Reference</p>
		</div>

<!-- Generated by Doxygen 1.5.6 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<h1>api_11_uianatomy.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/** </span>
<a name="l00002"></a>00002 <span class="comment">    @page chapter_ui_anatomy Anatomy of a UI Object</span>
<a name="l00003"></a>00003 <span class="comment"></span>
<a name="l00004"></a>00004 <span class="comment">    Max user interface objects are more complex than normal non-user-interface objects. If you have nothing in particular to display, or do not need to create a unique interface for user interaction or editing, it would be better to avoid writing one. However, if you want the details, we have them for you!</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment">    In order to create a user interface object, you'll need to be familiar with @ref attr, as they are used extensively. If you examine a toggle object in the inspector in Max, you will see a few attributes that have been defined as belonging to the toggle class, namely:</span>
<a name="l00007"></a>00007 <span class="comment"></span>
<a name="l00008"></a>00008 <span class="comment">    - Background Color</span>
<a name="l00009"></a>00009 <span class="comment">    - Check Color</span>
<a name="l00010"></a>00010 <span class="comment">    - Border Color</span>
<a name="l00011"></a>00011 <span class="comment"></span>
<a name="l00012"></a>00012 <span class="comment">    We'll show how attributes are defined and described so that the inspector can edit them properly.</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment">    In addition to attributes, user interface objects draw in a box and respond to user events such as mouse clicks and keyboard events. We'll show how to implement drawing an object's paint method as well user interaction in the mousedown, mousedrag, and mouseup methods.</span>
<a name="l00015"></a>00015 <span class="comment"></span>
<a name="l00016"></a>00016 <span class="comment">    This chapter only covers basic drawing of lines and filled rectangles. But you can take advantage of a complete graphics API called jgraphics, intended to be used in a user interface object's paint method. We discuss @ref chapter_jgraphics in more detail in a separate chapter. You may also find the header file descriptions of the set of @ref jgraphics functions helpful.</span>
<a name="l00017"></a>00017 <span class="comment"></span>
<a name="l00018"></a>00018 <span class="comment">    The SDK examples contain two user interface projects -- the one we'll discuss in this chapter is called &lt;a href="uisimp_8c-source.html"&gt;uisimp&lt;/a&gt; and is a version of the toggle object with a more complicated check box and user interaction. The second project is called &lt;a href="pictmeter~_8c-source.html"&gt;pictmeter~&lt;/a&gt;, a more advanced object that uses audio as well as image files.</span>
<a name="l00019"></a>00019 <span class="comment"></span>
<a name="l00020"></a>00020 <span class="comment">    The uisimp object differs from the toggle object in a couple of ways:</span>
<a name="l00021"></a>00021 <span class="comment"></span>
<a name="l00022"></a>00022 <span class="comment">    - it tracks the mouse even when it isn't down and "looks excited" when the mouse passes over it</span>
<a name="l00023"></a>00023 <span class="comment">    - it tracks the mouse while the user is holding the mouse down to show a sort of "depressed" appearance when turning the toggle on</span>
<a name="l00024"></a>00024 <span class="comment">    - the new toggle state value is sent out when the mouse is released rather than when the mouse is down. In addition, the uisimp object tracks the mouse and does not change the state if the mouse is released outside of the object's box</span>
<a name="l00025"></a>00025 <span class="comment">    - it doesn't have rounded corners </span>
<a name="l00026"></a>00026 <span class="comment">    - it has a solid square for a "checked state" instead of an X</span>
<a name="l00027"></a>00027 <span class="comment"></span>
<a name="l00028"></a>00028 <span class="comment">    Otherwise, it acts largely as the toggle does.</span>
<a name="l00029"></a>00029 <span class="comment"></span>
<a name="l00030"></a>00030 <span class="comment">    The first thing we suggest you do is build the uisimp object and test it out. Once the object is properly building, type "uisimp" into an object box and you can try it out.</span>
<a name="l00031"></a>00031 <span class="comment"></span>
<a name="l00032"></a>00032 <span class="comment"></span>
<a name="l00033"></a>00033 <span class="comment">    @section chapter_ui_anatomy_headers Required Headers</span>
<a name="l00034"></a>00034 <span class="comment"></span>
<a name="l00035"></a>00035 <span class="comment">    UI objects require that you include two header files, jpatcher_api.h and jgraphics.h:</span>
<a name="l00036"></a>00036 <span class="comment"></span>
<a name="l00037"></a>00037 <span class="comment">@code</span>
<a name="l00038"></a>00038 <span class="comment">    #include "jpatcher_api.h"</span>
<a name="l00039"></a>00039 <span class="comment">    #include "jgraphics.h"</span>
<a name="l00040"></a>00040 <span class="comment">@endcode</span>
<a name="l00041"></a>00041 <span class="comment"></span>
<a name="l00042"></a>00042 <span class="comment">    The header file jpatcher_api.h includes data structures and accessor functions required by UI objects. The header file jgraphics.h includes data structures and functions for drawing.</span>
<a name="l00043"></a>00043 <span class="comment"></span>
<a name="l00044"></a>00044 <span class="comment"></span>
<a name="l00045"></a>00045 <span class="comment">    @section chapter_ui_anatomy_struct UI Object Data Structure</span>
<a name="l00046"></a>00046 <span class="comment"></span>
<a name="l00047"></a>00047 <span class="comment">    The first part of a UI object is a #t_jbox, not a #t_object. You should generally avoid direct access to fields of a #t_jbox, particularly when changing values, and use the accessor functions defined in jpatcher_api.h. For example, if you change the rectangle of a box without using the accessor function jbox_set_rect(), the patcher will not be notified properly and the screen will not update.</span>
<a name="l00048"></a>00048 <span class="comment"></span>
<a name="l00049"></a>00049 <span class="comment">    Following the #t_jbox, you can add other fields for storing the internal state of your object. In particular, if you are going to be drawing something using color, you will want to create attributes that reference fields holding colors in your object. We'll show you how to do this below. Here is the declaration of the t_uisimp data structure.</span>
<a name="l00050"></a>00050 <span class="comment"></span>
<a name="l00051"></a>00051 <span class="comment">@code</span>
<a name="l00052"></a>00052 <span class="comment">    typedef struct _uisimp </span>
<a name="l00053"></a>00053 <span class="comment">    {</span>
<a name="l00054"></a>00054 <span class="comment">        t_jbox u_box;                       // header for UI objects</span>
<a name="l00055"></a>00055 <span class="comment">        void *u_out;                        // outlet pointer</span>
<a name="l00056"></a>00056 <span class="comment">        long u_state;                       // state (1 or 0)</span>
<a name="l00057"></a>00057 <span class="comment">        char u_mouseover;                   // is mouse over the object</span>
<a name="l00058"></a>00058 <span class="comment">        char u_mousedowninside;             // is mouse down within the object</span>
<a name="l00059"></a>00059 <span class="comment">        char u_trackmouse;                  // if non-zero, track mouse when button not down</span>
<a name="l00060"></a>00060 <span class="comment">        t_jrgba u_outline;                  // outline color</span>
<a name="l00061"></a>00061 <span class="comment">        t_jrgba u_check;                    // check (square) color</span>
<a name="l00062"></a>00062 <span class="comment">        t_jrgba u_background;               // background color</span>
<a name="l00063"></a>00063 <span class="comment">        t_jrgba u_hilite;                   // highlight color (when mouse is over and when clicking to check box)</span>
<a name="l00064"></a>00064 <span class="comment">    } t_uisimp;</span>
<a name="l00065"></a>00065 <span class="comment">@endcode</span>
<a name="l00066"></a>00066 <span class="comment"></span>
<a name="l00067"></a>00067 <span class="comment">    The #t_jrgba structure defines a color with four doubles for red, green, blue, and alpha. Each component ranges from 0-1. When red, green, and blue are all 0, the color is black; when red, green, and blue are 1, the color is white. By defining color attributes using #t_jrgba structures, you will permit the user to use the standard color picker from the inspector to configure colors for your object.</span>
<a name="l00068"></a>00068 <span class="comment"></span>
<a name="l00069"></a>00069 <span class="comment">    The structure members u_mouseover and u_mousedowninside are used to signal the code that paints the toggle from the code that handles mouse interaction. We'll discuss this more in the "interaction strategy" section below.</span>
<a name="l00070"></a>00070 <span class="comment"></span>
<a name="l00071"></a>00071 <span class="comment"></span>
<a name="l00072"></a>00072 <span class="comment">    @section chapter_ui_anatomy_init Initialization Routine for UI Objects</span>
<a name="l00073"></a>00073 <span class="comment"></span>
<a name="l00074"></a>00074 <span class="comment">    Once you've declared your object's struct, you'll write your initialization (main) routine to set up the class, declaring methods and attributes used by UI objects.</span>
<a name="l00075"></a>00075 <span class="comment"></span>
<a name="l00076"></a>00076 <span class="comment">    The first addition to the class initialization of a normal Max object you need to make is a call to jbox_initclass(). This adds standard methods and attributes common to all UI objects. Here's how you should to it:</span>
<a name="l00077"></a>00077 <span class="comment"></span>
<a name="l00078"></a>00078 <span class="comment">@code</span>
<a name="l00079"></a>00079 <span class="comment">    c = class_new("uisimp", (method)uisimp_new, (method)uisimp_free, sizeof(t_uisimp), 0L, A_GIMME, 0);</span>
<a name="l00080"></a>00080 <span class="comment"></span>
<a name="l00081"></a>00081 <span class="comment">    c-&gt;c_flags |= CLASS_FLAG_NEWDICTIONARY;</span>
<a name="l00082"></a>00082 <span class="comment">    jbox_initclass(c, JBOX_FIXWIDTH | JBOX_COLOR);</span>
<a name="l00083"></a>00083 <span class="comment">@endcode</span>
<a name="l00084"></a>00084 <span class="comment"></span>
<a name="l00085"></a>00085 <span class="comment">    The line c-&gt;c_flags |= #CLASS_FLAG_NEWDICTIONARY is required, but the flags passed to jbox_initclass -- #JBOX_FIXWIDTH and #JBOX_COLOR -- are optional. #JBOX_FIXWIDTH means that when your object is selected in a patcher, the Fix Width menu item will be enabled to resize your object to its class's default dimensions. We'll specify the default dimensions in a moment. #JBOX_COLOR means that your object will be given a color attribute so that it can be edited with the color picked shown by the Color... menu item. This is a way to edit a "basic" color of your object without opening the inspector. If neither of these behaviors apply to your object, feel free to pass 0 for the flags argument to jbox_initclass().</span>
<a name="l00086"></a>00086 <span class="comment"></span>
<a name="l00087"></a>00087 <span class="comment"></span>
<a name="l00088"></a>00088 <span class="comment">    @section chapter_ui_anatomy_methods UI Object Methods</span>
<a name="l00089"></a>00089 <span class="comment"></span>
<a name="l00090"></a>00090 <span class="comment">    Next we need to bind a few standard methods. The only required method for UI objects is paint, which draws the your object's content when its box is visible and needs to be redrawn.</span>
<a name="l00091"></a>00091 <span class="comment"></span>
<a name="l00092"></a>00092 <span class="comment">@code</span>
<a name="l00093"></a>00093 <span class="comment">    class_addmethod(c, (method)uisimp_paint,        "paint",    A_CANT, 0);</span>
<a name="l00094"></a>00094 <span class="comment">@endcode</span>
<a name="l00095"></a>00095 <span class="comment"></span>
<a name="l00096"></a>00096 <span class="comment">    We'll discuss the paint method in detail below. It makes use of the @ref jgraphics API, which is described in more detail in its own chapter.</span>
<a name="l00097"></a>00097 <span class="comment"></span>
<a name="l00098"></a>00098 <span class="comment">    Our uisimp toggle will respond to mouse gestures, so we will define a set of mouse handling methods.</span>
<a name="l00099"></a>00099 <span class="comment"></span>
<a name="l00100"></a>00100 <span class="comment">@code</span>
<a name="l00101"></a>00101 <span class="comment">    class_addmethod(c, (method)uisimp_mousedown,    "mousedown",    A_CANT, 0);</span>
<a name="l00102"></a>00102 <span class="comment">    class_addmethod(c, (method)uisimp_mousedrag,    "mousedrag",    A_CANT, 0);</span>
<a name="l00103"></a>00103 <span class="comment">    class_addmethod(c, (method)uisimp_mouseup,      "mouseup",      A_CANT, 0);</span>
<a name="l00104"></a>00104 <span class="comment">    class_addmethod(c, (method)uisimp_mouseenter,   "mouseenter",   A_CANT, 0);</span>
<a name="l00105"></a>00105 <span class="comment">    class_addmethod(c, (method)uisimp_mouseleave,   "mouseleave",   A_CANT, 0);</span>
<a name="l00106"></a>00106 <span class="comment">    class_addmethod(c, (method)uisimp_mousemove,    "mousemove",    A_CANT, 0);</span>
<a name="l00107"></a>00107 <span class="comment">@endcode</span>
<a name="l00108"></a>00108 <span class="comment"></span>
<a name="l00109"></a>00109 <span class="comment">    mousedown is sent to your object when the user clicks on your object -- in other words, when the mouse is moved over the object and the primary mouse button is depressed. mousedrag is sent after an initial mousedown when the mouse moves and the button is still held down from the click. mouseup is sent when the mouse button is released after a mousedown is sent. mouseenter is sent when the mouse button is not down and the mouse moves into your object's box. mousemove is sent -- after a mouseenter -- when the mouse button is not down but the mouse position changes inside your object's box. mouseleave is sent when the mouse button is not down and the mouse position moves from being over your object's box to being outside of it.</span>
<a name="l00110"></a>00110 <span class="comment"></span>
<a name="l00111"></a>00111 <span class="comment">    You are not obligated to respond to any of these messages. You could, for example, only respond to mousedown and ignore the other messages.</span>
<a name="l00112"></a>00112 <span class="comment"></span>
<a name="l00113"></a>00113 <span class="comment">    It might be helpful to summarize mouse messages in the following "rules" (although normally it's not necessary to think about them explicitly):</span>
<a name="l00114"></a>00114 <span class="comment"></span>
<a name="l00115"></a>00115 <span class="comment">    - mousedown will always be followed by mouseup, but not necessarily by mousedrag if the button press is rapid and there is no movement while the mouse button is pressed.</span>
<a name="l00116"></a>00116 <span class="comment">    - mouseenter will always be followed by mouseleave, but </span>
<a name="l00117"></a>00117 <span class="comment">    - mouseenter will always precede mousemove</span>
<a name="l00118"></a>00118 <span class="comment">    - mouseleave will be sent only after a mouseenter is sent</span>
<a name="l00119"></a>00119 <span class="comment">    - You cannot count on any particular relationship between the mousedown / mousedrag / mouseup sequence and the mouseenter / mousemove / mouseleave sequence.</span>
<a name="l00120"></a>00120 <span class="comment"></span>
<a name="l00121"></a>00121 <span class="comment">    We'll look at the actual implementation of mouse handling methods below.</span>
<a name="l00122"></a>00122 <span class="comment"></span>
<a name="l00123"></a>00123 <span class="comment"></span>
<a name="l00124"></a>00124 <span class="comment">    @section chapter_ui_anatomy_attributes Defining Attributes</span>
<a name="l00125"></a>00125 <span class="comment"></span>
<a name="l00126"></a>00126 <span class="comment">    After the declaration of standard methods, your object will define its own attributes. By using what we call "attribute attributes" you can further describe attributes so that they can be appropriately displayed and edited in the inspector as well as saved in a patcher (or not). You can also set default values for attributes that are automatically copied to your object when it is instantiated, and mark an attribute so that your object is redrawn when its value changes.</span>
<a name="l00127"></a>00127 <span class="comment"></span>
<a name="l00128"></a>00128 <span class="comment">    As a convenience, we've defined a series of macros in ext_obex_util.h (which is included when your object includes ext_obex.h) that reduce the amount of typing needed to define attributes and attribute attributes.</span>
<a name="l00129"></a>00129 <span class="comment"></span>
<a name="l00130"></a>00130 <span class="comment">    Most UI object attributes are offset attributes; that is, they reference a location in your object's data structure by offset and size. As an example, uisimp has a char offset attribute called trackmouse that specifies whether the object will change the object's appearance when the mouse moves over it. Here's how this is defined:</span>
<a name="l00131"></a>00131 <span class="comment"></span>
<a name="l00132"></a>00132 <span class="comment">@code</span>
<a name="l00133"></a>00133 <span class="comment">    CLASS_ATTR_CHAR(c, "trackmouse", 0, t_uisimp, u_trackmouse);</span>
<a name="l00134"></a>00134 <span class="comment">    CLASS_ATTR_STYLE_LABEL(c, "trackmouse", 0, "onoff", "Track Mouse");</span>
<a name="l00135"></a>00135 <span class="comment">    CLASS_ATTR_SAVE(c, "trackmouse", 0);</span>
<a name="l00136"></a>00136 <span class="comment">@endcode</span>
<a name="l00137"></a>00137 <span class="comment"></span>
<a name="l00138"></a>00138 <span class="comment">    The first line, #CLASS_ATTR_CHAR, defines a char-sized offset attribute. If you look at the declaration of t_uisimp, you can see that the u_trackmouse field is declared to be a char. The #CLASS_ATTR_CHAR macro take five arguments. </span>
<a name="l00139"></a>00139 <span class="comment"></span>
<a name="l00140"></a>00140 <span class="comment">    - The first argument is the class for which the attribute is being declared. </span>
<a name="l00141"></a>00141 <span class="comment">    - The second argument is the name of the attribute. You can use send a message to your object with this name and a value and set the attribute. </span>
<a name="l00142"></a>00142 <span class="comment">    - The third argument is a collection of attribute flags. For the attributes (and attribute attributes) we'll be defining in the uisimp object, the flags will be 0, but you can use them to make attributes read-only with #ATTR_SET_OPAQUE_USER.</span>
<a name="l00143"></a>00143 <span class="comment">    - The fourth argument is the name of your object's structure containing the field you want to use for the attribute</span>
<a name="l00144"></a>00144 <span class="comment">    - The fifth argument is the field name you want to use for the attribute</span>
<a name="l00145"></a>00145 <span class="comment"></span>
<a name="l00146"></a>00146 <span class="comment">    The fourth and fifth arguments are used to calculate the offset of the beginning of the field from the beginning of the structure. This allows the attribute to read and write the memory occupied by the field directly.</span>
<a name="l00147"></a>00147 <span class="comment"></span>
<a name="l00148"></a>00148 <span class="comment">    The second line, #CLASS_ATTR_STYLE_LABEL, defines some attribute attributes for the trackmouse attribute. THis macro takes five arguments as well:</span>
<a name="l00149"></a>00149 <span class="comment"></span>
<a name="l00150"></a>00150 <span class="comment">    - The first argument is the class for which the attribute attributes are being declared. </span>
<a name="l00151"></a>00151 <span class="comment">    - The second argument is the name of the attribute, which should have already been defined by a #CLASS_ATTR_CHAR or similar attribute declaration</span>
<a name="l00152"></a>00152 <span class="comment">    - The third argument is usually 0 -- it is an attribute flags argument for the attribute attributes</span>
<a name="l00153"></a>00153 <span class="comment">    - The fourth argument is the style of the attribute. "onoff" is used here for a setting in your object that will be a toggle. By using the onoff style the trackmouse attribute will appear with a checkbox in the inspector window. Effectively, this macro defines an attribute called "style" that is attached to the "trackmouse" attribute and set its value to the symbol "onoff" in one step.</span>
<a name="l00154"></a>00154 <span class="comment">    - The fifth argument is a string used as a descriptive label for the attribute that appears in the inspector and other places in the Max user interface. If you don't supply a label, the attribute name will be shown. The string is used as the value of a newly created "label" attribute attribute.</span>
<a name="l00155"></a>00155 <span class="comment"></span>
<a name="l00156"></a>00156 <span class="comment">    The category attribute attribute is used to organize your object's attributes in the inspector window. For the trackmouse attribute, we use the "Behavior" category, and for the color attributes discussed below, we use "Color" -- look at the inspector category tabs for a few UI objects that come with Max for suggested standard category names. You're free to create your own. </span>
<a name="l00157"></a>00157 <span class="comment"></span>
<a name="l00158"></a>00158 <span class="comment">    To define a category for a single attribute, you can use the #CLASS_ATTR_CATEGORY macro:</span>
<a name="l00159"></a>00159 <span class="comment"></span>
<a name="l00160"></a>00160 <span class="comment">@code</span>
<a name="l00161"></a>00161 <span class="comment">    CLASS_ATTR_CATEGORY(c, "trackmouse", 0, "Behavior");</span>
<a name="l00162"></a>00162 <span class="comment">@endcode</span>
<a name="l00163"></a>00163 <span class="comment"></span>
<a name="l00164"></a>00164 <span class="comment">    To define a category for a series of attributes, you can use #CLASS_STICKY_ATTR, which applies the current value of a specified attribute attribute to any attributes subsequently defined, until a #CLASS_STICKY_ATTR_CLEAR is set for an attribute attribute name. #CLASS_STICKY_ATTR is used in uisimp to apply the "Color" category to a set of three color attributes.</span>
<a name="l00165"></a>00165 <span class="comment"></span>
<a name="l00166"></a>00166 <span class="comment">@code</span>
<a name="l00167"></a>00167 <span class="comment">    CLASS_STICKY_ATTR(c, "category", 0, "Color");</span>
<a name="l00168"></a>00168 <span class="comment">@endcode</span>
<a name="l00169"></a>00169 <span class="comment"></span>
<a name="l00170"></a>00170 <span class="comment">    Color attributes are defined using #CLASS_ATTR_RGBA. The uisimp object defines four color attributes. Here is the first, called bgcolor:</span>
<a name="l00171"></a>00171 <span class="comment"></span>
<a name="l00172"></a>00172 <span class="comment">@code</span>
<a name="l00173"></a>00173 <span class="comment">    CLASS_ATTR_RGBA(c, "bgcolor", 0, t_uisimp, u_background); </span>
<a name="l00174"></a>00174 <span class="comment">    CLASS_ATTR_DEFAULTNAME_SAVE_PAINT(c, "bgcolor", 0, "1. 1. 1. 1."); </span>
<a name="l00175"></a>00175 <span class="comment">    CLASS_ATTR_STYLE_LABEL(c,"bgcolor",0,"rgba","Background Color");</span>
<a name="l00176"></a>00176 <span class="comment">@endcode</span>
<a name="l00177"></a>00177 <span class="comment"></span>
<a name="l00178"></a>00178 <span class="comment">    The difference between #CLASS_ATTR_RGBA and #CLASS_ATTR_CHAR for defining an attribute is that #CLASS_ATTR_RGBA expects the name of a structure member declared of type #t_jrgba rather than type char. When set, the attribute will assign values to the four doubles that make up the components of the color.</span>
<a name="l00179"></a>00179 <span class="comment"></span>
<a name="l00180"></a>00180 <span class="comment">    The next line uses the #CLASS_ATTR_DEFAULTNAME_SAVE_PAINT macro. This sets three things about the bgcolor attribute. First it says that the color attribute bgcolor can be assigned a default value via the object defaults window. So, if you don't like the standard white defined by the object, you can assign you own color for the background color of all newly created uisimp objects. The four values 1 1 1 1 supplied as the last argument to #CLASS_ATTR_DEFAULTNAME_SAVE_PAINT specify the "standard" default value that will be used for the bgcolor attribute in the absence of any overrides from the user.</span>
<a name="l00181"></a>00181 <span class="comment"></span>
<a name="l00182"></a>00182 <span class="comment">    The SAVE aspect of this macro specifies that this attribute's values should be saved with the object in a patcher. A patcher file saves an object's class, location and connections, but it can also save the object's appearance or any other attribute value you specify, by using the "save" attribute attribute.</span>
<a name="l00183"></a>00183 <span class="comment"></span>
<a name="l00184"></a>00184 <span class="comment">    The PAINT aspect of this macro provides the ability to have your object redrawn whenever this attribute (bgcolor) changes. However, to implement auto-repainting on attribute changes, you'll need to add the following code when initializing your class:</span>
<a name="l00185"></a>00185 <span class="comment"> </span>
<a name="l00186"></a>00186 <span class="comment">@code</span>
<a name="l00187"></a>00187 <span class="comment">    class_addmethod(c, (method)jbox_notify, "notify", A_CANT, 0);</span>
<a name="l00188"></a>00188 <span class="comment">@endcode</span>
<a name="l00189"></a>00189 <span class="comment"> </span>
<a name="l00190"></a>00190 <span class="comment">    The function jbox_notify() will determine whether an attribute that has caused a change notification to be sent has its paint attribute attribute set, and if so, will call jbox_redraw. If you write your own notify method because you want to respond to changes in attributes or other environment changes, you can call jbox_notify inside of it.</span>
<a name="l00191"></a>00191 <span class="comment"></span>
<a name="l00192"></a>00192 <span class="comment">    @subsection chapter_ui_anatomy_attributes_color Standard Color Attribute</span>
<a name="l00193"></a>00193 <span class="comment"></span>
<a name="l00194"></a>00194 <span class="comment">    At the beginning of our initialization routine, we passed #JBOX_COLOR as a flag to jbox_initclass(). This adds an attribute to our object called color, which uses storage provided in the #t_jbox to keep track of a color for us. The color attribute is a standard name for the "most basic" color your object uses, and if you define it, the Color menu item in the Object menu will be enabled when your object is selected, permitting the user to change the color without opening the inspector. </span>
<a name="l00195"></a>00195 <span class="comment"></span>
<a name="l00196"></a>00196 <span class="comment">    If you use #JBOX_COLOR, you don't need to define the color attribute using #CLASS_ATTR_RGBA -- jbox_initclass() will do it for you. However, the color attribute comes unadorned, so you are free to enhance it with attribute attributes. Here's what uisimp does:</span>
<a name="l00197"></a>00197 <span class="comment"></span>
<a name="l00198"></a>00198 <span class="comment">@code</span>
<a name="l00199"></a>00199 <span class="comment">    CLASS_ATTR_DEFAULTNAME_SAVE_PAINT(c, "color", 0, "0. 0. 0. 1."); </span>
<a name="l00200"></a>00200 <span class="comment">    CLASS_ATTR_STYLE_LABEL(c,"color",0,"rgba","Check Color");</span>
<a name="l00201"></a>00201 <span class="comment">@endcode</span>
<a name="l00202"></a>00202 <span class="comment"></span>
<a name="l00203"></a>00203 <span class="comment"></span>
<a name="l00204"></a>00204 <span class="comment">    @subsection chapter_ui_anatomy_attributes_size Setting a Default Size</span>
<a name="l00205"></a>00205 <span class="comment"></span>
<a name="l00206"></a>00206 <span class="comment">    Another attribute defined for your object by jbox_initclass() is called patching_rect. It holds the dimensions of your object's box. If you want to set a standard size for new instances of your object, you can give the patching_rect a set of default values. Use 0 0 for the first two values (x and y position) and use the next two values to define the width and height. We want a small square to be the default size for uisimp, so we use #CLASS_ATTR_DEFAULT to assign a default value to the patching_rect attribute as follows:</span>
<a name="l00207"></a>00207 <span class="comment"></span>
<a name="l00208"></a>00208 <span class="comment">@code</span>
<a name="l00209"></a>00209 <span class="comment">    CLASS_ATTR_DEFAULT(c,"patching_rect",0, "0. 0. 20. 20.");</span>
<a name="l00210"></a>00210 <span class="comment">@endcode</span>
<a name="l00211"></a>00211 <span class="comment"></span>
<a name="l00212"></a>00212 <span class="comment"></span>
<a name="l00213"></a>00213 <span class="comment"></span>
<a name="l00214"></a>00214 <span class="comment">    @section chapter_ui_anatomy_new New Instance Routine</span>
<a name="l00215"></a>00215 <span class="comment"></span>
<a name="l00216"></a>00216 <span class="comment">    The UI object new instance routine is more complicated than that of a normal Max object. Each UI object is passed a #t_dictionary (a hierarchically structured collection of data accessed by symbolic names) containing the information needed to instantiate an instance. For UI objects, data elements in the dictionary correspond to attribute values. For example, if your object saved an attribute called "bgcolor" you will be able to access the saved value in your new instance routine from the dictionary using the same name bgcolor.</span>
<a name="l00217"></a>00217 <span class="comment"></span>
<a name="l00218"></a>00218 <span class="comment">    If the instance is being created from the object palette or by the typing the name of your object into an object box, the dictionary will be filled in with default values. If the object is being created by reading a patcher file, the dictionary will be filled in with the saved attributes stored in the file. In most cases, you don't need to work with the dictionary directly, unless you've added proprietary non-attribute information to your object's dictionary that you want to look for and extract. However, you do need to pass the dictionary to some standard routines, and initialize everything in the right order.</span>
<a name="l00219"></a>00219 <span class="comment"></span>
<a name="l00220"></a>00220 <span class="comment">    Let's take a look at the pattern you should follow for your object's new instance routine.</span>
<a name="l00221"></a>00221 <span class="comment"></span>
<a name="l00222"></a>00222 <span class="comment">    First, the new instance routine is declared as follows:</span>
<a name="l00223"></a>00223 <span class="comment"></span>
<a name="l00224"></a>00224 <span class="comment">@code</span>
<a name="l00225"></a>00225 <span class="comment">    void *uisimp_new(t_symbol *s, long argc, t_atom *argv);</span>
<a name="l00226"></a>00226 <span class="comment">@endcode</span>
<a name="l00227"></a>00227 <span class="comment"></span>
<a name="l00228"></a>00228 <span class="comment">    We will get the dictionary that defines the object out of the arguments passed in argc, argv. (The symbol argument s is the name of the object.) If obtaining the dictionary fails, we should return NULL to indicate we didn't make an instance.</span>
<a name="l00229"></a>00229 <span class="comment"></span>
<a name="l00230"></a>00230 <span class="comment">@code</span>
<a name="l00231"></a>00231 <span class="comment">    void *uisimp_new(t_symbol *s, long argc, t_atom *argv);</span>
<a name="l00232"></a>00232 <span class="comment">    {</span>
<a name="l00233"></a>00233 <span class="comment">        t_uisimp *x = NULL;</span>
<a name="l00234"></a>00234 <span class="comment">        t_dictionary *d = NULL;</span>
<a name="l00235"></a>00235 <span class="comment">        long boxflags;</span>
<a name="l00236"></a>00236 <span class="comment"></span>
<a name="l00237"></a>00237 <span class="comment">        if (!(d = object_dictionaryarg(argc,argv)))</span>
<a name="l00238"></a>00238 <span class="comment">            return NULL;</span>
<a name="l00239"></a>00239 <span class="comment">@endcode</span>
<a name="l00240"></a>00240 <span class="comment"></span>
<a name="l00241"></a>00241 <span class="comment">    Next, we allocate a new instance of the object's class: </span>
<a name="l00242"></a>00242 <span class="comment"></span>
<a name="l00243"></a>00243 <span class="comment">@code</span>
<a name="l00244"></a>00244 <span class="comment">    x = (t_uisimp *)object_alloc(s_uisimp_class);</span>
<a name="l00245"></a>00245 <span class="comment">@endcode</span>
<a name="l00246"></a>00246 <span class="comment"></span>
<a name="l00247"></a>00247 <span class="comment">    Then we need to initialize the options for our box. Our object uses the options that are not commented out. </span>
<a name="l00248"></a>00248 <span class="comment"></span>
<a name="l00249"></a>00249 <span class="comment">@code</span>
<a name="l00250"></a>00250 <span class="comment">    boxflags = 0 </span>
<a name="l00251"></a>00251 <span class="comment">            | JBOX_DRAWFIRSTIN </span>
<a name="l00252"></a>00252 <span class="comment">            | JBOX_NODRAWBOX</span>
<a name="l00253"></a>00253 <span class="comment">            | JBOX_DRAWINLAST</span>
<a name="l00254"></a>00254 <span class="comment">            | JBOX_TRANSPARENT  </span>
<a name="l00255"></a>00255 <span class="comment">    //      | JBOX_NOGROW</span>
<a name="l00256"></a>00256 <span class="comment">            | JBOX_GROWY</span>
<a name="l00257"></a>00257 <span class="comment">    //      | JBOX_GROWBOTH</span>
<a name="l00258"></a>00258 <span class="comment">    //      | JBOX_HILITE</span>
<a name="l00259"></a>00259 <span class="comment">    //      | JBOX_BACKGROUND</span>
<a name="l00260"></a>00260 <span class="comment">            | JBOX_DRAWBACKGROUND</span>
<a name="l00261"></a>00261 <span class="comment">    //      | JBOX_NOFLOATINSPECTOR</span>
<a name="l00262"></a>00262 <span class="comment">    //      | JBOX_MOUSEDRAGDELTA</span>
<a name="l00263"></a>00263 <span class="comment">    //      | JBOX_TEXTFIELD</span>
<a name="l00264"></a>00264 <span class="comment">            ;</span>
<a name="l00265"></a>00265 <span class="comment">@endcode</span>
<a name="l00266"></a>00266 <span class="comment"></span>
<a name="l00267"></a>00267 <span class="comment">    Here is some more detail about each of the box flags.</span>
<a name="l00268"></a>00268 <span class="comment"></span>
<a name="l00269"></a>00269 <span class="comment">    We pass the flags along with a pointer to our newly created instance and the argc, argv arguments to jbox_new(). The name is a little misleading. jbox_new() does not instantiate your box. As we explained above, your UI object has a #t_jbox at the beginning. jbox_new() just initializes the #t_jbox for you. jbox_new() doesn't know about the other stuff in your object's data structure that comes after the #t_jbox. You'll have to initialize the extra items yourself.</span>
<a name="l00270"></a>00270 <span class="comment"></span>
<a name="l00271"></a>00271 <span class="comment">@code</span>
<a name="l00272"></a>00272 <span class="comment">    jbox_new((t_jbox *)x, boxflags, argc, argv);</span>
<a name="l00273"></a>00273 <span class="comment">@endcode</span>
<a name="l00274"></a>00274 <span class="comment"></span>
<a name="l00275"></a>00275 <span class="comment">    Once jbox_new() has been called, you then assign the b_firstin pointer of your #t_jbox header to point to your object. Essentially this assigns the object that will receive messages from objects connected to your leftmost inlet (as well as other inlets via inlets or proxies you create). This step is easily forgotten and will cause most things not to work until you remember it. jbox_new() will obtain the attributes common to all boxes such as the patching_rect, and assign them to your object for you.</span>
<a name="l00276"></a>00276 <span class="comment"></span>
<a name="l00277"></a>00277 <span class="comment">@code</span>
<a name="l00278"></a>00278 <span class="comment">    x-&gt;u_box.b_firstin = (void *)x;</span>
<a name="l00279"></a>00279 <span class="comment">@endcode</span>
<a name="l00280"></a>00280 <span class="comment"></span>
<a name="l00281"></a>00281 <span class="comment">    Next, you are free to initialize any members of your object's data structure, as well as declare inlets. These steps are the same for UI objects as for non-UI objects.</span>
<a name="l00282"></a>00282 <span class="comment"></span>
<a name="l00283"></a>00283 <span class="comment">@code</span>
<a name="l00284"></a>00284 <span class="comment">    x-&gt;u_mousedowninside = x-&gt;u_mouseover = x-&gt;u_state = 0;</span>
<a name="l00285"></a>00285 <span class="comment">    x-&gt;u_out = intout((t_object *)x);</span>
<a name="l00286"></a>00286 <span class="comment">@endcode</span>
<a name="l00287"></a>00287 <span class="comment"></span>
<a name="l00288"></a>00288 <span class="comment">    Once your object is in a safe initialized state, call attr_dictionary_process() if you've defined any attributes. This will find the attributes in the dictionary your object received, then set them to the values stored in the dictionary. There is no way to guarantee the order in which the attributes will be set. If this a problem, you can obtain the attribute values "by hand" and assign them to your object. </span>
<a name="l00289"></a>00289 <span class="comment"></span>
<a name="l00290"></a>00290 <span class="comment">    Note that you do not need to call attr_dictionary_process() if you have not defined any attributes. jbox_new() will take care of setting all attributes common to all UI objects.</span>
<a name="l00291"></a>00291 <span class="comment"></span>
<a name="l00292"></a>00292 <span class="comment">@code</span>
<a name="l00293"></a>00293 <span class="comment">        attr_dictionary_process(x,d);</span>
<a name="l00294"></a>00294 <span class="comment">@endcode</span>
<a name="l00295"></a>00295 <span class="comment"></span>
<a name="l00296"></a>00296 <span class="comment">    As the last thing to do before returning your newly created UI object, and more specifically after you've initialized everything to finalize the appearance of your object, call jbox_ready(). jbox_ready() will paint your object, calculate the positions of the inlets and outlets, and perform other initialization tasks to ensure that your box is a proper member of the visible patcher.</span>
<a name="l00297"></a>00297 <span class="comment"></span>
<a name="l00298"></a>00298 <span class="comment">    If your object does not appear when you instantiate it, you should check whether you do not have a jbox_ready() call.</span>
<a name="l00299"></a>00299 <span class="comment"></span>
<a name="l00300"></a>00300 <span class="comment">@code</span>
<a name="l00301"></a>00301 <span class="comment">        jbox_ready((t_jbox *)x);</span>
<a name="l00302"></a>00302 <span class="comment">@endcode</span>
<a name="l00303"></a>00303 <span class="comment"></span>
<a name="l00304"></a>00304 <span class="comment">    Finally, as with any instance creation routine, the newly created object will be returned.</span>
<a name="l00305"></a>00305 <span class="comment"></span>
<a name="l00306"></a>00306 <span class="comment">@code</span>
<a name="l00307"></a>00307 <span class="comment">    return x;</span>
<a name="l00308"></a>00308 <span class="comment">@endcode</span>
<a name="l00309"></a>00309 <span class="comment"></span>
<a name="l00310"></a>00310 <span class="comment"></span>
<a name="l00311"></a>00311 <span class="comment">    @section chapter_ui_anatomy_updating Dynamic Updating</span>
<a name="l00312"></a>00312 <span class="comment"></span>
<a name="l00313"></a>00313 <span class="comment">    Drawing anything to the screen must be limited to your paint method (this was not the case with the previous UI object API in Max). If you want to redraw something, you need to call jbox_redraw() to cause the screen to be redrawn. This is necessary because your object is part of a compositing user interface that must be managed by the patcher as a whole to avoid screen artifacts. The jbox_redraw() routine calculates the area of the screen that needs to be redrawn, then informs the Mac or Windows "window manager" to mark this area as invalid. At some later point in time, the OS will invoke the patcher's paint routine, which will dispatch to all of the boxes inside the invalid area according to the current Z-order of all the boxes. Boxes that are in the background are drawn first, so that any transparent or semi-transparent boxes can be drawn on top of them. In addition, unless you specify otherwise, the last drawn image of a box is cached in a buffer, so that your paint method will only be called when you explicitly invalidate your object's content with jbox_redraw(). In other words, you can't count on "global patcher drawing" to invoke your paint method.</span>
<a name="l00314"></a>00314 <span class="comment"></span>
<a name="l00315"></a>00315 <span class="comment">    The basic strategy you'll want to use in thinking about redrawing is that you will set internal state in other methods, then call jbox_redraw(). The paint method will read the internal state and adjust its drawing appropriately. You'll see this strategy used in the uisimp object as it tracks the mouse.</span>
<a name="l00316"></a>00316 <span class="comment"></span>
<a name="l00317"></a>00317 <span class="comment"></span>
<a name="l00318"></a>00318 <span class="comment">    @section chapter_ui_anatomy_paint The Paint Method</span>
<a name="l00319"></a>00319 <span class="comment"></span>
<a name="l00320"></a>00320 <span class="comment">    Your object's paint method uses the jgraphics API to draw. The header file, jgraphics.h, provides a description of each of the routines in the API. Here we will only discuss general principles and features of drawing with uisimp's relatively simple paint method. There is also a jgraphics example UI object that contains a number of functions showing how various drawing tasks can be performed.</span>
<a name="l00321"></a>00321 <span class="comment"></span>
<a name="l00322"></a>00322 <span class="comment">    Drawing in Max is resolution-independent. The "size" of your object's rectangle is always the pixel size when the patcher is scaled to 100% regardless of the zoom level, and any magnification or size reduction to the actual screen is automatically handled by matrix transforms. Another thing that is handled automatically for you is drawing to multiple views. If a patcher is invisible (i.e., a subpatcher that has not been double-clicked), it does not have any views. But if it is visible, a patcher can have many patcherviews. If your UI object box is in a patcher with multiple views open, your paint method will be called once for each view, and will be passed different a patcherview object each time. For most objects, this will pose few problems, but for objects to work properly when there are anywhere from zero to ten views open, they cannot change their internal state in the paint method, they can only read it. As an example, if your object had a boolean "painted" field in its structure that would be set when the paint method had finished, it would not work properly in the cases where the box was invisible or where it was shown in multiple patcher views, because it would either be set zero or more than once.</span>
<a name="l00323"></a>00323 <span class="comment"></span>
<a name="l00324"></a>00324 <span class="comment">    The first step for any paint method is to obtain the #t_jgraphics object from the patcherview object passed to the paint method. The patcherview is an opaque #t_object that you will use to access information about your box's rectangle and its graphics context. A patcherview is not the same thing as a patcher; as mentioned above, there could be more than one patcherview for a patcher if it has multiple views open. </span>
<a name="l00325"></a>00325 <span class="comment"></span>
<a name="l00326"></a>00326 <span class="comment">@code</span>
<a name="l00327"></a>00327 <span class="comment">    void uisimp_paint(t_uisimp *x, t_object *patcherview)</span>
<a name="l00328"></a>00328 <span class="comment">    {</span>
<a name="l00329"></a>00329 <span class="comment">        t_rect rect;</span>
<a name="l00330"></a>00330 <span class="comment"></span>
<a name="l00331"></a>00331 <span class="comment">        t_jgraphics *g = (t_jgraphics*) patcherview_get_jgraphics(patcherview);     // obtain graphics context</span>
<a name="l00332"></a>00332 <span class="comment">@endcode</span>
<a name="l00333"></a>00333 <span class="comment"></span>
<a name="l00334"></a>00334 <span class="comment">    After obtaining the #t_jgraphics object, the next thing that you'll need to do is determine the rectangle of your box. A view of a patcher may be in either patching or presentation mode. Since each mode can have its own rectangle, it is necessary to use the patcherview to obtain the rectangle for your object.</span>
<a name="l00335"></a>00335 <span class="comment"></span>
<a name="l00336"></a>00336 <span class="comment">@code</span>
<a name="l00337"></a>00337 <span class="comment">    jbox_get_rect_for_view((t_object *)x, patcherview, &amp;rect);</span>
<a name="l00338"></a>00338 <span class="comment">@endcode</span>
<a name="l00339"></a>00339 <span class="comment"></span>
<a name="l00340"></a>00340 <span class="comment">    The #t_rect structure specifies a rectangle using the x and y coordinates of the top left corner, along with the width and height. However, the coordinates of the #t_jgraphics you'll be using to draw into always begin at 0 for the top left corner, so you'll only care about the width and height, at least for drawing.</span>
<a name="l00341"></a>00341 <span class="comment"></span>
<a name="l00342"></a>00342 <span class="comment">    The first thing we'll draw is just an outline of our box using the value of the outline color attribute. First we'll set the color we want to use, then make a rectangular path, then finally we'll stroke the path we've made. </span>
<a name="l00343"></a>00343 <span class="comment"></span>
<a name="l00344"></a>00344 <span class="comment">    With calls such as jgraphics_rectangle(), the rectangular shape is added to the existing path. The initial path is empty, and after calling jgraphics_stroke() or jgraphics_fill(), the path is again cleared. (If you want to retain the path, you can use the jgraphics_stroke_preserve() and jgraphics_fill_preserve variants().)</span>
<a name="l00345"></a>00345 <span class="comment"></span>
<a name="l00346"></a>00346 <span class="comment">@code</span>
<a name="l00347"></a>00347 <span class="comment">    jgraphics_set_source_jrgba(g, &amp;x-&gt;u_outline);</span>
<a name="l00348"></a>00348 <span class="comment">    jgraphics_set_line_width(g, 1.);</span>
<a name="l00349"></a>00349 <span class="comment">    jgraphics_rectangle(g, 0., 0., rect.width, rect.height);</span>
<a name="l00350"></a>00350 <span class="comment">    jgraphics_stroke(g);</span>
<a name="l00351"></a>00351 <span class="comment">@endcode</span>
<a name="l00352"></a>00352 <span class="comment"></span>
<a name="l00353"></a>00353 <span class="comment">    You do not need to destroy the path before your paint method is finished. This will be done for you, but the fact that the path does not survive after the paint method is finished means you can't make a path and then store it without copying it first. Such a strategy is not recommended in any case, since your object's rectangle might change unpredictably from one paint method invocation to the next, which will likely cause your path to be the wrong shape or size.</span>
<a name="l00354"></a>00354 <span class="comment"></span>
<a name="l00355"></a>00355 <span class="comment">    The next feature of the paint method is to draw an inner outline if the mouse is moved over the box. Detecting the mouse's presence over the box happens in the mouseenter / mouseleave methods described below -- but essentially, we know that the mouse is over our object if the u_mouseover has been set by these mouse tracking methods.</span>
<a name="l00356"></a>00356 <span class="comment"></span>
<a name="l00357"></a>00357 <span class="comment">    To draw a rectangle that is inset by one pixel from the box rectangle, we use the rectangle starting at 1, 1 with a width of the box width - 2 and a height of the box height - 2.</span>
<a name="l00358"></a>00358 <span class="comment"></span>
<a name="l00359"></a>00359 <span class="comment">@code</span>
<a name="l00360"></a>00360 <span class="comment">    // paint "inner highlight" to indicate mouseover</span>
<a name="l00361"></a>00361 <span class="comment">    if (x-&gt;u_mouseover &amp;&amp; !x-&gt;u_mousedowninside) {</span>
<a name="l00362"></a>00362 <span class="comment">        jgraphics_set_source_jrgba(g, &amp;x-&gt;u_hilite);</span>
<a name="l00363"></a>00363 <span class="comment">        jgraphics_set_line_width(g, 1.);</span>
<a name="l00364"></a>00364 <span class="comment">        jgraphics_rectangle(g, 1., 1., rect.width - 2, rect.height - 2);</span>
<a name="l00365"></a>00365 <span class="comment">        jgraphics_stroke(g);</span>
<a name="l00366"></a>00366 <span class="comment">    }</span>
<a name="l00367"></a>00367 <span class="comment">@endcode</span>
<a name="l00368"></a>00368 <span class="comment"></span>
<a name="l00369"></a>00369 <span class="comment">    Some similar code provides the ability to show the highlight color when the user is about to check (turn on) the toggle:</span>
<a name="l00370"></a>00370 <span class="comment"></span>
<a name="l00371"></a>00371 <span class="comment">@code</span>
<a name="l00372"></a>00372 <span class="comment">    if (x-&gt;u_mousedowninside &amp;&amp; !x-&gt;u_state) {      // paint hilite color</span>
<a name="l00373"></a>00373 <span class="comment">        jgraphics_set_source_jrgba(g, &amp;x-&gt;u_hilite);</span>
<a name="l00374"></a>00374 <span class="comment">        jgraphics_rectangle(g, 1., 1., rect.width - 2, rect.height - 2);</span>
<a name="l00375"></a>00375 <span class="comment">        jgraphics_fill(g);</span>
<a name="l00376"></a>00376 <span class="comment">    }</span>
<a name="l00377"></a>00377 <span class="comment">@endcode</span>
<a name="l00378"></a>00378 <span class="comment"></span>
<a name="l00379"></a>00379 <span class="comment">    Finally, we paint a square in the middle of the object if the toggle state is non-zero to indicate that the box has been checked. Here we are filling a path instead of stroking it. Note also that we use the call jbox_get_color() to get the "standard" color of our object that is stored inside the #t_jbox. As we've specified by using the #JBOX_COLOR flag for jbox_initclass() in our initialization routine, the color obtained by jbox_get_color() for the "check" (really just a square of solid color) is the one the user can change with the Color... item in the Object menu.</span>
<a name="l00380"></a>00380 <span class="comment"></span>
<a name="l00381"></a>00381 <span class="comment">@code</span>
<a name="l00382"></a>00382 <span class="comment">    if (x-&gt;u_state) {</span>
<a name="l00383"></a>00383 <span class="comment">        t_jrgba col;</span>
<a name="l00384"></a>00384 <span class="comment"></span>
<a name="l00385"></a>00385 <span class="comment">        jbox_get_color((t_object *)x, &amp;col);</span>
<a name="l00386"></a>00386 <span class="comment">        jgraphics_set_source_jrgba(g, &amp;col);</span>
<a name="l00387"></a>00387 <span class="comment">        if (x-&gt;u_mousedowninside)       // make rect bigger if mouse is down and we are unchecking</span>
<a name="l00388"></a>00388 <span class="comment">            jgraphics_rectangle(g, 3., 3., rect.width - 6, rect.height - 6);</span>
<a name="l00389"></a>00389 <span class="comment">        else</span>
<a name="l00390"></a>00390 <span class="comment">            jgraphics_rectangle(g, 4., 4., rect.width - 8, rect.height - 8);</span>
<a name="l00391"></a>00391 <span class="comment">        jgraphics_fill(g);</span>
<a name="l00392"></a>00392 <span class="comment">    }</span>
<a name="l00393"></a>00393 <span class="comment">@endcode</span>
<a name="l00394"></a>00394 <span class="comment"></span>
<a name="l00395"></a>00395 <span class="comment">    Clearly, a quick perusal of the jgraphics.h header file will demonstrate that there is much more to drawing than we've discussed here. But the main purpose of the uisimp paint method is to show how to implement "dynamic" graphics that follow the mouse. Now we'll see the mouse tracking side of the story.</span>
<a name="l00396"></a>00396 <span class="comment"></span>
<a name="l00397"></a>00397 <span class="comment"></span>
<a name="l00398"></a>00398 <span class="comment"></span>
<a name="l00399"></a>00399 <span class="comment">    @section chapter_ui_anatomy_mouse Handling Mouse Gestures</span>
<a name="l00400"></a>00400 <span class="comment"></span>
<a name="l00401"></a>00401 <span class="comment">    When the mouse is clicked, dragged, released, or moved inside its box, your object will receive messages. In the uisimp example we've defined methods for most of the mouse gesture messages available, and we've implemented them to change internal state in the object, then call jbox_redraw() to repaint the object to reflect the new state. This strategy produces a "dynamic" appearance of a gadget users associate with a typical graphical interface -- in this case a toggle checkbox.</span>
<a name="l00402"></a>00402 <span class="comment"></span>
<a name="l00403"></a>00403 <span class="comment">    All mouse gesture methods are declared in the same way:</span>
<a name="l00404"></a>00404 <span class="comment"></span>
<a name="l00405"></a>00405 <span class="comment">@code</span>
<a name="l00406"></a>00406 <span class="comment">    void myobect_mouse(t_myobject *x, t_object *patcherview, t_pt pt, long modifiers);</span>
<a name="l00407"></a>00407 <span class="comment">@endcode</span>
<a name="l00408"></a>00408 <span class="comment"></span>
<a name="l00409"></a>00409 <span class="comment">    Let's first look at the most commonly implemented mouse gesture handler, the mousedown method that responds to an initial click on the object. As you can see, it is very simple; it merely sets u_mousedowninside to true, then calls jbox_redraw(), causing the box to be repainted. We've defined this toggle not to change the actual state until the mouse is released (unlike the standard Max toggle object), but we do want to give the user some feedback on the initial mouse down that something is going to happen. If you look back at the paint method, you can see that u_mousedowninside is used to change the way the object is painted to give it a "pending state change" appearance that will be finalized when the mouse is released inside the box.</span>
<a name="l00410"></a>00410 <span class="comment"></span>
<a name="l00411"></a>00411 <span class="comment">@code</span>
<a name="l00412"></a>00412 <span class="comment">    void uisimp_mousedown(t_uisimp *x, t_object *patcherview, t_pt pt, long modifiers)</span>
<a name="l00413"></a>00413 <span class="comment">    {</span>
<a name="l00414"></a>00414 <span class="comment">        x-&gt;u_mousedowninside = true;    // wouldn't get a click unless it was inside the box</span>
<a name="l00415"></a>00415 <span class="comment">        jbox_redraw((t_jbox *)x);</span>
<a name="l00416"></a>00416 <span class="comment">    }</span>
<a name="l00417"></a>00417 <span class="comment">@endcode</span>
<a name="l00418"></a>00418 <span class="comment"></span>
<a name="l00419"></a>00419 <span class="comment"></span>
<a name="l00420"></a>00420 <span class="comment">    If we test the mouse position to ensure that it is inside the box when it is released, we provide the opportunity for the user to cancel the act of toggling the state of the object by moving the cursor outside of the box before releasing the button. To provide feedback to the user that this is going to happen, we've implemented a mousedrag method that performs this test and redraws the object if the "mouse inside" condition has changed from its previous state. The mousedrag message will be sent to your object as long as the mouse button is still down after an initial click and the cursor has moved, even if the cursor moves outside of the boundaries of your object's box.</span>
<a name="l00421"></a>00421 <span class="comment"></span>
<a name="l00422"></a>00422 <span class="comment">    Note that, as with the paint method, we use the patcherview to get the current box rectangle. We can then test the point we are given (using jgraphics_ptinrect()) to see if it is inside or outside the box.</span>
<a name="l00423"></a>00423 <span class="comment"></span>
<a name="l00424"></a>00424 <span class="comment">@code</span>
<a name="l00425"></a>00425 <span class="comment">    void uisimp_mousedrag(t_uisimp *x, t_object *patcherview, t_pt pt, long modifiers)</span>
<a name="l00426"></a>00426 <span class="comment">    {</span>
<a name="l00427"></a>00427 <span class="comment">        t_rect rect;</span>
<a name="l00428"></a>00428 <span class="comment"></span>
<a name="l00429"></a>00429 <span class="comment">        jbox_get_rect_for_view((t_object *)x, patcherview, &amp;rect);</span>
<a name="l00430"></a>00430 <span class="comment"></span>
<a name="l00431"></a>00431 <span class="comment">        // test to see if mouse is still inside the object, redraw if changed</span>
<a name="l00432"></a>00432 <span class="comment"></span>
<a name="l00433"></a>00433 <span class="comment">        if (jgraphics_ptinrect(pt, rect)) {</span>
<a name="l00434"></a>00434 <span class="comment">            if (!x-&gt;u_mousedowninside) {</span>
<a name="l00435"></a>00435 <span class="comment">                x-&gt;u_mousedowninside = true;</span>
<a name="l00436"></a>00436 <span class="comment">                jbox_redraw((t_jbox *)x);</span>
<a name="l00437"></a>00437 <span class="comment">            }</span>
<a name="l00438"></a>00438 <span class="comment">        } else {</span>
<a name="l00439"></a>00439 <span class="comment">            if (x-&gt;u_mousedowninside) {</span>
<a name="l00440"></a>00440 <span class="comment">                x-&gt;u_mousedowninside = false;</span>
<a name="l00441"></a>00441 <span class="comment">                jbox_redraw((t_jbox *)x);</span>
<a name="l00442"></a>00442 <span class="comment">            }</span>
<a name="l00443"></a>00443 <span class="comment">        }</span>
<a name="l00444"></a>00444 <span class="comment">    }</span>
<a name="l00445"></a>00445 <span class="comment">@endcode</span>
<a name="l00446"></a>00446 <span class="comment">    </span>
<a name="l00447"></a>00447 <span class="comment"></span>
<a name="l00448"></a>00448 <span class="comment">    Our mouseup method uses the last value of u_mousedowninside as the determining factor for whether to toggle the object's internal state. If u_mousedowninside is false, no state change happens. But if it is true, the state changes and the new state value is sent out the object's outlet (inside uisimp_bang()).</span>
<a name="l00449"></a>00449 <span class="comment"></span>
<a name="l00450"></a>00450 <span class="comment">@code</span>
<a name="l00451"></a>00451 <span class="comment">    if (x-&gt;u_mousedowninside) {</span>
<a name="l00452"></a>00452 <span class="comment">        x-&gt;u_state = !x-&gt;u_state;</span>
<a name="l00453"></a>00453 <span class="comment">        uisimp_bang(x);</span>
<a name="l00454"></a>00454 <span class="comment">        x-&gt;u_mousedowninside = false;</span>
<a name="l00455"></a>00455 <span class="comment">        jbox_redraw((t_jbox *)x);</span>
<a name="l00456"></a>00456 <span class="comment">    }</span>
<a name="l00457"></a>00457 <span class="comment">@endcode</span>
<a name="l00458"></a>00458 <span class="comment"></span>
<a name="l00459"></a>00459 <span class="comment">    Finally, we've implemented mouseenter, mousemove, and mouseleave methods to provide another level of "mouse over" style highlighting for the object. Rather than changing u_mousedowninside, a u_mouseover field is set when the mouseenter message is received, and cleared when the mouseleave method is received. And again, after this variable is manipulated, we repaint the box with jbox_redraw().</span>
<a name="l00460"></a>00460 <span class="comment"></span>
<a name="l00461"></a>00461 <span class="comment">@code</span>
<a name="l00462"></a>00462 <span class="comment">    void uisimp_mouseenter(t_uisimp *x, t_object *patcherview, t_pt pt, long modifiers)</span>
<a name="l00463"></a>00463 <span class="comment">    {</span>
<a name="l00464"></a>00464 <span class="comment">        x-&gt;u_mouseover = true;</span>
<a name="l00465"></a>00465 <span class="comment">        jbox_redraw((t_jbox *)x);</span>
<a name="l00466"></a>00466 <span class="comment">    }</span>
<a name="l00467"></a>00467 <span class="comment"></span>
<a name="l00468"></a>00468 <span class="comment">    void uisimp_mouseleave(t_uisimp *x, t_object *patcherview, t_pt pt, long modifiers)</span>
<a name="l00469"></a>00469 <span class="comment">    {</span>
<a name="l00470"></a>00470 <span class="comment">        x-&gt;u_mouseover = false;</span>
<a name="l00471"></a>00471 <span class="comment">        jbox_redraw((t_jbox *)x);</span>
<a name="l00472"></a>00472 <span class="comment">    }</span>
<a name="l00473"></a>00473 <span class="comment">@endcode</span>
<a name="l00474"></a>00474 <span class="comment"></span>
<a name="l00475"></a>00475 <span class="comment"></span>
<a name="l00476"></a>00476 <span class="comment">    @section chapter_ui_anatomy_freeing Freeing a UI Object</span>
<a name="l00477"></a>00477 <span class="comment"></span>
<a name="l00478"></a>00478 <span class="comment">    If your object has created any clocks or otherwise allocated memory that should be freed when the object goes away, you should handle this in the free routine. But, most importantly, you must call the function jbox_free(). If your UI object doesn't need to do anything special in its free routine, you can pass jbox_free() as the free routine argument to class_new() in your initialization routine. We chose not to do this, since having an actual function permits easy modification should some memory need to be freed at some point in the future evolution of the object.</span>
<a name="l00479"></a>00479 <span class="comment"></span>
<a name="l00480"></a>00480 <span class="comment">@code</span>
<a name="l00481"></a>00481 <span class="comment">    void uisimp_free(t_uisimp *x)</span>
<a name="l00482"></a>00482 <span class="comment">    {</span>
<a name="l00483"></a>00483 <span class="comment">        jbox_free((t_jbox *)x);</span>
<a name="l00484"></a>00484 <span class="comment">    }</span>
<a name="l00485"></a>00485 <span class="comment">@endcode</span>
<a name="l00486"></a>00486 <span class="comment"></span>
<a name="l00487"></a>00487 <span class="comment"></span>
<a name="l00488"></a>00488 <span class="comment">*/</span>
</pre></div></div>
		<div id="c74footer">
			<p>Copyright &copy; 2008, <a href="http://www.cycling74.com/">Cycling '74</a></p>
		</div>
	</body>
</html>
