<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
		<title>Max5 API Reference</title>
		<link href="c74-doxygen.css" rel="stylesheet" type="text/css">
	</head>
	<body>

		<div id="c74header">
			<img src="max5.png" />
			<p>Max 5 API Reference</p>
		</div>

<!-- Generated by Doxygen 1.5.6 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<h1>api_06_scheduler.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/** </span>
<a name="l00002"></a>00002 <span class="comment">    @page chapter_scheduler The Scheduler</span>
<a name="l00003"></a>00003 <span class="comment"></span>
<a name="l00004"></a>00004 <span class="comment">    The Max scheduler permits operations to be delayed until a later time. It keeps track of time in double-precision, but the resolution of the scheduler depends on the user's environment preferences. The scheduler also works in conjunction with a low-priority queue, which permits time-consuming operations that might be initiated inside the scheduler to be executed in a way that does not disrupt timing accuracy.</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment">    Most objects interface with the scheduler via a clock (#t_clock) object. A clock is associated with a task function that will execute when the scheduler's current time reaches the clock's time. There is also a function called schedule() that can be used for one-off delayed execution of a function. It creates a clock to do its job however, so if your object is going to be using the scheduler repeatedly, it is more efficient to store references to the clocks it creates so the clocks can be reused.</span>
<a name="l00007"></a>00007 <span class="comment"></span>
<a name="l00008"></a>00008 <span class="comment">    The scheduler is periodically polled to see if it needs to execute clock tasks. There are numerous preferences Max users can set to determine when and how often this polling occurs. Briefly:</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">    - The Overdrive setting determines whether scheduler polling occurs in a high-prority timer thread or the main thread</span>
<a name="l00011"></a>00011 <span class="comment">    - The Interval setting determines the number of milliseconds elapse between polling the scheduler</span>
<a name="l00012"></a>00012 <span class="comment">    - The Throttle setting determines how many tasks can be executed in any particular scheduler poll</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment">    Similar Throttle and Interval settings exist for the low-priority queue as well.</span>
<a name="l00015"></a>00015 <span class="comment"></span>
<a name="l00016"></a>00016 <span class="comment">    For more information refer to the @ref sched documentation. While the details might be a little overwhelming on first glance, the important point is that the exact time your scheduled task will execute is subject to variability. Max permits this level of user control over the scheduler to balance all computational needs for a specific application.</span>
<a name="l00017"></a>00017 <span class="comment"></span>
<a name="l00018"></a>00018 <span class="comment"></span>
<a name="l00019"></a>00019 <span class="comment">    @section chapter_scheduler_clocks Creating and Using Clocks</span>
<a name="l00020"></a>00020 <span class="comment"></span>
<a name="l00021"></a>00021 <span class="comment">    There are five steps to using a clock in an external object. </span>
<a name="l00022"></a>00022 <span class="comment"></span>
<a name="l00023"></a>00023 <span class="comment">    1. Add a member to your object's data structure to hold a pointer to the clock object</span>
<a name="l00024"></a>00024 <span class="comment">@code</span>
<a name="l00025"></a>00025 <span class="comment">    typedef struct _myobject</span>
<a name="l00026"></a>00026 <span class="comment">    {</span>
<a name="l00027"></a>00027 <span class="comment">        t_object m_obj;</span>
<a name="l00028"></a>00028 <span class="comment">    </span>
<a name="l00029"></a>00029 <span class="comment">        void *m_clock;</span>
<a name="l00030"></a>00030 <span class="comment">    } t_object;</span>
<a name="l00031"></a>00031 <span class="comment">@endcode</span>
<a name="l00032"></a>00032 <span class="comment"></span>
<a name="l00033"></a>00033 <span class="comment">    2. Write a task function that will do something when the clock is executed. The function has only a single argument, a pointer to your object. The example below gets the current scheduler time and prints it.</span>
<a name="l00034"></a>00034 <span class="comment"></span>
<a name="l00035"></a>00035 <span class="comment">@code</span>
<a name="l00036"></a>00036 <span class="comment">    void myobject_task(t_myobject *x)</span>
<a name="l00037"></a>00037 <span class="comment">    {</span>
<a name="l00038"></a>00038 <span class="comment">        double time;</span>
<a name="l00039"></a>00039 <span class="comment"></span>
<a name="l00040"></a>00040 <span class="comment">        sched_getftime(&amp;time);</span>
<a name="l00041"></a>00041 <span class="comment">        post("instance %lx is executing at time %.2f", x, time);</span>
<a name="l00042"></a>00042 <span class="comment">    }</span>
<a name="l00043"></a>00043 <span class="comment">@endcode</span>
<a name="l00044"></a>00044 <span class="comment"></span>
<a name="l00045"></a>00045 <span class="comment">    3. In your new instance routine, create the clock (passing a pointer to your object and the task function) and store the result in your object's data structure.</span>
<a name="l00046"></a>00046 <span class="comment">@code</span>
<a name="l00047"></a>00047 <span class="comment">        x-&gt;m_clock = clock_new((t_object *)x, (method)myobject_task);</span>
<a name="l00048"></a>00048 <span class="comment">@endcode</span>
<a name="l00049"></a>00049 <span class="comment"></span>
<a name="l00050"></a>00050 <span class="comment">    4. Schedule your clock. Use clock_fdelay() to schedule the clock in terms of a delay from the current time. Below we schedule the clock to execute 100 milliseconds from now.</span>
<a name="l00051"></a>00051 <span class="comment">@code</span>
<a name="l00052"></a>00052 <span class="comment">        clock_fdelay(x-&gt;m_clock, 100.);</span>
<a name="l00053"></a>00053 <span class="comment">@endcode</span>
<a name="l00054"></a>00054 <span class="comment"></span>
<a name="l00055"></a>00055 <span class="comment">    If you want to cancel the execution of a clock for some reason, you can use clock_unset().</span>
<a name="l00056"></a>00056 <span class="comment">@code</span>
<a name="l00057"></a>00057 <span class="comment">        clock_unset(x-&gt;m_clock);</span>
<a name="l00058"></a>00058 <span class="comment">@endcode</span>
<a name="l00059"></a>00059 <span class="comment"></span>
<a name="l00060"></a>00060 <span class="comment">    5. In your object's free routine, free the clock</span>
<a name="l00061"></a>00061 <span class="comment">@code</span>
<a name="l00062"></a>00062 <span class="comment">        object_free(x-&gt;m_clock);</span>
<a name="l00063"></a>00063 <span class="comment">@endcode</span>
<a name="l00064"></a>00064 <span class="comment"></span>
<a name="l00065"></a>00065 <span class="comment">    Note that if you call clock_delay() on a clock that is already set, its execution time will be changed. It won't execute twice.</span>
<a name="l00066"></a>00066 <span class="comment"></span>
<a name="l00067"></a>00067 <span class="comment"></span>
<a name="l00068"></a>00068 <span class="comment">    @section chapter_scheduler_qelems Creating and Using Qelems</span>
<a name="l00069"></a>00069 <span class="comment"></span>
<a name="l00070"></a>00070 <span class="comment">    A qelem ("queue element") is used to ensure that an operation occurs in the low-priority thread. The task function associated with a #t_qelem is executed when the low-priority queue is serviced, always in the main (user interface) thread. Any qelem that is "set" belongs to the low-priority queue and will be executed as soon as it serviced. </span>
<a name="l00071"></a>00071 <span class="comment"></span>
<a name="l00072"></a>00072 <span class="comment">    There are two principal things you want to avoid in the high priority thread: first, time-consuming or unpredictable operations such as file access, and second, anything that will block execution for any length of time -- for example, showing a dialog box (including a file dialog).</span>
<a name="l00073"></a>00073 <span class="comment"></span>
<a name="l00074"></a>00074 <span class="comment">    The procedure for using a qelem is analogous to that for using a clock.</span>
<a name="l00075"></a>00075 <span class="comment"></span>
<a name="l00076"></a>00076 <span class="comment">    1. Add a member to your object's data structure to hold a pointer to the qelem</span>
<a name="l00077"></a>00077 <span class="comment">@code</span>
<a name="l00078"></a>00078 <span class="comment">    typedef struct _myobject</span>
<a name="l00079"></a>00079 <span class="comment">    {</span>
<a name="l00080"></a>00080 <span class="comment">        t_object m_obj;</span>
<a name="l00081"></a>00081 <span class="comment">    </span>
<a name="l00082"></a>00082 <span class="comment">        void *m_qelem</span>
<a name="l00083"></a>00083 <span class="comment">    } t_myobject;</span>
<a name="l00084"></a>00084 <span class="comment">@endcode</span>
<a name="l00085"></a>00085 <span class="comment"></span>
<a name="l00086"></a>00086 <span class="comment">    2. Write a task function that will do something when the qelem is executed. The function has only a single argument, a pointer to your object.</span>
<a name="l00087"></a>00087 <span class="comment">@code</span>
<a name="l00088"></a>00088 <span class="comment">    void myobject_qtask(t_myobject *x)</span>
<a name="l00089"></a>00089 <span class="comment">    {</span>
<a name="l00090"></a>00090 <span class="comment">        post("I am being executed a low priority!"</span>
<a name="l00091"></a>00091 <span class="comment">    }</span>
<a name="l00092"></a>00092 <span class="comment">@endcode</span>
<a name="l00093"></a>00093 <span class="comment"></span>
<a name="l00094"></a>00094 <span class="comment">    3. In your new instance routine, create the qelem (passing a pointer to your object and the task function) and store the result in your object's data structure.</span>
<a name="l00095"></a>00095 <span class="comment">@code</span>
<a name="l00096"></a>00096 <span class="comment">        x-&gt;m_qelem = qelem_new((t_object *)x, (method)myobject_qtask);</span>
<a name="l00097"></a>00097 <span class="comment">@endcode</span>
<a name="l00098"></a>00098 <span class="comment"></span>
<a name="l00099"></a>00099 <span class="comment">    4. Set the qelem by using qelem_set(). You could, for example, call qelem_set() in a clock task function or in direct response to a message such as bang or int.</span>
<a name="l00100"></a>00100 <span class="comment">@code</span>
<a name="l00101"></a>00101 <span class="comment">        qelem_set(x-&gt;m_qelem);</span>
<a name="l00102"></a>00102 <span class="comment">@endcode</span>
<a name="l00103"></a>00103 <span class="comment"></span>
<a name="l00104"></a>00104 <span class="comment">    If you want to cancel the execution of a qelem for some reason, you can use qelem_unset().</span>
<a name="l00105"></a>00105 <span class="comment">@code</span>
<a name="l00106"></a>00106 <span class="comment">        qelem_unset(x-&gt;m_qelem);</span>
<a name="l00107"></a>00107 <span class="comment">@endcode</span>
<a name="l00108"></a>00108 <span class="comment"></span>
<a name="l00109"></a>00109 <span class="comment">    5. In your object's free routine, call qelem_free(). Do not call object_free() or freeobject() -- unlike the clock, the qelem is not an object.</span>
<a name="l00110"></a>00110 <span class="comment">@code</span>
<a name="l00111"></a>00111 <span class="comment">        qelem_free(x-&gt;m_qelem);</span>
<a name="l00112"></a>00112 <span class="comment">@endcode</span>
<a name="l00113"></a>00113 <span class="comment"></span>
<a name="l00114"></a>00114 <span class="comment">    Note that if you call qelem_set() on a qelem that is already set, it won't execute twice. This is a feature, not a bug, as it permits you to execute a low-priority task only as fast as the low-priority queue operates, not at the high-priority rate that the task might be triggered. An example would be that a number box will redraw more slowly than a counter that changes its value. This is not something you need to worry about, even if you are writing UI objects, as Max handles it internally (using a qelem).</span>
<a name="l00115"></a>00115 <span class="comment"></span>
<a name="l00116"></a>00116 <span class="comment"></span>
<a name="l00117"></a>00117 <span class="comment">    @section chapter_scheduler_defer Defer</span>
<a name="l00118"></a>00118 <span class="comment"></span>
<a name="l00119"></a>00119 <span class="comment">    The defer function and its variants use a qelem to ensure that a function executes at low-priority. There are three variants: defer(), defer_low(), and defer_medium(). The difference between using defer() and a qelem is that defer() is a one-shot deal -- it creates a qelem, sets it, and then gets rid of it when the task function has executed. The effect of this is that if you have some rapid high-priority event that needs to trigger something to happen at low-priority, defer() will ensure that this low-priority task happens every time the high-priority event occurs (in a 1:1 ratio), whereas using a qelem will only run the task at a rate that corresponds to the service interval of the low-priority queue. If you repeatedly defer() something too rapidly, the low-priority queue will become backlogged and the responsiveness of the UI will suffer.</span>
<a name="l00120"></a>00120 <span class="comment"></span>
<a name="l00121"></a>00121 <span class="comment">    A typical use of defer() is if your object implements a read message to ask the user for a file. Opening the dialog in the timer thread and waiting for user input will likely crash, but even if it didn't, the scheduler would effectively stop.</span>
<a name="l00122"></a>00122 <span class="comment"></span>
<a name="l00123"></a>00123 <span class="comment">    To use defer(), you write a deferred task function that will execute at low priority. The function will be passed a pointer to your object, plus a symbol and atom list modeled on the prototype for an anything method. You need not pass any arguments to the deferred task if you don't need them, however.</span>
<a name="l00124"></a>00124 <span class="comment"></span>
<a name="l00125"></a>00125 <span class="comment">@code</span>
<a name="l00126"></a>00126 <span class="comment">    void myobject_deferredtask(t_myobject *x, t_symbol *s, long argc, t_atom *argv)</span>
<a name="l00127"></a>00127 <span class="comment">    {</span>
<a name="l00128"></a>00128 <span class="comment">        post("I am deferred");</span>
<a name="l00129"></a>00129 <span class="comment">    }</span>
<a name="l00130"></a>00130 <span class="comment">@endcode</span>
<a name="l00131"></a>00131 <span class="comment"></span>
<a name="l00132"></a>00132 <span class="comment">    To call the task, use defer() as shown below. The first example passes no arguments. The second passes a couple of long atoms.</span>
<a name="l00133"></a>00133 <span class="comment">@code</span>
<a name="l00134"></a>00134 <span class="comment">        defer((t_object *)x, (method)myobject_deferredtask, NULL, 0, NULL);</span>
<a name="l00135"></a>00135 <span class="comment"></span>
<a name="l00136"></a>00136 <span class="comment">        t_atom av[2];</span>
<a name="l00137"></a>00137 <span class="comment"></span>
<a name="l00138"></a>00138 <span class="comment">        atom_setlong(av, 1);</span>
<a name="l00139"></a>00139 <span class="comment">        atom_setlong(av+ 2, 74);</span>
<a name="l00140"></a>00140 <span class="comment"></span>
<a name="l00141"></a>00141 <span class="comment">        defer((t_object *)x, (method)myobject_deferredtask, NULL, 2, av);</span>
<a name="l00142"></a>00142 <span class="comment">@endcode</span>
<a name="l00143"></a>00143 <span class="comment"></span>
<a name="l00144"></a>00144 <span class="comment">    Defer copies any atoms you pass to newly allocated memory, which it frees when the deferred task has executed.</span>
<a name="l00145"></a>00145 <span class="comment"></span>
<a name="l00146"></a>00146 <span class="comment"></span>
<a name="l00147"></a>00147 <span class="comment">    @subsection chapter_scheduler_defer_variants Defer Variants</span>
<a name="l00148"></a>00148 <span class="comment"></span>
<a name="l00149"></a>00149 <span class="comment">    defer has two variants, defer_low() and defer_medium(). Here is a comparison:</span>
<a name="l00150"></a>00150 <span class="comment"></span>
<a name="l00151"></a>00151 <span class="comment">    defer()</span>
<a name="l00152"></a>00152 <span class="comment"></span>
<a name="l00153"></a>00153 <span class="comment">    If executing at high priority, defer() puts the deferred task at the front of the low-priority queue. If not executing at highpriority, defer() calls the deferred task immediately.</span>
<a name="l00154"></a>00154 <span class="comment"></span>
<a name="l00155"></a>00155 <span class="comment">    defer_low()</span>
<a name="l00156"></a>00156 <span class="comment"></span>
<a name="l00157"></a>00157 <span class="comment">    At all priority levels, defer_low() puts the deferred task at the back of the low-priority queue.</span>
<a name="l00158"></a>00158 <span class="comment"></span>
<a name="l00159"></a>00159 <span class="comment">    defer_medium()</span>
<a name="l00160"></a>00160 <span class="comment"></span>
<a name="l00161"></a>00161 <span class="comment">    If executing at high priority, defer_medium() puts the deferred task at the back of the low-priority queue. If not executing at high priority, defer_medium() calls the deferred task immediately.</span>
<a name="l00162"></a>00162 <span class="comment"></span>
<a name="l00163"></a>00163 <span class="comment"></span>
<a name="l00164"></a>00164 <span class="comment">    @section chapter_scheduler_sechedule Schedule</span>
<a name="l00165"></a>00165 <span class="comment"></span>
<a name="l00166"></a>00166 <span class="comment">    The schedule() function is to clocks as defer() is to qelems.  Schedule creates a clock for a task function you specify and calls clock_fdelay() on it to make the task execute at a desired time. As with defer(), schedule() can copy arguments to be delivered to the task when it executes.</span>
<a name="l00167"></a>00167 <span class="comment"></span>
<a name="l00168"></a>00168 <span class="comment">    A schedule() variant, schedule_defer(), executes the task function at low priority after a specified delay.</span>
<a name="l00169"></a>00169 <span class="comment"></span>
<a name="l00170"></a>00170 <span class="comment"></span>
<a name="l00171"></a>00171 <span class="comment">*/</span>
</pre></div></div>
		<div id="c74footer">
			<p>Copyright &copy; 2008, <a href="http://www.cycling74.com/">Cycling '74</a></p>
		</div>
	</body>
</html>
