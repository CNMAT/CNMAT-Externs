<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
		<title>Max5 API Reference</title>
		<link href="c74-doxygen.css" rel="stylesheet" type="text/css">
	</head>
	<body>

		<div id="c74header">
			<img src="max5.png" />
			<p>Max 5 API Reference</p>
		</div>

<!-- Generated by Doxygen 1.5.6 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="chapter_inout">Inlets and Outlets </a></h1>You are familiar with inlets and outlets when connecting two objects together in a patcher.<p>
To receive data in your object or send data to other objects, you need to create the C versions of inlets and outlets. In this section, we'll explain what inlets and outlets are, how to create them, and how to use them. We'll also discuss a more advanced type of inlet called a proxy that permits a message to be received in any of your object's inlets. Proxies are used by audio objects to permit inlets to handle both signals and normal Max messages.<p>
By default, every object shows one inlet. Additional inlets appear to the right of the default inlet, with the rightmost inlet being created last.<p>
Inlets are essentially message translators. For example, if you create an int inlet, your object will receive the "in1" message instead of the "int" message when a number arrives at this newly created inlet. You can use the different message name to define special behavior for numbers arriving at each inlet. For example, a basic arithmetic object in Max such as + stores the number to be added when it arrives in the right inlet, but performs the computation and outputs the result when a number arrives in the left inlet.<p>
Outlets define connections between objects and are used to send messages from your object to the objects to which it is connected. What is not obvious about an outlet, however, is that when you send a number out an outlet, the outlet-sending function does not return until all computation "below" the outlet has completed. This stack-based execution model is best illustrated by observing a patch with the Max debugger window. To understand this stack-based model it may be helpful to use the breakpoint and debugging features in Max and follow the stack display as you step through the execution of a patch. Outlets, like inlets, appear in the order you create them from right-to-left. In other words, the first inlet or outlet you create will be the visually farthest to the right.<h2><a class="anchor" name="chapter_inout_inlets">
Creating and Using Inlets</a></h2>
Proper use of an inlet involves two steps: first, add a method that will respond to the message sent via the inlet in your initialization routine, and second, create the inlet in your new instance routine. (Creating inlets at any other time is not supported.)<p>
There are three types of inlets: int, float, and custom. We'll only describe int and float inlets here because proxies are generally a better way to create an inlet that can respond to any message. For int inlets, you'll bind a function to a message "in1", "in2", "in3" etc. depending on the inlet number you assign. Here's how to create a single inlet using "in1"...<p>
In your initialization routine: <div class="fragment"><pre class="fragment">        <a class="code" href="group__class.html#g1fabf54e0cec8d4e5f732fa347b3f874" title="Adds a method to a previously defined object class.">class_addmethod</a>(c, (<a class="code" href="group__datatypes.html#gc26ba0a173b50597f5738132e059b42d" title="Function pointer type for generic methods.">method</a>)myobject_in1, <span class="stringliteral">"in1"</span>, <a class="code" href="group__atom.html#gg8aa6700e9f00b132eb376db6e39ade47002f28879581a6f66ea492b994b96f1e" title="long integer">A_LONG</a>, 0);
</pre></div><p>
In your new instance routine, after calling <a class="el" href="group__obj.html#gcb89ef27c34b45e9037d877375804284" title="Allocates the memory for an instance of an object class and initialize its object...">object_alloc()</a> to create your instance: <div class="fragment"><pre class="fragment">        <a class="code" href="group__inout.html#g8ca68c8eafef51622f263f13e047341b" title="Use intin() to create an inlet typed to receive only integers.">intin</a>(x, 1);
</pre></div><p>
The method that will be called when an int is received in the right inlet: <div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> myobject_in1(t_myobject *x, <span class="keywordtype">long</span> n)
    {
        <span class="comment">// do something with n</span>
    }
</pre></div><p>
Creating a single inlet in this way gives your object two inlets (remember that it always has one by default). If you want to create multiple inlets, you'll need to create them in order from right to left, as shown below: <div class="fragment"><pre class="fragment">        <a class="code" href="group__inout.html#g8ca68c8eafef51622f263f13e047341b" title="Use intin() to create an inlet typed to receive only integers.">intin</a>(x, 2);        <span class="comment">// creates an inlet (the right inlet) that will send your object the "in2" message</span>
        <a class="code" href="group__inout.html#g8ca68c8eafef51622f263f13e047341b" title="Use intin() to create an inlet typed to receive only integers.">intin</a>(x, 1);        <span class="comment">// creates an inlet (the middle inlet) that will send your object the "in1" message</span>
</pre></div><p>
Inlets that send float messages to your object are created with <a class="el" href="group__inout.html#g01125a22c75ef028199febbe21346f0e" title="Use floatin() to create an inlet typed to receive only floats.">floatin()</a> and translate the float message into "ft1","ft2","ft3" etc. Example:<p>
In initialization routine: <div class="fragment"><pre class="fragment">        <a class="code" href="group__class.html#g1fabf54e0cec8d4e5f732fa347b3f874" title="Adds a method to a previously defined object class.">class_addmethod</a>(c, (<a class="code" href="group__datatypes.html#gc26ba0a173b50597f5738132e059b42d" title="Function pointer type for generic methods.">method</a>)myobject_ft1, <span class="stringliteral">"ft1"</span>, <a class="code" href="group__atom.html#gg8aa6700e9f00b132eb376db6e39ade470b3aa0ab8104573dfc9cb70b5b08031f" title="32-bit float">A_FLOAT</a>, 0);
</pre></div><p>
In new instance routine: <div class="fragment"><pre class="fragment">        <a class="code" href="group__inout.html#g01125a22c75ef028199febbe21346f0e" title="Use floatin() to create an inlet typed to receive only floats.">floatin</a>(x, 1);
</pre></div><p>
Method: <div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> myobject_ft1(t_myobject *x, <span class="keywordtype">double</span> f)
    {
        <a class="code" href="group__console.html#g3714108f42b44384b4d58009eafc1806" title="Print text to the Max window.">post</a>(<span class="stringliteral">"float %.2f received in right inlet,f);</span>
<span class="stringliteral">    }</span>
</pre></div><p>
Note that you can mix int and float inlets, but each inlet must have a unique number. Example: <div class="fragment"><pre class="fragment">        <a class="code" href="group__inout.html#g8ca68c8eafef51622f263f13e047341b" title="Use intin() to create an inlet typed to receive only integers.">intin</a>(x, 2);
        <a class="code" href="group__inout.html#g01125a22c75ef028199febbe21346f0e" title="Use floatin() to create an inlet typed to receive only floats.">floatin</a>(x, 1);
</pre></div><h2><a class="anchor" name="chapter_inout_outlets">
Creating and Using Outlets</a></h2>
You create outlets in your new instance routine. Outlet creators return a pointer that you should store for later use when you want to send a message. As with inlets, outlets are created from right to left.<p>
Here's a simple example. First we'll add two void pointers to our data structure to store the outlets for each instance. <div class="fragment"><pre class="fragment">    <span class="keyword">typedef</span> <span class="keyword">struct </span>_myobject
    {
        <a class="code" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or...">t_object</a> m_ob;
        <span class="keywordtype">void</span> *m_outlet1;
        <span class="keywordtype">void</span> *m_outlet2;
    } t_myobject;
</pre></div><p>
Then we'll create the outlets in our new instance routine. <div class="fragment"><pre class="fragment">        x = (t_myobject *)<a class="code" href="group__obj.html#gcb89ef27c34b45e9037d877375804284" title="Allocates the memory for an instance of an object class and initialize its object...">object_alloc</a>(s_myobject_class);
        x-&gt;m_outlet2 = <a class="code" href="group__inout.html#g69d26d4f2684aab7dbc1b2d18248eae5" title="Use bangout() to create an outlet that will always send the bang message.">bangout</a>((<a class="code" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or...">t_object</a> *)x);
        x-&gt;m_outlet1 = <a class="code" href="group__inout.html#g9b8d897c728eeafa5638d4fc16ff704e" title="Use intout() to create an outlet that will always send the int message.">intout</a>((<a class="code" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or...">t_object</a> *)x);
        <span class="keywordflow">return</span> x;
</pre></div><p>
These outlets are type-specific, meaning that we will always send the same type of message through them. If you want to create outlets that can send any message, use <a class="el" href="group__inout.html#g451b3a1ec203ac8648a5399e209f070a" title="Use outlet_new() to create an outlet that can send a specific non-standard message...">outlet_new()</a>. Type-specific outlets execute faster, because they make a direct connection to the method handler that will be called at the time you send a message. When we want to send messages out these outlets, say, in our bang method, we do the following:<p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> myobject_bang(t_myobject *x)
    {
        <a class="code" href="group__inout.html#g357498d7143fd266facfbfc4efa59029" title="Use outlet_bang() to send a bang message out an outlet.">outlet_bang</a>(x-&gt;m_outlet2);
        <a class="code" href="group__inout.html#g0b2b38216f2f4dba486bfcd2273f255e" title="Use outlet_int() to send a float message out an outlet.">outlet_int</a>(x-&gt;m_outlet1, 74);
    }
</pre></div><p>
The bang method above sends the bang message out the m_outlet2 outlet first, then sends the number 74 out the m_outlet1. This is consistent with the general design in Max to send values out outlets from right to left. However, there is nothing enforcing this design, and you could reverse the statements if you felt like it.<p>
A more general message-sending routine, <a class="el" href="group__inout.html#g12798ee897e01dac21ee547c4091d8a8" title="Use outlet_anything() to send any message out an outlet.">outlet_anything()</a>, will be shown in the <a class="el" href="chapter_atoms.html">Atoms and Messages</a> section.<h2><a class="anchor" name="chapter_inout_proxies">
Creating and Using Proxies</a></h2>
A proxy is a small object that controls an inlet, but does not translate the message it receives. Instead it sets a location inside your object's data structure to a value you associate with the inlet. If the message comes "directly" to your object via the left inlet, the value will be 0. However, in order to be thread-safe, you should not read the value of this "inlet number" directly. Instead, you'll use the <a class="el" href="group__inout.html#ge81f89a78389587dc23d641e38b42481" title="Use proxy_getinlet to get the inlet number in which a message was received.">proxy_getinlet()</a> routine to determine the inlet that has received the message.<p>
The advantage of proxies over regular inlets is that your object can respond to any message in all of its inlets, not just the left inlet. As a Max user, you may already appreciate the proxy feature without knowing it. For example, the pack object can combine ints, floats, lists, or symbols arriving in any of its inlets. It uses proxies to make this happen. MSP audio objects that accept signals in more than one inlet use proxies as well. In fact, the proxy capability is built into the way you create audio objects, as will be discussed in the <a class="el" href="chapter_msp_anatomy.html">Anatomy of a MSP Object</a> section.<p>
If your object's non-left inlets will only respond to ints or floats, implementing proxies is usually overkill.<h2><a class="anchor" name="chapter_inout_example">
Example</a></h2>
First, add a place in your object to store the proxy value. You shouldn't access this directly, but the proxy needs it. Second, you'll need to store the proxy, because you need to free it when your object goes away. If you create many proxies, you'll need to store pointers to all of them, but all proxies share the same long integer value field.<p>
<div class="fragment"><pre class="fragment">    <span class="keyword">typedef</span> <span class="keyword">struct </span>_myobject
    {
        <a class="code" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or...">t_object</a> m_obj;
        <span class="keywordtype">long</span> m_in;          <span class="comment">// space for the inlet number used by all the proxies</span>
        <span class="keywordtype">void</span> *m_proxy;
    } t_myobject;
</pre></div><p>
In your new instance routine, create the proxy, passing your object, a non-zero code value associated with the proxy, and a pointer to your object's inlet number location.<p>
<div class="fragment"><pre class="fragment">        x-&gt;m_proxy = <a class="code" href="group__inout.html#g65676568dda565aba2dd13c9f88c9f91" title="Use proxy_new to create a new Proxy object.">proxy_new</a>((<a class="code" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or...">t_object</a> *)x, 1, &amp;x-&gt;m_in);
</pre></div><p>
If you want to create regular inlets for your object, you can do so. Proxies and regular inlets can be mixed, although such a design might confuse a user of your object.<p>
Finally, here is a method that takes a different action depending on the value of x-&gt;m_in that we check using <a class="el" href="group__inout.html#ge81f89a78389587dc23d641e38b42481" title="Use proxy_getinlet to get the inlet number in which a message was received.">proxy_getinlet()</a>.<p>
<div class="fragment"><pre class="fragment">     <span class="keywordtype">void</span> myobject_bang(t_myobject *x)
    {
        <span class="keywordflow">switch</span> (<a class="code" href="group__inout.html#ge81f89a78389587dc23d641e38b42481" title="Use proxy_getinlet to get the inlet number in which a message was received.">proxy_getinlet</a>((<a class="code" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or...">t_object</a> *)x)) {
            <span class="keywordflow">case</span> 0:
                <a class="code" href="group__console.html#g3714108f42b44384b4d58009eafc1806" title="Print text to the Max window.">post</a>(<span class="stringliteral">"bang received in left inlet"</span>);
                <span class="keywordflow">break</span>;
            <span class="keywordflow">case</span> 1:
                <a class="code" href="group__console.html#g3714108f42b44384b4d58009eafc1806" title="Print text to the Max window.">post</a>(<span class="stringliteral">"bang received in right inlet"</span>);
                <span class="keywordflow">break</span>;
        }
    }
</pre></div> </div>
		<div id="c74footer">
			<p>Copyright &copy; 2008, <a href="http://www.cycling74.com/">Cycling '74</a></p>
		</div>
	</body>
</html>
