<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Max 6 API</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
	<div id="c74header">
		<img src="header.png" height="200" />
	</div>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__memory.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Memory Management</div>  </div>
</div>
<div class="contents">

<p>In the past, Max has provided two separate APIs for memory management.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga6ae185a510cc76224680e6156b843055">MM_UNIFIED</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro being defined means that getbytes and sysmem APIs for memory management are unified.  <a href="#ga6ae185a510cc76224680e6156b843055"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#gaa513b95a076519ec168b62d85881f643">getbytes</a> (short size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate small amounts of non-relocatable memory.  <a href="#gaa513b95a076519ec168b62d85881f643"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#gaa1dc485c42515917ca377dbaf15b7dcd">freebytes</a> (void *b, short size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory allocated with <a class="el" href="group__memory.html#gaa513b95a076519ec168b62d85881f643" title="Allocate small amounts of non-relocatable memory.">getbytes()</a>.  <a href="#gaa1dc485c42515917ca377dbaf15b7dcd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga198147e2629edde67218d8a759e9d5a0">getbytes16</a> (short size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Use <a class="el" href="group__memory.html#ga198147e2629edde67218d8a759e9d5a0" title="Use getbytes16() to allocate small amounts of non-relocatable memory that is aligned on a 16-byte bou...">getbytes16()</a> to allocate small amounts of non-relocatable memory that is aligned on a 16-byte boundary for use with vector optimization.  <a href="#ga198147e2629edde67218d8a759e9d5a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#gafba42d2b23405e29469392394cf41555">freebytes16</a> (char *mem, short size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory allocated with <a class="el" href="group__memory.html#ga198147e2629edde67218d8a759e9d5a0" title="Use getbytes16() to allocate small amounts of non-relocatable memory that is aligned on a 16-byte bou...">getbytes16()</a>.  <a href="#gafba42d2b23405e29469392394cf41555"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga50135e5f9bb18030ff1d12e9976253ab">newhandle</a> (long size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate relocatable memory.  <a href="#ga50135e5f9bb18030ff1d12e9976253ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga6402eb4bbf3acd03d3e2f1133195bac3">growhandle</a> (void *h, long size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the size of a handle.  <a href="#ga6402eb4bbf3acd03d3e2f1133195bac3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#gae325435a83824eb6b42e0885b68b9110">disposhandle</a> (char **h)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the memory used by a handle you no longer need.  <a href="#gae325435a83824eb6b42e0885b68b9110"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__datatypes.html#ga70766a030fcd392d4574fa59b296a68e">t_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga276676be214edff9fe5c9d0681f39ae6">sysmem_newptr</a> (long size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory.  <a href="#ga276676be214edff9fe5c9d0681f39ae6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__datatypes.html#ga70766a030fcd392d4574fa59b296a68e">t_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga1c178a079247f715c6e34c828d375324">sysmem_newptrclear</a> (long size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory and set it to zero.  <a href="#ga1c178a079247f715c6e34c828d375324"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__datatypes.html#ga70766a030fcd392d4574fa59b296a68e">t_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#gacad6bca165c7b2849fc81d8449245755">sysmem_resizeptr</a> (void *ptr, long newsize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize an existing pointer.  <a href="#gacad6bca165c7b2849fc81d8449245755"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__datatypes.html#ga70766a030fcd392d4574fa59b296a68e">t_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#gaf458ca679d665984dbaa8125c88a417e">sysmem_resizeptrclear</a> (void *ptr, long newsize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize an existing pointer and clear it.  <a href="#gaf458ca679d665984dbaa8125c88a417e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga4f847713a1bd083030d60e8752d7c28d">sysmem_ptrsize</a> (void *ptr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the size of a pointer.  <a href="#ga4f847713a1bd083030d60e8752d7c28d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga200c82639e547869db1f3887d17102d3">sysmem_freeptr</a> (void *ptr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory allocated with <a class="el" href="group__memory.html#ga276676be214edff9fe5c9d0681f39ae6" title="Allocate memory.">sysmem_newptr()</a>.  <a href="#ga200c82639e547869db1f3887d17102d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga527cceb7178a110b73ca01fdc41702b4">sysmem_copyptr</a> (const void *src, void *dst, long bytes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy memory the contents of one pointer to another pointer.  <a href="#ga527cceb7178a110b73ca01fdc41702b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#gacdacfad4785c71dc8c4ce5d4d9714d54">sysmem_newhandle</a> (long size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a handle (a pointer to a pointer).  <a href="#gacdacfad4785c71dc8c4ce5d4d9714d54"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga56406e70880d954e3d51b87e606c1398">sysmem_newhandleclear</a> (unsigned long size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a handle (a pointer to a pointer) whose memory is set to zero.  <a href="#ga56406e70880d954e3d51b87e606c1398"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga420520dda6015ec33876b18b860083dd">sysmem_resizehandle</a> (<a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a> handle, long newsize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize an existing handle.  <a href="#ga420520dda6015ec33876b18b860083dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga84cf5e5a070edef2834faf3b7beed5fe">sysmem_handlesize</a> (<a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a> handle)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the size of a handle.  <a href="#ga84cf5e5a070edef2834faf3b7beed5fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga5815994f7d02b77c24f8c684df9acd83">sysmem_freehandle</a> (<a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a> handle)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory allocated with <a class="el" href="group__memory.html#gacdacfad4785c71dc8c4ce5d4d9714d54" title="Allocate a handle (a pointer to a pointer).">sysmem_newhandle()</a>.  <a href="#ga5815994f7d02b77c24f8c684df9acd83"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga545ea0e5d3d8f14bda62f8ac6b3e6d71">sysmem_lockhandle</a> (<a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a> handle, long lock)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the locked/unlocked state of a handle.  <a href="#ga545ea0e5d3d8f14bda62f8ac6b3e6d71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#gab59295d789b6a720b9ab981a39441cbc">sysmem_ptrandhand</a> (void *p, <a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a> h, long size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add memory to an existing handle and copy memory to the resized portion from a pointer.  <a href="#gab59295d789b6a720b9ab981a39441cbc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga52dd152965c42f6b1e14cfdf8b102a30">sysmem_ptrbeforehand</a> (void *p, <a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a> h, unsigned long size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add memory to an existing handle and copy memory to the resized portion from a pointer.  <a href="#ga52dd152965c42f6b1e14cfdf8b102a30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga2d07c8171a047d92e8bd95f8bb5b2a70">sysmem_nullterminatehandle</a> (<a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a> h)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a null terminator to a handle.  <a href="#ga2d07c8171a047d92e8bd95f8bb5b2a70"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>In the past, Max has provided two separate APIs for memory management. </p>
<p>One for allocating memory on the stack so that it was interrupt safe, including the <a class="el" href="group__memory.html#gaa513b95a076519ec168b62d85881f643" title="Allocate small amounts of non-relocatable memory.">getbytes()</a> and <a class="el" href="group__memory.html#gaa1dc485c42515917ca377dbaf15b7dcd" title="Free memory allocated with getbytes().">freebytes()</a> functions. The other, the "sysmem" API, were for allocating memory on the heap where larger amounts of memory were needed and the code could be guaranteed to operate at non-interrupt level.</p>
<p>Many things have changed in the environment of recent operating systems (MacOS X and Windows XP/Vista), the memory routines function differently, and the scheduler is no longer directly triggered by a hardware interrupt. In Max 5, the sysmem and getbytes API's have been unified, and thus may be used interchangeably.</p>
<p>The memory management unification can be switched on and off in the header files if needed, to compile code for older versions of Max for example, by changing the use of <a class="el" href="group__memory.html#ga6ae185a510cc76224680e6156b843055" title="This macro being defined means that getbytes and sysmem APIs for memory management are unified...">MM_UNIFIED</a> in the Max headers.</p>
<h2><a class="anchor" id="The"></a>
Sysmem API</h2>
<p>The Sysmem API provides a number of utilities for allocating and managing memory. It is relatively similar to some of the Macintosh Memory Manager API, and not too different from Standard C library memory functions. It is <em>not</em> safe to mix these routines with other memory routines (e.g. don’t use malloc() to allocate a pointer, and <a class="el" href="group__memory.html#ga200c82639e547869db1f3887d17102d3" title="Free memory allocated with sysmem_newptr().">sysmem_freeptr()</a> to free it). </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga6ae185a510cc76224680e6156b843055"></a><!-- doxytag: member="ext.h::MM_UNIFIED" ref="ga6ae185a510cc76224680e6156b843055" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MM_UNIFIED</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This macro being defined means that getbytes and sysmem APIs for memory management are unified. </p>
<p>This is correct for Max 5, but should be commented out when compiling for old max targets. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gae325435a83824eb6b42e0885b68b9110"></a><!-- doxytag: member="ext_proto.h::disposhandle" ref="gae325435a83824eb6b42e0885b68b9110" args="(char **h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void disposhandle </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free the memory used by a handle you no longer need. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>The handle to dispose. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__memory.html#ga5815994f7d02b77c24f8c684df9acd83" title="Free memory allocated with sysmem_newhandle().">sysmem_freehandle()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa1dc485c42515917ca377dbaf15b7dcd"></a><!-- doxytag: member="ext_proto.h::freebytes" ref="gaa1dc485c42515917ca377dbaf15b7dcd" args="(void *b, short size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freebytes </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free memory allocated with <a class="el" href="group__memory.html#gaa513b95a076519ec168b62d85881f643" title="Allocate small amounts of non-relocatable memory.">getbytes()</a>. </p>
<p>As of Max 5 it is unified with <a class="el" href="group__memory.html#ga276676be214edff9fe5c9d0681f39ae6" title="Allocate memory.">sysmem_newptr()</a>, which is the preferred method for allocating memory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>A pointer to the block of memory previously allocated that you want to free. </td></tr>
    <tr><td class="paramname">size</td><td>The size the block specified (as parameter b) in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafba42d2b23405e29469392394cf41555"></a><!-- doxytag: member="ext_proto.h::freebytes16" ref="gafba42d2b23405e29469392394cf41555" args="(char *mem, short size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freebytes16 </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free memory allocated with <a class="el" href="group__memory.html#ga198147e2629edde67218d8a759e9d5a0" title="Use getbytes16() to allocate small amounts of non-relocatable memory that is aligned on a 16-byte bou...">getbytes16()</a>. </p>
<p>As of Max 5 it is unified with <a class="el" href="group__memory.html#ga276676be214edff9fe5c9d0681f39ae6" title="Allocate memory.">sysmem_newptr()</a>, which is the preferred method for allocating memory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to the block of memory previously allocated that you want to free. </td></tr>
    <tr><td class="paramname">size</td><td>The size the block specified (as parameter b) in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Note that <a class="el" href="group__memory.html#gafba42d2b23405e29469392394cf41555" title="Free memory allocated with getbytes16().">freebytes16()</a> will cause memory corruption if you pass it memory that was allocated with <a class="el" href="group__memory.html#gaa513b95a076519ec168b62d85881f643" title="Allocate small amounts of non-relocatable memory.">getbytes()</a>. Use it only with memory allocated with <a class="el" href="group__memory.html#ga198147e2629edde67218d8a759e9d5a0" title="Use getbytes16() to allocate small amounts of non-relocatable memory that is aligned on a 16-byte bou...">getbytes16()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa513b95a076519ec168b62d85881f643"></a><!-- doxytag: member="ext_proto.h::getbytes" ref="gaa513b95a076519ec168b62d85881f643" args="(short size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* getbytes </td>
          <td>(</td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate small amounts of non-relocatable memory. </p>
<p>As of Max 5 it is unified with <a class="el" href="group__memory.html#ga276676be214edff9fe5c9d0681f39ae6" title="Allocate memory.">sysmem_newptr()</a>, which is the preferred method for allocating memory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size to allocate in bytes (up to 32767 bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the allocated memory. </dd></dl>

</div>
</div>
<a class="anchor" id="ga198147e2629edde67218d8a759e9d5a0"></a><!-- doxytag: member="ext_proto.h::getbytes16" ref="ga198147e2629edde67218d8a759e9d5a0" args="(short size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* getbytes16 </td>
          <td>(</td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use <a class="el" href="group__memory.html#ga198147e2629edde67218d8a759e9d5a0" title="Use getbytes16() to allocate small amounts of non-relocatable memory that is aligned on a 16-byte bou...">getbytes16()</a> to allocate small amounts of non-relocatable memory that is aligned on a 16-byte boundary for use with vector optimization. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size to allocate in bytes (up to 32767 bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the allocated memory.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><a class="el" href="group__memory.html#ga198147e2629edde67218d8a759e9d5a0" title="Use getbytes16() to allocate small amounts of non-relocatable memory that is aligned on a 16-byte bou...">getbytes16()</a> is identical to getbytes except that it returns memory that is aligned to a 16-byte boundary. This allows you to allocate storage for vector-optimized memory at interrupt level. Note that any memory allocated with <a class="el" href="group__memory.html#ga198147e2629edde67218d8a759e9d5a0" title="Use getbytes16() to allocate small amounts of non-relocatable memory that is aligned on a 16-byte bou...">getbytes16()</a> must be freed with <a class="el" href="group__memory.html#gafba42d2b23405e29469392394cf41555" title="Free memory allocated with getbytes16().">freebytes16()</a>, not <a class="el" href="group__memory.html#gaa1dc485c42515917ca377dbaf15b7dcd" title="Free memory allocated with getbytes().">freebytes()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6402eb4bbf3acd03d3e2f1133195bac3"></a><!-- doxytag: member="ext_proto.h::growhandle" ref="ga6402eb4bbf3acd03d3e2f1133195bac3" args="(void *h, long size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short growhandle </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the size of a handle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>The handle to resize. </td></tr>
    <tr><td class="paramname">size</td><td>The new size to allocate in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Ignored. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__memory.html#ga420520dda6015ec33876b18b860083dd" title="Resize an existing handle.">sysmem_resizehandle()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga50135e5f9bb18030ff1d12e9976253ab"></a><!-- doxytag: member="ext_proto.h::newhandle" ref="ga50135e5f9bb18030ff1d12e9976253ab" args="(long size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** newhandle </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate relocatable memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size to allocate in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The allocated handle. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__memory.html#gacdacfad4785c71dc8c4ce5d4d9714d54" title="Allocate a handle (a pointer to a pointer).">sysmem_newhandle()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga527cceb7178a110b73ca01fdc41702b4"></a><!-- doxytag: member="ext_sysmem.h::sysmem_copyptr" ref="ga527cceb7178a110b73ca01fdc41702b4" args="(const void *src, void *dst, long bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sysmem_copyptr </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy memory the contents of one pointer to another pointer. </p>
<p>This function is similar to BlockMove() or memcpy(). It copies the contents of the memory from the source to the destination pointer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>A pointer to the memory whose bytes will be copied. </td></tr>
    <tr><td class="paramname">dst</td><td>A pointer to the memory where the data will be copied. </td></tr>
    <tr><td class="paramname">bytes</td><td>The size in bytes of the data to be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5815994f7d02b77c24f8c684df9acd83"></a><!-- doxytag: member="ext_sysmem.h::sysmem_freehandle" ref="ga5815994f7d02b77c24f8c684df9acd83" args="(t_handle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sysmem_freehandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free memory allocated with <a class="el" href="group__memory.html#gacdacfad4785c71dc8c4ce5d4d9714d54" title="Allocate a handle (a pointer to a pointer).">sysmem_newhandle()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle whose memory will be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga200c82639e547869db1f3887d17102d3"></a><!-- doxytag: member="ext_sysmem.h::sysmem_freeptr" ref="ga200c82639e547869db1f3887d17102d3" args="(void *ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sysmem_freeptr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free memory allocated with <a class="el" href="group__memory.html#ga276676be214edff9fe5c9d0681f39ae6" title="Allocate memory.">sysmem_newptr()</a>. </p>
<p>This function is similar to DisposePtr or free. It frees the memory that had been allocated to the given pointer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The pointer whose memory will be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga84cf5e5a070edef2834faf3b7beed5fe"></a><!-- doxytag: member="ext_sysmem.h::sysmem_handlesize" ref="ga84cf5e5a070edef2834faf3b7beed5fe" args="(t_handle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long sysmem_handlesize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the size of a handle. </p>
<p>This function is similar to GetHandleSize().</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle whose size will be queried. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes allocated to the specified handle. </dd></dl>

</div>
</div>
<a class="anchor" id="ga545ea0e5d3d8f14bda62f8ac6b3e6d71"></a><!-- doxytag: member="ext_sysmem.h::sysmem_lockhandle" ref="ga545ea0e5d3d8f14bda62f8ac6b3e6d71" args="(t_handle handle, long lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long sysmem_lockhandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the locked/unlocked state of a handle. </p>
<p>This function is similar to HLock or HUnlock. It sets the lock state of a handle, using a zero or non-zero number.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle that will be locked. </td></tr>
    <tr><td class="paramname">lock</td><td>The new lock state of the handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The previous lock state. </dd></dl>

</div>
</div>
<a class="anchor" id="gacdacfad4785c71dc8c4ce5d4d9714d54"></a><!-- doxytag: member="ext_sysmem.h::sysmem_newhandle" ref="gacdacfad4785c71dc8c4ce5d4d9714d54" args="(long size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a> sysmem_newhandle </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a handle (a pointer to a pointer). </p>
<p>This function is similar to NewHandle(). It allocates a handle of a given number of bytes and returns a <a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad" title="Generic pointer-to-a-pointer type.">t_handle</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size of the handle in bytes that will be allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new <a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad" title="Generic pointer-to-a-pointer type.">t_handle</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga56406e70880d954e3d51b87e606c1398"></a><!-- doxytag: member="ext_sysmem.h::sysmem_newhandleclear" ref="ga56406e70880d954e3d51b87e606c1398" args="(unsigned long size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a> sysmem_newhandleclear </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a handle (a pointer to a pointer) whose memory is set to zero. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size of the handle in bytes that will be allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new <a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad" title="Generic pointer-to-a-pointer type.">t_handle</a>. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__memory.html#gacdacfad4785c71dc8c4ce5d4d9714d54" title="Allocate a handle (a pointer to a pointer).">sysmem_newhandle()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga276676be214edff9fe5c9d0681f39ae6"></a><!-- doxytag: member="ext_sysmem.h::sysmem_newptr" ref="ga276676be214edff9fe5c9d0681f39ae6" args="(long size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__datatypes.html#ga70766a030fcd392d4574fa59b296a68e">t_ptr</a> sysmem_newptr </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate memory. </p>
<p>This function is similar to NewPtr() or malloc(). It allocates a pointer of a given number of bytes and returns a pointer to the memory allocated.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The amount of memory to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the allocated memory, or NULL if the allocation fails. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1c178a079247f715c6e34c828d375324"></a><!-- doxytag: member="ext_sysmem.h::sysmem_newptrclear" ref="ga1c178a079247f715c6e34c828d375324" args="(long size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__datatypes.html#ga70766a030fcd392d4574fa59b296a68e">t_ptr</a> sysmem_newptrclear </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate memory and set it to zero. </p>
<p>This function is similar to NewPtrClear() or calloc(). It allocates a pointer of a given number of bytes, zeroing all memory, and returns a pointer to the memory allocated.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The amount of memory to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the allocated memory, or NULL if the allocation fails. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2d07c8171a047d92e8bd95f8bb5b2a70"></a><!-- doxytag: member="ext_sysmem.h::sysmem_nullterminatehandle" ref="ga2d07c8171a047d92e8bd95f8bb5b2a70" args="(t_handle h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long sysmem_nullterminatehandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a null terminator to a handle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>A handle to null terminate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An error code. </dd></dl>

</div>
</div>
<a class="anchor" id="gab59295d789b6a720b9ab981a39441cbc"></a><!-- doxytag: member="ext_sysmem.h::sysmem_ptrandhand" ref="gab59295d789b6a720b9ab981a39441cbc" args="(void *p, t_handle h, long size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long sysmem_ptrandhand </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a>&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add memory to an existing handle and copy memory to the resized portion from a pointer. </p>
<p>This function is similar to PtrAndHand(). It resizes an existing handle by adding a given number of bytes to it and copies data from a pointer into those bytes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The existing pointer whose data will be copied into the resized handle. </td></tr>
    <tr><td class="paramname">h</td><td>The handle which will be enlarged by the size of the pointer. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes that will be added to the handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes allocated to the specified handle. </dd></dl>

</div>
</div>
<a class="anchor" id="ga52dd152965c42f6b1e14cfdf8b102a30"></a><!-- doxytag: member="ext_sysmem.h::sysmem_ptrbeforehand" ref="ga52dd152965c42f6b1e14cfdf8b102a30" args="(void *p, t_handle h, unsigned long size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long sysmem_ptrbeforehand </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a>&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add memory to an existing handle and copy memory to the resized portion from a pointer. </p>
<p>Unlike <a class="el" href="group__memory.html#gab59295d789b6a720b9ab981a39441cbc" title="Add memory to an existing handle and copy memory to the resized portion from a pointer.">sysmem_ptrandhand()</a>, however, this copies the ptr before the previously exising handle data.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The existing pointer whose data will be copied into the resized handle. </td></tr>
    <tr><td class="paramname">h</td><td>The handle which will be enlarged by the size of the pointer. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes that will be added to the handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4f847713a1bd083030d60e8752d7c28d"></a><!-- doxytag: member="ext_sysmem.h::sysmem_ptrsize" ref="ga4f847713a1bd083030d60e8752d7c28d" args="(void *ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long sysmem_ptrsize </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the size of a pointer. </p>
<p>This function is similar to _msize().</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The pointer whose size will be queried </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes allocated to the pointer specified. </dd></dl>

</div>
</div>
<a class="anchor" id="ga420520dda6015ec33876b18b860083dd"></a><!-- doxytag: member="ext_sysmem.h::sysmem_resizehandle" ref="ga420520dda6015ec33876b18b860083dd" args="(t_handle handle, long newsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long sysmem_resizehandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>newsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resize an existing handle. </p>
<p>This function is similar to SetHandleSize(). It resizes an existing handle to the size specified.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle that will be resized. </td></tr>
    <tr><td class="paramname">newsize</td><td>The new size of the handle in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes allocated to the specified handle. </dd></dl>

</div>
</div>
<a class="anchor" id="gacad6bca165c7b2849fc81d8449245755"></a><!-- doxytag: member="ext_sysmem.h::sysmem_resizeptr" ref="gacad6bca165c7b2849fc81d8449245755" args="(void *ptr, long newsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__datatypes.html#ga70766a030fcd392d4574fa59b296a68e">t_ptr</a> sysmem_resizeptr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>newsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resize an existing pointer. </p>
<p>This function is similar to realloc(). It resizes an existing pointer and returns a new pointer to the resized memory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The pointer to the memory that will be resized. </td></tr>
    <tr><td class="paramname">newsize</td><td>The new size of the pointer in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the resized memory, or NULL if the allocation fails. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf458ca679d665984dbaa8125c88a417e"></a><!-- doxytag: member="ext_sysmem.h::sysmem_resizeptrclear" ref="gaf458ca679d665984dbaa8125c88a417e" args="(void *ptr, long newsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__datatypes.html#ga70766a030fcd392d4574fa59b296a68e">t_ptr</a> sysmem_resizeptrclear </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>newsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resize an existing pointer and clear it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The pointer to the memory that will be resized. </td></tr>
    <tr><td class="paramname">newsize</td><td>The new size of the pointer in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the resized memory, or NULL if the allocation fails. </dd></dl>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

		<div id="c74footer">
			&nbsp;&nbsp;Copyright &copy; 2011, <a href="http://www.cycling74.com/">Cycling '74</a>
		</div>
	</body>
</html>
