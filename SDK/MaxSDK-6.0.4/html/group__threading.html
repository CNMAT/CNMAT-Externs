<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Max 6 API</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
	<div id="c74header">
		<img src="header.png" height="200" />
	</div>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__threading.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Threads</div>  </div>
</div>
<div class="contents">

<p>In Max, there are several threads of execution.  
<a href="#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for Threads:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<center><table><tr><td><img src="group__threading.png" border="0" alt="" usemap="#group____threading"/>
<map name="group____threading" id="group____threading">
<area shape="rect" id="node2" href="group__critical.html" title="A critical region is a simple mechanism that prevents multiple threads from accessing at once code pr..." alt="" coords="128,5,250,35"/><area shape="rect" id="node3" href="group__mutex.html" title="Mutexes" alt="" coords="151,59,227,90"/></map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="groups"></a>
Modules</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__critical.html">Critical Regions</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>A critical region is a simple mechanism that prevents multiple threads from accessing at once code protected by the same critical region. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html">Mutexes</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#gafca49284437802927af64f9133765571">ATOMIC_INCREMENT</a>(atomicptr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this routine for incrementing a global counter using a threadsafe and multiprocessor safe method.  <a href="#gafca49284437802927af64f9133765571"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#gabd7677871ef0b04a3ca6e65aedd64dee">ATOMIC_DECREMENT</a>(atomicptr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this routine for decrementing a global counter using a threadsafe and multiprocessor safe method.  <a href="#gabd7677871ef0b04a3ca6e65aedd64dee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#gab00bb40d899c20d6452575230cfed09b">ATOMIC_COMPARE_SWAP32</a>(oldvalue, newvalue, atomicptr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">atomic compare exchange does this:  <a href="#gab00bb40d899c20d6452575230cfed09b"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3f508e817912b65c30d97339cf7a6e62"></a><!-- doxytag: member="threading::t_thread" ref="ga3f508e817912b65c30d97339cf7a6e62" args="" -->
typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#ga3f508e817912b65c30d97339cf7a6e62">t_thread</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A Max thread. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaf0068b8e9ac28430873484727029315"></a><!-- doxytag: member="threading::t_systhread" ref="gaaf0068b8e9ac28430873484727029315" args="" -->
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#gaaf0068b8e9ac28430873484727029315">t_systhread</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque thread instance pointer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga503de6f3f546ef1dd2bed57a13d9812c"></a><!-- doxytag: member="threading::t_systhread_mutex" ref="ga503de6f3f546ef1dd2bed57a13d9812c" args="" -->
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#ga503de6f3f546ef1dd2bed57a13d9812c">t_systhread_mutex</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque mutex handle. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga56cc95a6cbd27fada3a74b85a7bc3155"></a><!-- doxytag: member="threading::t_systhread_cond" ref="ga56cc95a6cbd27fada3a74b85a7bc3155" args="" -->
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#ga56cc95a6cbd27fada3a74b85a7bc3155">t_systhread_cond</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque cond handle. <br/></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#gaa95d9c538a1b25404d19106739db9802">e_max_systhread_mutex_flags</a> { <a class="el" href="group__threading.html#ggaa95d9c538a1b25404d19106739db9802ae34f8741b28ee92a4d702bee8671bb32">SYSTHREAD_MUTEX_NORMAL</a>, 
<a class="el" href="group__threading.html#ggaa95d9c538a1b25404d19106739db9802abb3854e7bf495808b4251d1319cdfa45">SYSTHREAD_MUTEX_ERRORCHECK</a>, 
<a class="el" href="group__threading.html#ggaa95d9c538a1b25404d19106739db9802a4fa486d028b3153aac389ed24e63dddb">SYSTHREAD_MUTEX_RECURSIVE</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__mutex.html#gaa8cae78764c59883566ac4f861dd534e" title="Create a new mutex, which can be used to place thread locks around critical code.">systhread_mutex_new()</a> flags  <a href="group__threading.html#gaa95d9c538a1b25404d19106739db9802">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#ga1eb8ec7623f0806dd079d7be708c19a8">schedule</a> (void *ob, <a class="el" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d">method</a> fun, long when, <a class="el" href="structt__symbol.html">t_symbol</a> *sym, short argc, Atom *argv)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cause a function to be executed at the timer level at some time in the future.  <a href="#ga1eb8ec7623f0806dd079d7be708c19a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#gaa9b66fe2fc601f110bd962a622f1d5a0">schedule_delay</a> (void *ob, <a class="el" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d">method</a> fun, long delay, <a class="el" href="structt__symbol.html">t_symbol</a> *sym, short argc, <a class="el" href="structt__atom.html">t_atom</a> *argv)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cause a function to be executed at the timer level at some time in the future specified by a delay offset.  <a href="#gaa9b66fe2fc601f110bd962a622f1d5a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#gad60dbceb5e50471a3ec76f608a9ea35c">isr</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether your code is executing in the Max scheduler thread.  <a href="#gad60dbceb5e50471a3ec76f608a9ea35c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#gaa24a0c9896f1ad241e45590065c3f643">defer</a> (void *ob, <a class="el" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d">method</a> fn, <a class="el" href="structt__symbol.html">t_symbol</a> *sym, short argc, <a class="el" href="structt__atom.html">t_atom</a> *argv)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Defer execution of a function to the main thread if (and only if) your function is executing in the scheduler thread.  <a href="#gaa24a0c9896f1ad241e45590065c3f643"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#ga486daa40ddb16f70b663615695d18315">defer_low</a> (void *ob, <a class="el" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d">method</a> fn, <a class="el" href="structt__symbol.html">t_symbol</a> *sym, short argc, <a class="el" href="structt__atom.html">t_atom</a> *argv)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Defer execution of a function to the back of the queue on the main thread.  <a href="#ga486daa40ddb16f70b663615695d18315"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#ga7217fa33811a5ed35b970f504b4e4a79">systhread_create</a> (<a class="el" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d">method</a> entryproc, void *arg, long stacksize, long priority, long flags, <a class="el" href="group__threading.html#gaaf0068b8e9ac28430873484727029315">t_systhread</a> *thread)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new thread.  <a href="#ga7217fa33811a5ed35b970f504b4e4a79"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#gaacc57aeddc69c01e7562397bdf6f12f5">systhread_terminate</a> (<a class="el" href="group__threading.html#gaaf0068b8e9ac28430873484727029315">t_systhread</a> thread)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Forcefully kill a thread -- not recommended.  <a href="#gaacc57aeddc69c01e7562397bdf6f12f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#gad1ca1694ee14824a56916d8f67d7966b">systhread_sleep</a> (long milliseconds)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend the execution of the calling thread.  <a href="#gad1ca1694ee14824a56916d8f67d7966b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#gad448ff5be27ef8233162a0e24751786f">systhread_exit</a> (long status)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit the calling thread.  <a href="#gad448ff5be27ef8233162a0e24751786f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#gaac24a9db0d7af2343501a4e762d2ce85">systhread_join</a> (<a class="el" href="group__threading.html#gaaf0068b8e9ac28430873484727029315">t_systhread</a> thread, unsigned int *retval)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for thread to quit and get return value from <a class="el" href="group__threading.html#gad448ff5be27ef8233162a0e24751786f" title="Exit the calling thread.">systhread_exit()</a>.  <a href="#gaac24a9db0d7af2343501a4e762d2ce85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__threading.html#gaaf0068b8e9ac28430873484727029315">t_systhread</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#gab76eb3e1668b13483533c4929be5c914">systhread_self</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the thread instance pointer for the calling thread.  <a href="#gab76eb3e1668b13483533c4929be5c914"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#ga4e4b35c628d791550e5523c4b554d466">systhread_setpriority</a> (<a class="el" href="group__threading.html#gaaf0068b8e9ac28430873484727029315">t_systhread</a> thread, int priority)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the thread priority for the given thread.  <a href="#ga4e4b35c628d791550e5523c4b554d466"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#gaf073584f030cffc3a823601173803a95">systhread_getpriority</a> (<a class="el" href="group__threading.html#gaaf0068b8e9ac28430873484727029315">t_systhread</a> thread)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the thread priority for the given thread.  <a href="#gaf073584f030cffc3a823601173803a95"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#ga7ed1192e20bccddec517591b4a5f0f91">systhread_ismainthread</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if the function currently being executed is in the main thread.  <a href="#ga7ed1192e20bccddec517591b4a5f0f91"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#ga9bc306a6b164f705e55d1612c5ccfb78">systhread_istimerthread</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if the function currently being executed is in the scheduler thread.  <a href="#ga9bc306a6b164f705e55d1612c5ccfb78"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>In Max, there are several threads of execution. </p>
<p>The details of these threads are highlighted in the article "Event Priority in Max (Scheduler vs. Queue)" located online at <a href="http://www.cycling74.com/story/2005/5/2/133649/9742.">http://www.cycling74.com/story/2005/5/2/133649/9742.</a></p>
<p>Not all of the details of Max's threading model are expounded here. Most important to understand is that we typically deal the scheduler (which when overdrive is on runs in a separate and high priority thread) and the low priority queue (which always runs in the main application thread).</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.cycling74.com/twiki/bin/view/ProductDocumentation/JitterSdkSchedQueue">http://www.cycling74.com/twiki/bin/view/ProductDocumentation/JitterSdkSchedQueue</a> </dd>
<dd>
<a href="http://www.cycling74.com/story/2005/5/2/133649/9742">http://www.cycling74.com/story/2005/5/2/133649/9742</a> </dd></dl>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="gab00bb40d899c20d6452575230cfed09b"></a><!-- doxytag: member="ext_atomic.h::ATOMIC_COMPARE_SWAP32" ref="gab00bb40d899c20d6452575230cfed09b" args="(oldvalue, newvalue, atomicptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ATOMIC_COMPARE_SWAP32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">oldvalue, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">newvalue, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">atomicptr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>atomic compare exchange does this: </p>
<ul>
<li>if (*atomicptr == oldvalue) *atomicptr = newvalue;</li>
<li>all of above done atomically</li>
<li>return value is boolean: true if exchange was done</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">atomicptr</td><td>pointer to the atomic value </td></tr>
    <tr><td class="paramname">newvalue</td><td>value that will be assigned to *atomicptr if test succeeds </td></tr>
    <tr><td class="paramname">oldvalue</td><td>newvalue is only stored if original value equals oldvalue </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabd7677871ef0b04a3ca6e65aedd64dee"></a><!-- doxytag: member="ext_atomic.h::ATOMIC_DECREMENT" ref="gabd7677871ef0b04a3ca6e65aedd64dee" args="(atomicptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ATOMIC_DECREMENT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">atomicptr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use this routine for decrementing a global counter using a threadsafe and multiprocessor safe method. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">atomicptr</td><td>pointer to the (int) counter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafca49284437802927af64f9133765571"></a><!-- doxytag: member="ext_atomic.h::ATOMIC_INCREMENT" ref="gafca49284437802927af64f9133765571" args="(atomicptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ATOMIC_INCREMENT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">atomicptr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use this routine for incrementing a global counter using a threadsafe and multiprocessor safe method. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">atomicptr</td><td>pointer to the (int) counter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="gaa95d9c538a1b25404d19106739db9802"></a><!-- doxytag: member="ext_systhread.h::e_max_systhread_mutex_flags" ref="gaa95d9c538a1b25404d19106739db9802" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__threading.html#gaa95d9c538a1b25404d19106739db9802">e_max_systhread_mutex_flags</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="group__mutex.html#gaa8cae78764c59883566ac4f861dd534e" title="Create a new mutex, which can be used to place thread locks around critical code.">systhread_mutex_new()</a> flags </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggaa95d9c538a1b25404d19106739db9802ae34f8741b28ee92a4d702bee8671bb32"></a><!-- doxytag: member="SYSTHREAD_MUTEX_NORMAL" ref="ggaa95d9c538a1b25404d19106739db9802ae34f8741b28ee92a4d702bee8671bb32" args="" -->SYSTHREAD_MUTEX_NORMAL</em>&nbsp;</td><td>
<p>Normal. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa95d9c538a1b25404d19106739db9802abb3854e7bf495808b4251d1319cdfa45"></a><!-- doxytag: member="SYSTHREAD_MUTEX_ERRORCHECK" ref="ggaa95d9c538a1b25404d19106739db9802abb3854e7bf495808b4251d1319cdfa45" args="" -->SYSTHREAD_MUTEX_ERRORCHECK</em>&nbsp;</td><td>
<p>Error-checking. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa95d9c538a1b25404d19106739db9802a4fa486d028b3153aac389ed24e63dddb"></a><!-- doxytag: member="SYSTHREAD_MUTEX_RECURSIVE" ref="ggaa95d9c538a1b25404d19106739db9802a4fa486d028b3153aac389ed24e63dddb" args="" -->SYSTHREAD_MUTEX_RECURSIVE</em>&nbsp;</td><td>
<p>Recursive. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaa24a0c9896f1ad241e45590065c3f643"></a><!-- doxytag: member="ext_proto.h::defer" ref="gaa24a0c9896f1ad241e45590065c3f643" args="(void *ob, method fn, t_symbol *sym, short argc, t_atom *argv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* defer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d">method</a>&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__symbol.html">t_symbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__atom.html">t_atom</a> *&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Defer execution of a function to the main thread if (and only if) your function is executing in the scheduler thread. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ob</td><td>First argument passed to the function fun when it executes. </td></tr>
    <tr><td class="paramname">fn</td><td>Function to be called, see below for how it should be declared. </td></tr>
    <tr><td class="paramname">sym</td><td>Second argument passed to the function fun when it executes. </td></tr>
    <tr><td class="paramname">argc</td><td>Count of arguments in argv. argc is also the third argument passed to the function fun when it executes. </td></tr>
    <tr><td class="paramname">argv</td><td>Array containing a variable number of <a class="el" href="structt__atom.html" title="An atom is a typed datum.">t_atom</a> function arguments. If this argument is non-zero, defer allocates memory to make a copy of the arguments (according to the size passed in argc) and passes the copied array to the function fun when it executes as the fourth argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Return values is for internal Cycling '74 use only.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This function uses the <a class="el" href="group__threading.html#gad60dbceb5e50471a3ec76f608a9ea35c" title="Determine whether your code is executing in the Max scheduler thread.">isr()</a> routine to determine whether you're at the Max timer interrupt level (in the scheduler thread). If so, <a class="el" href="group__threading.html#gaa24a0c9896f1ad241e45590065c3f643" title="Defer execution of a function to the main thread if (and only if) your function is executing in the s...">defer()</a> creates a Qelem (see <a class="el" href="group__qelems.html">Qelems</a>), calls <a class="el" href="group__qelems.html#gab5fa3e43e7851d1a2049ee28f5275955" title="Cause a Qelem to execute with a higher priority.">qelem_front()</a>, and its queue function calls the function fn you passed with the specified arguments. If you're not in the scheduler thread, the function is executed immediately with the arguments. Note that this implies that <a class="el" href="group__threading.html#gaa24a0c9896f1ad241e45590065c3f643" title="Defer execution of a function to the main thread if (and only if) your function is executing in the s...">defer()</a> is not appropriate for using in situations such as Device or File manager I/0 completion routines. The <a class="el" href="group__threading.html#ga486daa40ddb16f70b663615695d18315" title="Defer execution of a function to the back of the queue on the main thread.">defer_low()</a> function is appropriate however, because it always defers.</dd></dl>
<p>The deferred function should be declared as follows: </p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> myobject_do (myObject *client, <a class="code" href="structt__symbol.html" title="The symbol.">t_symbol</a> *s, <span class="keywordtype">short</span> argc, <a class="code" href="structt__atom.html" title="An atom is a typed datum.">t_atom</a> *argv);
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__threading.html#ga486daa40ddb16f70b663615695d18315" title="Defer execution of a function to the back of the queue on the main thread.">defer_low()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga486daa40ddb16f70b663615695d18315"></a><!-- doxytag: member="ext_proto.h::defer_low" ref="ga486daa40ddb16f70b663615695d18315" args="(void *ob, method fn, t_symbol *sym, short argc, t_atom *argv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* defer_low </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d">method</a>&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__symbol.html">t_symbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__atom.html">t_atom</a> *&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Defer execution of a function to the back of the queue on the main thread. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ob</td><td>First argument passed to the function fun when it executes. </td></tr>
    <tr><td class="paramname">fn</td><td>Function to be called, see below for how it should be declared. </td></tr>
    <tr><td class="paramname">sym</td><td>Second argument passed to the function fun when it executes. </td></tr>
    <tr><td class="paramname">argc</td><td>Count of arguments in argv. argc is also the third argument passed to the function fun when it executes. </td></tr>
    <tr><td class="paramname">argv</td><td>Array containing a variable number of <a class="el" href="structt__atom.html" title="An atom is a typed datum.">t_atom</a> function arguments. If this argument is non-zero, defer allocates memory to make a copy of the arguments (according to the size passed in argc) and passes the copied array to the function fun when it executes as the fourth argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Return values is for internal Cycling '74 use only.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><a class="el" href="group__threading.html#ga486daa40ddb16f70b663615695d18315" title="Defer execution of a function to the back of the queue on the main thread.">defer_low()</a> always defers a call to the function fun whether you are already in the main thread or not, and uses <a class="el" href="group__qelems.html#ga3e292aad133af89a87e167e88cc4a1b5" title="Cause a Qelem to execute.">qelem_set()</a>, not <a class="el" href="group__qelems.html#gab5fa3e43e7851d1a2049ee28f5275955" title="Cause a Qelem to execute with a higher priority.">qelem_front()</a>. This function is recommended for responding to messages that will cause your object to open a dialog box, such as read and write.</dd></dl>
<p>The deferred function should be declared as follows: </p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> myobject_do (myObject *client, <a class="code" href="structt__symbol.html" title="The symbol.">t_symbol</a> *s, <span class="keywordtype">short</span> argc, <a class="code" href="structt__atom.html" title="An atom is a typed datum.">t_atom</a> *argv);
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__threading.html#gaa24a0c9896f1ad241e45590065c3f643" title="Defer execution of a function to the main thread if (and only if) your function is executing in the s...">defer()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gad60dbceb5e50471a3ec76f608a9ea35c"></a><!-- doxytag: member="ext_proto.h::isr" ref="gad60dbceb5e50471a3ec76f608a9ea35c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long isr </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine whether your code is executing in the Max scheduler thread. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>This function returns non-zero if you are within Max's scheduler thread, zero otherwise. Note that if your code sets up other types of interrupt-level callbacks, such as for other types of device drivers used in asynchronous mode, isr will return false. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1eb8ec7623f0806dd079d7be708c19a8"></a><!-- doxytag: member="ext_proto.h::schedule" ref="ga1eb8ec7623f0806dd079d7be708c19a8" args="(void *ob, method fun, long when, t_symbol *sym, short argc, Atom *argv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void schedule </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d">method</a>&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>when</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__symbol.html">t_symbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Atom *&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cause a function to be executed at the timer level at some time in the future. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ob</td><td>First argument passed to the function fun when it executes. </td></tr>
    <tr><td class="paramname">fun</td><td>Function to be called, see below for how it should be declared. </td></tr>
    <tr><td class="paramname">when</td><td>The logical time that the function fun will be executed. </td></tr>
    <tr><td class="paramname">sym</td><td>Second argument passed to the function fun when it executes. </td></tr>
    <tr><td class="paramname">argc</td><td>Count of arguments in argv. argc is also the third argument passed to the function fun when it executes. </td></tr>
    <tr><td class="paramname">argv</td><td>Array containing a variable number of <a class="el" href="structt__atom.html" title="An atom is a typed datum.">t_atom</a> function arguments. If this argument is non-zero, defer allocates memory to make a copy of the arguments (according to the size passed in argc) and passes the copied array to the function fun when it executes as the fourth argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><a class="el" href="group__threading.html#ga1eb8ec7623f0806dd079d7be708c19a8" title="Cause a function to be executed at the timer level at some time in the future.">schedule()</a> calls a function at some time in the future. Unlike <a class="el" href="group__threading.html#gaa24a0c9896f1ad241e45590065c3f643" title="Defer execution of a function to the main thread if (and only if) your function is executing in the s...">defer()</a>, the function is called in the scheduling loop when logical time is equal to the specified value when. This means that the function could be called at interrupt level, so it should follow the usual restrictions on interrupt-level conduct. The function fun passed to schedule should be declared as follows:</dd></dl>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> myobject_do (myObject *client, <a class="code" href="structt__symbol.html" title="The symbol.">t_symbol</a> *s, <span class="keywordtype">short</span> argc, <a class="code" href="structt__atom.html" title="An atom is a typed datum.">t_atom</a> *argv); 
</pre></div><dl class="remark"><dt><b>Remarks:</b></dt><dd>One use of <a class="el" href="group__threading.html#ga1eb8ec7623f0806dd079d7be708c19a8" title="Cause a function to be executed at the timer level at some time in the future.">schedule()</a> is as an alternative to using the lockout flag.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__threading.html#gaa24a0c9896f1ad241e45590065c3f643" title="Defer execution of a function to the main thread if (and only if) your function is executing in the s...">defer()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa9b66fe2fc601f110bd962a622f1d5a0"></a><!-- doxytag: member="ext_proto.h::schedule_delay" ref="gaa9b66fe2fc601f110bd962a622f1d5a0" args="(void *ob, method fun, long delay, t_symbol *sym, short argc, t_atom *argv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void schedule_delay </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d">method</a>&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__symbol.html">t_symbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__atom.html">t_atom</a> *&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cause a function to be executed at the timer level at some time in the future specified by a delay offset. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ob</td><td>First argument passed to the function fun when it executes. </td></tr>
    <tr><td class="paramname">fun</td><td>Function to be called, see below for how it should be declared. </td></tr>
    <tr><td class="paramname">delay</td><td>The delay from the current time before the function will be executed. </td></tr>
    <tr><td class="paramname">sym</td><td>Second argument passed to the function fun when it executes. </td></tr>
    <tr><td class="paramname">argc</td><td>Count of arguments in argv. argc is also the third argument passed to the function fun when it executes. </td></tr>
    <tr><td class="paramname">argv</td><td>Array containing a variable number of <a class="el" href="structt__atom.html" title="An atom is a typed datum.">t_atom</a> function arguments. If this argument is non-zero, <a class="el" href="group__threading.html#gaa9b66fe2fc601f110bd962a622f1d5a0" title="Cause a function to be executed at the timer level at some time in the future specified by a delay of...">schedule_delay()</a> allocates memory to make a copy of the arguments (according to the size passed in argc) and passes the copied array to the function fun when it executes as the fourth argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><a class="el" href="group__threading.html#gaa9b66fe2fc601f110bd962a622f1d5a0" title="Cause a function to be executed at the timer level at some time in the future specified by a delay of...">schedule_delay()</a> is similar to <a class="el" href="group__threading.html#ga1eb8ec7623f0806dd079d7be708c19a8" title="Cause a function to be executed at the timer level at some time in the future.">schedule()</a> but allows you to specify the time as a delay rather than a specific logical time.</dd></dl>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> myobject_click (t_myobject *x, Point pt, <span class="keywordtype">short</span> modifiers) 
    { 
        <a class="code" href="structt__atom.html" title="An atom is a typed datum.">t_atom</a> a[1]; 
        a[0].<a class="code" href="structt__atom.html#a86aa4e605945738623b6f2b477c5a7d1" title="a value as defined in e_max_atomtypes">a_type</a> = <a class="code" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a002f28879581a6f66ea492b994b96f1e" title="long integer">A_LONG</a>; 
        a[0].<a class="code" href="structt__atom.html#a34dd9053b0a6585f90f4255da3f42d33" title="the actual data">a_w</a>.<a class="code" href="unionword.html#a6bc19a806142252aa3e84661a4b942a6" title="long integer">w_long</a> = Random(); 
        <a class="code" href="group__threading.html#gaa9b66fe2fc601f110bd962a622f1d5a0" title="Cause a function to be executed at the timer level at some time in the future specified by a delay of...">schedule_delay</a>(x, myobject_sched, 0 ,0, 1, a); 
    } 

    <span class="keywordtype">void</span> myobject_sched (t_myobject *x, <a class="code" href="structt__symbol.html" title="The symbol.">t_symbol</a> *s, <span class="keywordtype">short</span> ac, <a class="code" href="structt__atom.html" title="An atom is a typed datum.">t_atom</a> *av) 
    { 
        <a class="code" href="group__inout.html#ga0b2b38216f2f4dba486bfcd2273f255e" title="Use outlet_int() to send an int message out an outlet.">outlet_int</a>(x-&gt;m_out,av-&gt;<a class="code" href="structt__atom.html#a34dd9053b0a6585f90f4255da3f42d33" title="the actual data">a_w</a>.<a class="code" href="unionword.html#a6bc19a806142252aa3e84661a4b942a6" title="long integer">w_long</a>); 
    } 
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__threading.html#ga1eb8ec7623f0806dd079d7be708c19a8" title="Cause a function to be executed at the timer level at some time in the future.">schedule()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7217fa33811a5ed35b970f504b4e4a79"></a><!-- doxytag: member="ext_systhread.h::systhread_create" ref="ga7217fa33811a5ed35b970f504b4e4a79" args="(method entryproc, void *arg, long stacksize, long priority, long flags, t_systhread *thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long systhread_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d">method</a>&#160;</td>
          <td class="paramname"><em>entryproc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>stacksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__threading.html#gaaf0068b8e9ac28430873484727029315">t_systhread</a> *&#160;</td>
          <td class="paramname"><em>thread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new thread. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">entryproc</td><td>A method to call in the new thread when the thread is created. </td></tr>
    <tr><td class="paramname">arg</td><td>An argument to pass to the method specified for entryproc. Typically this might be a pointer to your object's struct. </td></tr>
    <tr><td class="paramname">stacksize</td><td>Not used. Pass 0 for this argument. </td></tr>
    <tr><td class="paramname">priority</td><td>Pass 0 for default priority. The priority can range from -32 to 32 where -32 is low, 0 is default and 32 is high. </td></tr>
    <tr><td class="paramname">flags</td><td>Not used. Pass 0 for this argument. </td></tr>
    <tr><td class="paramname">thread</td><td>The address of a <a class="el" href="group__threading.html#gaaf0068b8e9ac28430873484727029315" title="An opaque thread instance pointer.">t_systhread</a> where this thread's instance pointer will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A Max error code as defined in <a class="el" href="group__misc.html#ga0764dd6c02b76cca7d053ae50555d69d" title="Standard values returned by function calls with a return type of t_max_err.">e_max_errorcodes</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gad448ff5be27ef8233162a0e24751786f"></a><!-- doxytag: member="ext_systhread.h::systhread_exit" ref="gad448ff5be27ef8233162a0e24751786f" args="(long status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void systhread_exit </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Exit the calling thread. </p>
<p>Call this from within a thread made using <a class="el" href="group__threading.html#ga7217fa33811a5ed35b970f504b4e4a79" title="Create a new thread.">systhread_create()</a> when the thread is no longer needed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>You will typically pass 0 for status. This value will be accessible by <a class="el" href="group__threading.html#gaac24a9db0d7af2343501a4e762d2ce85" title="Wait for thread to quit and get return value from systhread_exit().">systhread_join()</a>, if needed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf073584f030cffc3a823601173803a95"></a><!-- doxytag: member="ext_systhread.h::systhread_getpriority" ref="gaf073584f030cffc3a823601173803a95" args="(t_systhread thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int systhread_getpriority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__threading.html#gaaf0068b8e9ac28430873484727029315">t_systhread</a>&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the thread priority for the given thread. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread for which to find the priority. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current priority value for the given thread. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7ed1192e20bccddec517591b4a5f0f91"></a><!-- doxytag: member="ext_systhread.h::systhread_ismainthread" ref="ga7ed1192e20bccddec517591b4a5f0f91" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short systhread_ismainthread </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check to see if the function currently being executed is in the main thread. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns true if the function is being executed in the main thread, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9bc306a6b164f705e55d1612c5ccfb78"></a><!-- doxytag: member="ext_systhread.h::systhread_istimerthread" ref="ga9bc306a6b164f705e55d1612c5ccfb78" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short systhread_istimerthread </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check to see if the function currently being executed is in the scheduler thread. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns true if the function is being executed in the main thread, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="gaac24a9db0d7af2343501a4e762d2ce85"></a><!-- doxytag: member="ext_systhread.h::systhread_join" ref="gaac24a9db0d7af2343501a4e762d2ce85" args="(t_systhread thread, unsigned int *retval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long systhread_join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__threading.html#gaaf0068b8e9ac28430873484727029315">t_systhread</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>retval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for thread to quit and get return value from <a class="el" href="group__threading.html#gad448ff5be27ef8233162a0e24751786f" title="Exit the calling thread.">systhread_exit()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to join. </td></tr>
    <tr><td class="paramname">retval</td><td>The address of a long to hold the return value (status) from <a class="el" href="group__threading.html#gad448ff5be27ef8233162a0e24751786f" title="Exit the calling thread.">systhread_exit()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A Max error code as defined in <a class="el" href="group__misc.html#ga0764dd6c02b76cca7d053ae50555d69d" title="Standard values returned by function calls with a return type of t_max_err.">e_max_errorcodes</a>.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>If your object is freed, and your thread function accesses memory from your object, then you will obviously have a memory violation. A common use of <a class="el" href="group__threading.html#gaac24a9db0d7af2343501a4e762d2ce85" title="Wait for thread to quit and get return value from systhread_exit().">systhread_join()</a> is to prevent this situation by waiting (in your free method) for the thread to exit. </dd></dl>

</div>
</div>
<a class="anchor" id="gab76eb3e1668b13483533c4929be5c914"></a><!-- doxytag: member="ext_systhread.h::systhread_self" ref="gab76eb3e1668b13483533c4929be5c914" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__threading.html#gaaf0068b8e9ac28430873484727029315">t_systhread</a> systhread_self </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the thread instance pointer for the calling thread. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The thread instance pointer for the thread from which this function is called. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4e4b35c628d791550e5523c4b554d466"></a><!-- doxytag: member="ext_systhread.h::systhread_setpriority" ref="ga4e4b35c628d791550e5523c4b554d466" args="(t_systhread thread, int priority)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void systhread_setpriority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__threading.html#gaaf0068b8e9ac28430873484727029315">t_systhread</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the thread priority for the given thread. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread for which to set the priority. </td></tr>
    <tr><td class="paramname">priority</td><td>A value in the range -32 to 32 where -32 is lowest, 0 is default, and 32 is highest. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad1ca1694ee14824a56916d8f67d7966b"></a><!-- doxytag: member="ext_systhread.h::systhread_sleep" ref="gad1ca1694ee14824a56916d8f67d7966b" args="(long milliseconds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void systhread_sleep </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>milliseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Suspend the execution of the calling thread. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds</td><td>The number of milliseconds to suspend the execution of the calling thread. The actual amount of time may be longer depending on various factors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaacc57aeddc69c01e7562397bdf6f12f5"></a><!-- doxytag: member="ext_systhread.h::systhread_terminate" ref="gaacc57aeddc69c01e7562397bdf6f12f5" args="(t_systhread thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long systhread_terminate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__threading.html#gaaf0068b8e9ac28430873484727029315">t_systhread</a>&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Forcefully kill a thread -- not recommended. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to kill. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A Max error code as defined in <a class="el" href="group__misc.html#ga0764dd6c02b76cca7d053ae50555d69d" title="Standard values returned by function calls with a return type of t_max_err.">e_max_errorcodes</a>. </dd></dl>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

		<div id="c74footer">
			&nbsp;&nbsp;Copyright &copy; 2011, <a href="http://www.cycling74.com/">Cycling '74</a>
		</div>
	</body>
</html>
