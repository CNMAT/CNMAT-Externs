The purpose of this chapter is to fill in additional details of Jitter OpenGL, which we refer to as OB3Ds.

We will show how to disable and/or override default OB3D attributes and methods, how to support matrix input and output, and manage resources such as textures, display lists, and shaders. This chapter assumes familiarity with the OpenGL API and the OB3D Quick Start chapter. It is out of the scope of our documentation to cover the OpenGL API, so for information on the OpenGL API we recommend consulting the OpenGL Red Book and the many online tutorials.\hypertarget{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_classdef}{}\section{Defining the OB3D Jitter Class}\label{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_classdef}
As covered in the OB3D Quick Start, Jitter OB3Ds have a large number of default attributes and methods, and require some specific methods to be defined. This section seeks to clarify these common attributes and methods and how to achieve custom behavior where necessary.\hypertarget{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_draw}{}\section{Declaring a Draw Method}\label{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_draw}
All Jitter OB3Ds must define a method bound to the symbol ob3d\_\-draw. This method takes no arguments in addition to the object struct, and should be defined with the private \hyperlink{group__atom_gga8aa6700e9f00b132eb376db6e39ade47af48193ec36e53b1507d81c49873c8d7a}{A\_\-CANT} type signature. The private ob3d\_\-draw method will be called by the standard draw, and drawraw methods that are added to every OB3D. The draw method will set up OpenGL state associated with the default OB3D attributes before calling ob3d\_\-draw, while the drawraw method will not.\hypertarget{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_geom}{}\section{Declaring Destination and Geometry Related Methods}\label{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_geom}
It is possible for attributes of a Jitter OB3D or your render destination to change, requiring resources to be freed or rebuilt. There are three methods used to communicate to an OB3D which such events happen so that the OB3D can manage resources accordingly. They are: dest\_\-closing, which informs an OB3D that the destination is being freed, and any context dependent resources such as textures, display lists, and shaders should be freed; dest\_\-changed, which informs an OB3D that the destination has been rebuilt, and new resources can be allocated; and rebuild\_\-geometry, which informs an OB3D of a change in texture units or some other attribute which affects \hyperlink{group__ob3dmod_ga6b42cd2b3e58ff2c13d38b4bde52668d}{jit\_\-gl\_\-drawinfo\_\-setup()} and other \hyperlink{structt__jit__gl__drawinfo}{t\_\-jit\_\-gl\_\-drawinfo} related functions, such as jit\_\-gl\_\-texcoord, requiring geometry that uses such functions to be rebuilt. These methods take no arguments in addition to the object struct. The dest\_\-closing and dest\_\-changed methods should be defined with the private \hyperlink{group__atom_gga8aa6700e9f00b132eb376db6e39ade47af48193ec36e53b1507d81c49873c8d7a}{A\_\-CANT} type signature, and the rebuild\_\-geometry method is typically defined as typed, but without arguments, so that users have the ability to explicitly call, if deemed necessary. The jit.gl.gridshape SDK project is a good example of these methods as it needs to free and allocate a display list as the render destination changes, and also makes use of jit\_\-gl\_\-texcoord to support multi-\/texturing, requiring geometry to be rebuilt as the number of texture units or other attributes change.\hypertarget{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_reg}{}\section{Declaring a Register Method}\label{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_reg}
Since all Jitter OB3D objects are named to support reference by name in jit.gl.sketch, and other objects, it is necessary to add the default registration method, \hyperlink{group__objectmod_gabcf088a00f36b6af8ce5896b81e4d0ef}{jit\_\-object\_\-register()}. Object registration and notification are covered in detail in a future chapter.\hypertarget{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_rot}{}\section{Overriding Rotation and Scale Related Attributes}\label{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_rot}
By default, each Jitter OB3D has rotate, rotatexyz, scale, and viewalign attributes added to the class by \hyperlink{group__ob3dmod_gaee60152a1d507a630e14f0e4f71e86f2}{jit\_\-ob3d\_\-setup()}, and these attributes are used in the ob3d\_\-draw\_\-preamble() function to set up OpenGL state prior to calling your object's draw method. These attributes can be disabled by using the \hyperlink{group__jitter_gafc39daa7e259fa20f8fe918cb4892dc4}{JIT\_\-OB3D\_\-NO\_\-ROTATION\_\-SCALE} flag. You can override these attributes by defining your own attributes of the same name, however, you will need to manage any necessary OpenGL state inside of your own draw method with the appropriate calls to glMatrixMode, glTranslate, glRotate, and glScale.\hypertarget{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_color}{}\section{Overriding Color Related Attributes}\label{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_color}
By default, each Jitter OB3D has color, aux\_\-color, and smooth\_\-shading attributes added to the class by \hyperlink{group__ob3dmod_gaee60152a1d507a630e14f0e4f71e86f2}{jit\_\-ob3d\_\-setup()}, and these attributes are used in the ob3d\_\-draw\_\-preamble function prior to calling your object's draw method. These attributes can be disabled by using the \hyperlink{group__jitter_ga6d6e4c119dbea5119a0f452a2486e590}{JIT\_\-OB3D\_\-NO\_\-COLOR} flag. You can override these attributes by defining your own attributes of the same name, however, you will need to manage any necessary OpenGL state inside of your own draw method with the appropriate calls to glColor and glShadeModel.\hypertarget{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_texture}{}\section{Overriding Texture Related Attributes}\label{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_texture}
By default, each Jitter OB3D has texture, capture, tex\_\-map, tex\_\-plane\_\-s, and tex\_\-plane\_\-t attributes added to the class by \hyperlink{group__ob3dmod_gaee60152a1d507a630e14f0e4f71e86f2}{jit\_\-ob3d\_\-setup()}, and these attributes are used in the ob3d\_\-draw\_\-preamble() function prior to calling your object's draw method. These attributes can be disabled by using the \hyperlink{group__jitter_gaf7d77e7694341904bdbd7440ae71d42e}{JIT\_\-OB3D\_\-NO\_\-TEXTURE} flag. You can override these attributes by defining your own attributes of the same name, however, you will need to manage any necessary OpenGL state inside of your own draw method with the appropriate calls to glEnable, glTexGen, jit\_\-gl\_\-bindtexture, jit\_\-gl\_\-unbindtexture, jit\_\-gl\_\-begincapture, and jit\_\-gl\_\-endcapture.\hypertarget{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_lighting}{}\section{Overriding Lighting and Material Related Attributes}\label{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_lighting}
By default, each Jitter OB3D has lighting\_\-enable, auto\_\-material, shininess, mat\_\-ambient, mat\_\-diffuse, mat\_\-specular, and mat\_\-emission attributes added to the class by \hyperlink{group__ob3dmod_gaee60152a1d507a630e14f0e4f71e86f2}{jit\_\-ob3d\_\-setup()}, and these attributes are used in the ob3d\_\-draw\_\-preamble function prior to calling your object's draw method. These attributes can be disabled by using the \hyperlink{group__jitter_gaf7b319953ace69f17633be98233fd324}{JIT\_\-OB3D\_\-NO\_\-LIGHTING\_\-MATERIAL} flag. You can override these attributes by defining your own attributes of the same name, however, you will need to manage any necessary OpenGL state inside of your own draw method with the appropriate calls to glEnable, glLight, glLightModel, and glMaterial.\hypertarget{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_fog}{}\section{Overriding Fog Related Attributes}\label{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_fog}
By default, each Jitter OB3D has fog and fog\_\-params attributes added to the class by \hyperlink{group__ob3dmod_gaee60152a1d507a630e14f0e4f71e86f2}{jit\_\-ob3d\_\-setup()}, and these attributes are used in the ob3d\_\-draw\_\-preamble function prior to calling your object's draw method. These attributes can be disabled by using the \hyperlink{group__jitter_gaf9c39790969f477fb42c3fe674eb5ca7}{JIT\_\-OB3D\_\-NO\_\-FOG} flag. You can override these attributes by defining your own attributes of the same name, however, you will need to manage any necessary OpenGL state inside of your own draw method with the appropriate calls to glEnable, glHint, and glFog.\hypertarget{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_poly}{}\section{Overriding Polygon Variable Related Attributes}\label{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_poly}
By default, each Jitter OB3D has poly\_\-mode, cull\_\-face, point\_\-size, and line\_\-width attributes added to the class by \hyperlink{group__ob3dmod_gaee60152a1d507a630e14f0e4f71e86f2}{jit\_\-ob3d\_\-setup()}, and these attributes are used in the ob3d\_\-draw\_\-preamble function prior to calling your object's draw method. These attributes can be disabled by using the \hyperlink{group__jitter_ga2eee6fc87f33ea672c921cddf960d5e1}{JIT\_\-OB3D\_\-NO\_\-POLY\_\-VARS} flag. You can override these attributes by defining your own attributes of the same name, however, you will need to manage any necessary OpenGL state inside of your own draw method with the appropriate calls to glPolygonMode, glEnable, glCullFace, glPointSize, and glLineWidth.\hypertarget{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_blend}{}\section{Overriding Blending Related Attributes}\label{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_blend}
By default, each Jitter OB3D has blend\_\-mode and blend\_\-enable attributes added to the class by \hyperlink{group__ob3dmod_gaee60152a1d507a630e14f0e4f71e86f2}{jit\_\-ob3d\_\-setup()}, and these attributes are used in the ob3d\_\-draw\_\-preamble function prior to calling your object's draw method. These attributes can be disabled by using the \hyperlink{group__jitter_gab4407b5b96c0744f03bec69e204b56bb}{JIT\_\-OB3D\_\-NO\_\-BLEND} flag. You can override these attributes by defining your own attributes of the same name, however, you will need to manage any necessary OpenGL state inside of your own draw method with the appropriate calls to glEnable and glBlendFunc.\hypertarget{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_aa}{}\section{Overriding Depth Buffer and Antialiasing Related Attributes}\label{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_aa}
By default, each Jitter OB3D has depth\_\-enable and antialias attributes added to the class by \hyperlink{group__ob3dmod_gaee60152a1d507a630e14f0e4f71e86f2}{jit\_\-ob3d\_\-setup()}, and these attributes are used in your ob3d\_\-draw\_\-preamble function prior to calling your object's draw method. These attributes can be disabled by using the \hyperlink{group__jitter_gad4a2b2f395618bafbd7faca61106b9f7}{JIT\_\-OB3D\_\-NO\_\-DEPTH} and \hyperlink{group__jitter_ga2ef1435359d9dca4722fb71db4b0d423}{JIT\_\-OB3D\_\-NO\_\-ANTIALIAS} flags, respectively. You can override these attributes by defining your own attributes of the same name, however, you will need to manage any necessary OpenGL state inside of your own draw method with the appropriate calls to glEnable and glHint.\hypertarget{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_matout}{}\section{Overriding Matrixoutput and Automatic Attributes}\label{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_matout}
By default, each Jitter OB3D has matrixoutput and automatic attributes added to the class by \hyperlink{group__ob3dmod_gaee60152a1d507a630e14f0e4f71e86f2}{jit\_\-ob3d\_\-setup()}, and these attributes are used in the ob3d\_\-draw\_\-preamble function prior to calling your object's draw method. These attributes can be disabled by using the \hyperlink{group__jitter_ga015276252d0ad61f9f35ad1ea227d089}{JIT\_\-OB3D\_\-NO\_\-MATRIXOUTPUT} and \hyperlink{group__jitter_ga63a89334c5c06f92792333d191b71b06}{JIT\_\-OB3D\_\-AUTO\_\-ONLY} flags, respectively. You can override these attributes by defining your own attributes of the same name.\hypertarget{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_ui}{}\section{Declaring a User Interface Object}\label{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_ui}
It is possible to declare a user interface OB3D, such as jit.gl.handle. To do so, you must use the \hyperlink{group__jitter_gaafef09ee7a36fc16e46529783df7cd72}{JIT\_\-OB3D\_\-DOES\_\-UI} flag to \hyperlink{group__ob3dmod_gaee60152a1d507a630e14f0e4f71e86f2}{jit\_\-ob3d\_\-setup()}, and define a method bound to the symbol ob3d\_\-ui, with the private \hyperlink{group__atom_gga8aa6700e9f00b132eb376db6e39ade47af48193ec36e53b1507d81c49873c8d7a}{A\_\-CANT} type signature and prototype similar to the following example from jit.gl.handle:


\begin{DoxyCode}
t_jit_err jit_gl_handle_ui(t_jit_gl_handle *x, 
   t_line_3d *p_line, t_wind_mouse_info *p_mouse);
\end{DoxyCode}
\hypertarget{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_jitclassctor}{}\section{The Jitter Class Constructor and Destructor}\label{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_jitclassctor}
Inside your Jitter class constructor, you must call \hyperlink{group__ob3dmod_gac27d63b4d66faf27fda165792dafa223}{jit\_\-ob3d\_\-new()} with a pointer to your newly allocated object, and your render destination name. The \hyperlink{group__ob3dmod_gac27d63b4d66faf27fda165792dafa223}{jit\_\-ob3d\_\-new()} function allocates an opaque structure that stores the standard OB3D attributes and some additional OB3D state, initializing them to default values, and then setting the pointer at the byte offset specified when calling the \hyperlink{group__ob3dmod_gaee60152a1d507a630e14f0e4f71e86f2}{jit\_\-ob3d\_\-setup()} function in your class definition. If your object supports matrix output or simply uses the \hyperlink{structt__jit__glchunk}{t\_\-jit\_\-glchunk} structure when drawing, you should typically allocate your initial \hyperlink{structt__jit__glchunk}{t\_\-jit\_\-glchunk} in your constructor using the \hyperlink{group__ob3dmod_gae1cfab3f91302b90cdcd8e8723295f91}{jit\_\-glchunk\_\-new()} or \hyperlink{group__ob3dmod_ga5c8a73551161b7ba602c0bea2ea9e479}{jit\_\-glchunk\_\-grid\_\-new()} functions. Use of the \hyperlink{structt__jit__glchunk}{t\_\-jit\_\-glchunk} structure and matrix output is described later in this chapter. Similarly, your OB3D Jitter class destructor must call \hyperlink{group__ob3dmod_ga5c1537df19c2d7e12ef809d3de3943d9}{jit\_\-ob3d\_\-free()} to free the opaque structure used for common OB3D state, free any allocated instances of \hyperlink{structt__jit__glchunk}{t\_\-jit\_\-glchunk} with jit\_\-glchunk\_\-free(), and free any other resources allocated such as display lists or textures.\hypertarget{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_ob3ddraw}{}\section{The OB3D Draw Method}\label{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_ob3ddraw}
The ob3d\_\-draw method is where all the drawing in your object should take place. It is also where you should typically allocate context dependent resources or query the context state, since you know that your context is valid and has been set. For the most part, the drawing you will perform in your ob3d\_\-draw method will be pure and simple OpenGL, though there are a few caveats which we will cover.\hypertarget{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_glstruct}{}\section{The t\_\-jit\_\-glchunk Structure and Matrix Output}\label{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_glstruct}
Since Jitter is a general purpose matrix processing framework, it makes sense that you would have the ability to pass geometry information through a Jitter network as matrices if your geometry is well suited to a matrix representation. The cells of your matrix can hold vertex information such as position, texture coordinates, normal vectors, color, and edge flags, and are documented in the \char`\"{}Geometry Under The Hood\char`\"{} Jitter Tutorial. You also have the option of specifying a connections matrix to reference the connectivity of the vertices if it is not implicit in the matrix representation, and a drawing primitive to use when drawing the vertices.

All this information, and whether or not the geometry matrix should be rendered immediately or sent through the Jitter network is managed with the \hyperlink{structt__jit__glchunk}{t\_\-jit\_\-glchunk}. An SDK example which demonstrates the use of \hyperlink{structt__jit__glchunk}{t\_\-jit\_\-glchunk} is jit.gl.gridshape. The \hyperlink{structt__jit__glchunk}{t\_\-jit\_\-glchunk} structure along with the vertex matrix it contains is allocated by the \hyperlink{group__ob3dmod_gae1cfab3f91302b90cdcd8e8723295f91}{jit\_\-glchunk\_\-new()} or \hyperlink{group__ob3dmod_ga5c8a73551161b7ba602c0bea2ea9e479}{jit\_\-glchunk\_\-grid\_\-new()} functions, freed with the \hyperlink{group__ob3dmod_gae4fabfa866a64f68987de90e065e604e}{jit\_\-glchunk\_\-delete()} function, and drawn with the \hyperlink{group__ob3dmod_gacb2a2ba1b2bb33377aa10b45bb3a0531}{jit\_\-ob3d\_\-draw\_\-chunk()} function. For reference, the \hyperlink{structt__jit__glchunk}{t\_\-jit\_\-glchunk} structure and relevant chunk flags are provided below:


\begin{DoxyCode}
// jit_glchunk is a public structure to store one 
// gl-command's-worth of data, in a format which 
// can be passed easily to glDrawRangeElements.  

typedef struct _jit_glchunk
{
   t_symbol   *prim;         // GL_TRI_STRIP, GL_TRIANGLES, etc. 
   t_jit_object *m_vertex;      // jit_matrix of xyzst... data. 
   t_symbol    *m_vertex_name;   // vertex matrix name
   t_jit_object *m_index;      // optional 1d connection matrix
   t_symbol    *m_index_name;   // connection matrix name
   unsigned long m_flags;      // special flags
   void      *next_chunk;      // singly linked list, typically NULL
} t_jit_glchunk;

// flags for chunk creation
#define JIT_GL_CHUNK_IGNORE_TEXTURES      1 << 0
#define JIT_GL_CHUNK_IGNORE_NORMALS      1 << 1
#define JIT_GL_CHUNK_IGNORE_COLORS      1 << 2
#define JIT_GL_CHUNK_IGNORE_EDGES      1 << 3
\end{DoxyCode}
\hypertarget{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_caveats}{}\section{OB3D OpenGL Caveats}\label{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_caveats}
While you can use any standard Open GL calls inside of your ob3d\_\-draw method. There are a few things worth noting to follow Jitter conventions. The first of which is the binding of texture coordinates. Since Jitter OB3Ds support multi-\/texturing by default, it is not necessarily satisfactory to submit only one texture coordinate with glTexCoord. Jitter provides some utility routines to set the texture coordinates for as many texture units which are bound, jit\_\-gl\_\-texcoord(1/2/3)(f/fv). Determining how many texture units have been bound by the default OB3D attributes requires some overhead, so rather than perform this overhead with every jit\_\-gl\_\-texcoord call, the jit\_\-gl\_\-texcoord functions take a \hyperlink{structt__jit__gl__drawinfo}{t\_\-jit\_\-gl\_\-drawinfo} struct as an argument. This struct can be setup once before rendering many vertices with the jit\_\-gl\_\-drawinfo\_\-setup function. Example use of jit\_\-gl\_\-texcoord and jit\_\-gl\_\-drawinfo\_\-setup is in the jit.gl.videoplane SDK project. Another Jitter specific mechanism is the means to bind textures using named instances of jit.gl.texture. It is possible to create and bind your own textures in an OB3D, but you must then perform all maintenance instead of relying on jit.gl.texture to handle this work for you. To bind and unbind an instance of jit.gl.texture, you should call the jit\_\-gl\_\-bindtexture and jit\_\-gl\_\-unbindtexture functions, which take a \hyperlink{structt__jit__gl__drawinfo}{t\_\-jit\_\-gl\_\-drawinfo} argument, a symbol with the name of the jit.gl.texture instance, and an integer for which texture unit to bind. Unlike binding ordinary textures in OpenGL, it is important to unbind instances of jit.gl.texture, or else problems may arise.\hypertarget{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_attrinfo}{}\section{Getting Information About the OB3D Attributes}\label{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_attrinfo}
Though the default OB3D attributes are typically relevant to the code which is automatically handled for your object prior to calling the ob3d\_\-draw method, it is sometimes necessary to access these values. Since the default OB3D attributes are stored in an opaque ob3d struct member, they are not accessible by your object with a simple struct pointer dereference. Instead, you need to use the jit\_\-attr\_\-get$\ast$ functions to access these attributes. You should pass in your object struct as the first argument to these functions rather than your ob3d struct member. For example:


\begin{DoxyCode}
   float pos[3];
   jit_attr_getfloat_array(x,gensym("position"),3,pos);
\end{DoxyCode}


Note that if you are acquiring this value often, it is preferable to generate the symbol in advance rather than generate the symbol for every call.\hypertarget{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_context}{}\section{Getting Information About the Context}\label{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_context}
From within the ob3d\_\-draw, dest\_\-closing, and dest\_\-changed methods, the rendering context has always been set, and you can get a handle to the native context using either the aglGetCurrentContext or wglGetCurrentContext functions. One can also in these methods use standard OpenGL glGet$\ast$ functions to determine the context's OpenGL state, such as the viewport, transformation matrix. It is not recommended to try and acquire the native context from other methods, or query the OpenGL state as it may not be valid.\hypertarget{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_play}{}\section{Playing Well with Others}\label{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_play}
It is important to recognize that OpenGL state is persistent, and that there may be objects which rely on OpenGL state that are drawn after your object draws itself. If your object makes any changes to OpenGL state that might affect objects that follow, you should restore the OpenGL state to whatever it was before your routine was called. For example, if your object changes the texture transformation matrix, you should push and pop the texture transformation matrix with glMatrixMode, glPushMatrix, and glPopMatrix, to prevent any problems with other objects.\hypertarget{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_wrapdef}{}\section{Defining the OB3D Max Wrapper Class}\label{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_wrapdef}
As mentioned in the OB3D Quick Start, in your Max wrapper class definition, you need only add a call to the \hyperlink{group__ob3dmod_ga6bb6d0a3847efb08150eb752257f8be9}{max\_\-ob3d\_\-setup()} function to add your standard drawing methods, and the \hyperlink{group__ob3dmod_ga8fa7e82f9a1f64c2e5d10b2dbf340536}{max\_\-jit\_\-ob3d\_\-assist()} function as your assist method, unless you wish to define your own custom assist method. Everything else is similar to the standard technique of wrapping a Jitter Class demonstrated in the Max Wrapper Class chapter. Please consult the OB3D Quick Start chapter and the jit.gl.simple SDK project for all necessary information related to the OB3D Max wrapper class.\hypertarget{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_matin}{}\section{Matrix Input}\label{chapter_jit_ob3ddetails_chapter_jit_ob3ddetails_matin}
Sometimes it is desirable for an OB3D also support incoming matrices as is the case with jit.gl.videoplane or jit.gl.mesh. It is not recommended to mix and match OB3Ds with MOPs. Conflicts arise with respect to arguments, standard inlets and outlets. Instead, if you wish to support matrix input in your OB3D, you should simply add to your Jitter class a method bound to the symbol jit\_\-matrix, and handle the incoming matrix data according to your needs -\/ for example as texture data in the case of jit.gl.videoplane, or geometry data in the case of jit.gl.mesh. The jit.gl.videoplane SDK project provides an example of an OB3D which also supports matrix input. When it is necessary to have multiple input matrices, this is typically managed by either declaring alternately named methods for each input, or exposing an attribute that specifies which input the jit\_\-matrix method assumes it is being called with. Note that this requires additional logic within the Max wrapper class to map to inlets, as it is not handled automatically. 