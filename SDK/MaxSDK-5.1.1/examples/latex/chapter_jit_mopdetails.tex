The purpose of this chapter is to fill in the details of what a Matrix Operator is and how it works.

Matrix data in Jitter is typically considered raw data without respect to what the data represents. This permits simple fundamental operations to be applied to different sorts of data without needing to know any special information. For this reason most MOPs are general purpose. The jit.scalebias example from the preceding chapter could be considered video specific in its terminology, and type and plane count restrictions, but fundamentally it is just calculating a product and sum on each plane of an incoming matrix. In this chapter, we'll cover the details of how to configure MOP inputs and outputs, any attribute restrictions or linking for those inputs and outputs, what you must do in your matrix\_\-calc method and how you expose your MOP to the Max environment, overriding default behavior if necessary.\hypertarget{chapter_jit_mopdetails_chapter_jit_mopdetails_classes}{}\section{Defining the MOP Jitter Class}\label{chapter_jit_mopdetails_chapter_jit_mopdetails_classes}
As discussed in the Matrix Operator Quick Start, for MOPs you must create an instance of jit\_\-mop with the \hyperlink{group__objectmod_gabde2eb49750992ec4125af862b402342}{jit\_\-object\_\-new()} function and add it to your Jitter class as an adornment with the \hyperlink{group__classmod_ga408738c800435bf50d092ce52b223327}{jit\_\-class\_\-addadornment()} function. The jit\_\-mop object holds information such as how many inputs and outputs the object has, what types, plane count, and dimension counts are supported, and how inputs should respond to incoming matrices. This information is only relevant to wrappers of the Jitter object which actually maintain additional matrices for inputs and outputs, as is the case with the MOP Max wrapper class. When used from C, Java, or JavaScript, it is the the programmer's responsibility to pass in matrices that conform to any restrictions imposed by the MOP. An example of instantiating and adding the jit\_\-mop object is below.


\begin{DoxyCode}
   // create a new instance of jit_mop with 1 input, and 1 output 
   mop = jit_object_new(_jit_sym_jit_mop,1,1);
   
   // add jit_mop object as an adornment to the class
   jit_class_addadornment(_jit_your_class,mop);
\end{DoxyCode}
\hypertarget{chapter_jit_mopdetails_chapter_jit_mopdetails_io}{}\section{The jit\_\-mop\_\-io Object}\label{chapter_jit_mopdetails_chapter_jit_mopdetails_io}
Each instance of jit\_\-mop contains some number of inputs and outputs, specified by the input and output arguments to the constructor. For each of these inputs and outputs there is an instance of jit\_\-mop\_\-io which records information specific to that input or output, such as type, plane count, and dimension restrictions. You can access the input or output objects by calling the getinput or getoutput methods with an integer index argument as below:


\begin{DoxyCode}
   input = jit_object_method(mop,_jit_sym_getinput,1);
   output = jit_object_method(mop,_jit_sym_getoutput,1);
\end{DoxyCode}


Once you have obtained references to these inputs or outputs, you may query or set the jit\_\-mop\_\-io attributes. The attributes typically configured are: types, which is a list of symbols of permitted types, the first of which being the default; mindim and maxdim, which are the minimum and maximum permitted sizes for each dimension; mindimcount and maxdimcount, which are the minimum and maximum permitted number of dimensions permitted; minplanecount and maxplanecount, which are the minimum and maximum number of planes permitted; typelink, which is the flag that determines if the I/O should change its type to whatever the leftmost incoming matrix is; dimlink, which is the flag that determines if the I/O should change its dimensions to whatever the leftmost incoming matrix is; and planelink, which is the flag that determines if the I/O should change its plane count to whatever the leftmost incoming matrix is.\hypertarget{chapter_jit_mopdetails_chapter_jit_mopdetails_restrictingattrs}{}\section{Restricting Input/Output Attributes}\label{chapter_jit_mopdetails_chapter_jit_mopdetails_restrictingattrs}
By default, all types, dimensions and plane count are permitted, and all linking is enabled. If you wish your MOP to have some specific restrictions, or difference in linking behaviors for any input or output in particular, you can set the corresponding attributes. For example, to set the plane count to always be four planes, you would set both the minplanecount and maxplanecount attributes to 4, as below:


\begin{DoxyCode}
   output = jit_object_method(mop,_jit_sym_getoutput,1);
   jit_attr_setlong(output,_jit_sym_minplanecount,4);
   jit_attr_setlong(output,_jit_sym_maxplanecount,4);
\end{DoxyCode}


The jit.scalebias example could have set the planecount using the minplanecount and maxplanecount attributes rather than calling the utility function \hyperlink{group__mopmod_gada02eaa2a5dc001cdb120a83cb093e25}{jit\_\-mop\_\-single\_\-planecount()}, which internally sets these attributes. A similar thing could be done to restrict type and dimensions. As for linking, if you wish to develop an object where the right hand input does not adapt to the size of the leftmost input, as is the case with jit.convolve, you would turn off the dimlink attribute, as below:


\begin{DoxyCode}
   input2 = jit_object_method(mop,_jit_sym_getinput,2);
   jit_attr_setlong(input2,_jit_sym_dimlink,0);
\end{DoxyCode}


Similar could be done to remove type and planecount linking, and the utility functions \hyperlink{group__mopmod_ga3f223fa6414f856e2484dbab7508945f}{jit\_\-mop\_\-input\_\-nolink()} and \hyperlink{group__mopmod_ga6878129233c6c88c43b8512db44a43ff}{jit\_\-mop\_\-output\_\-nolink()} set all of these link attributes to false (zero).\hypertarget{chapter_jit_mopdetails_chapter_jit_mopdetails_ioproc}{}\section{The ioproc Function}\label{chapter_jit_mopdetails_chapter_jit_mopdetails_ioproc}
For right hand matrix inputs, incoming data is typically copied by the MOP Max wrapper class. When an incoming matrix is received by the MOP Max wrapper class, a function called the ioproc is called, and the default ioproc copies the data, using the current input attributes (which might be linked to the lefthand input). The default ioproc can be overridden by calling the ioproc method followed by a function with the signature as listed below in the \hyperlink{group__mopmod_ga9d6c3b36f1e4a7ef30d674eda4196a5c}{jit\_\-mop\_\-ioproc\_\-copy\_\-adapt()} function. The \hyperlink{group__mopmod_ga9d6c3b36f1e4a7ef30d674eda4196a5c}{jit\_\-mop\_\-ioproc\_\-copy\_\-adapt()} function will always adapt to that inlet's incoming matrix attributes, as long as they don't conflict with any restrictions. The SDK project for jit.concat demonstrates the use of the \hyperlink{group__mopmod_ga9d6c3b36f1e4a7ef30d674eda4196a5c}{jit\_\-mop\_\-ioproc\_\-copy\_\-adapt()} function.


\begin{DoxyCode}
t_jit_err jit_mop_ioproc_copy_adapt(void *mop, void *mop_io, void *matrix)
{
   void *m; // destination matrix
   t_jit_matrix_info info;
   
   // look up destination matrix from mop_io
   if (matrix&&(m=jit_object_method(mop_io,_jit_sym_getmatrix))) 
   {
      // retrieve incoming matrix info
      jit_object_method(matrix,_jit_sym_getinfo,&info);

      //restrict matrix info based on mop_io attribtues
      jit_object_method(mop_io,_jit_sym_restrict_type,&info);
      jit_object_method(mop_io,_jit_sym_restrict_dim,&info);
      jit_object_method(mop_io,_jit_sym_restrict_planecount,&info);

      // set destination matrix info
      jit_object_method(m,_jit_sym_setinfo,&info);

      // copy the data with the frommatrix method
      jit_object_method(m,_jit_sym_frommatrix,matrix,NULL);
   }

   return JIT_ERR_NONE;
}
\end{DoxyCode}
\hypertarget{chapter_jit_mopdetails_chapter_jit_mopdetails_vario}{}\section{Variable Inputs/Outputs}\label{chapter_jit_mopdetails_chapter_jit_mopdetails_vario}
You can specify variable input/output MOPs with a negative argument for input and/or outputs when constructing your jit\_\-mop object. When the using variable inputs and/or outputs, there is not a jit\_\-mop\_\-io for each input and/or output within your class definition, and therefore the template type, dim, planecount, and linking attributes are not settable. If anything but the default behavior is required, you must accomplished it in another way â€” for example, either by overriding the jit\_\-matrix method of the MOP Max wrapper class, or defining an mproc method to be called from within the standard jit\_\-matrix method of the MOP Max wrapper class. The jit.pack, jit.unpack, jit.scissors, and jit.glue objects are a few SDK examples of MOPs with variable inputs and outputs. More information on overriding the jit\_\-matrix, mproc, and other default methods of the MOP Max wrapper class is covered later in this chapter.\hypertarget{chapter_jit_mopdetails_chapter_jit_mopdetails_adorn}{}\section{Adding jit\_\-mop as a Class Adornment}\label{chapter_jit_mopdetails_chapter_jit_mopdetails_adorn}
Once you have configured all of the inputs and outputs of your jit\_\-mop object, you must add your jit\_\-mop object to your Jitter class with the \hyperlink{group__classmod_ga408738c800435bf50d092ce52b223327}{jit\_\-class\_\-addadornment()} function. Adorments can be queried from the Jitter class at any time by calling \hyperlink{group__classmod_ga1b040b25876a0905f60683413ce34ae6}{jit\_\-class\_\-adornment\_\-get()} with the Jitter class pointer and the class name of the adornment object, as demonstrated below.


\begin{DoxyCode}
   // add jit_mop object as an adornment to the class
   jit_class_addadornment(_jit_your_class,mop);

   // look up jit_mop adornment 
   mop = jit_class_adornment_get(_jit_your_class,_jit_sym_jit_mop);
\end{DoxyCode}
\hypertarget{chapter_jit_mopdetails_chapter_jit_mopdetails_calc}{}\section{The Matrix Calculation Method}\label{chapter_jit_mopdetails_chapter_jit_mopdetails_calc}
The entry point of the MOP Jitter class is the matrix\_\-calc method, which is passed a list of matrices for the input, and a list of matrices for the output. It is not the responsibility of the matrix\_\-calc method to perform any copying and adaptation behavior, but rather simply ensure that the matrices are valid, compatible, and if so, process. Certain objects may modify the dim, type, or planecount of the output matrices â€” e.g. the SDK project, jit.thin. However, it is the calling party's responsibility to perform any copying and conformance to MOP I/O restrictions as defined by the jit\_\-mop\_\-io objectsâ€”i.e. either the Max wrapper class, or the C, Java, or Javascript code which calls the matrix\_\-calc method.\hypertarget{chapter_jit_mopdetails_chapter_jit_mopdetails_access}{}\section{Accessing the Input and Output Lists}\label{chapter_jit_mopdetails_chapter_jit_mopdetails_access}
The input and output lists passed as arguments to your matrix\_\-calc method are Jitter objects, and pointers to the individual inputs and outputs are acquired by calling the getindex method with an integer argument specifying the zero based list index. The return values should be tested to make sure they are not null. For example:


\begin{DoxyCode}
   // get the zeroth index input and output from 
   // the corresponding input and output lists
   in_matrix    = jit_object_method(inputs,_jit_sym_getindex,0);
   out_matrix   = jit_object_method(outputs,_jit_sym_getindex,0);
   
   // if the object and both input and output matrices
   // are valid, then process, else return an error
   if (x&&in_matrix&&out_matrix) 
   {
      // ... process data ...

   } else {
      return JIT_ERR_INVALID_PTR;
   }
\end{DoxyCode}


Technically, you can also pass in an instance of jit\_\-matrix in place of a list for the input or output arguments, since jit\_\-matrix has a getindex method which returns the jit\_\-matrix instance. This is an example of dynamic binding at work. Another example of dynamic binding inside the matrix\_\-calc method is that the list elements might be instances of jit\_\-mop\_\-io, rather than instances of jit\_\-matrix. However, since Jitter uses dynamic binding and the jit\_\-mop\_\-io object is a \char`\"{}decorator\char`\"{} class for jit\_\-matrix, all corresponding methods are passed on to the jit\_\-matrix referenced by the jit\_\-mop\_\-io. In fact, any Jitter objects which respond to the standard interface for jit\_\-matrix could be passed as inputs or outputs. If this seems confusing, you need not think about the underlying implementation further, but instead can assume that what is being passed in is simply an instance of jit\_\-matrix. After all it should behave like one, even if it is not.\hypertarget{chapter_jit_mopdetails_chapter_jit_mopdetails_locking}{}\section{Locking and Unlocking Matrices}\label{chapter_jit_mopdetails_chapter_jit_mopdetails_locking}
Prior to working with a matrix, it is necessary to \char`\"{}lock\char`\"{} it so that the data and attributes will not be changed across the duration of the operation. This is accomplished by calling the jit\_\-matrix instance's lock method with an integer argument of 1 (true) to lock the matrix. You should store the current lock state to restore when you're done processing. The lock operation should be the first thing to do after ensuring that the matrix objects are not NULL. For example


\begin{DoxyCode}
   // lock input and output matrices   
   in_savelock = (long) jit_object_method(in_matrix,_jit_sym_lock,1);
   out_savelock = (long) jit_object_method(out_matrix,_jit_sym_lock,1);

   // ... process data ...

out:
   // restore matrix lock state to previous value
   jit_object_method(out_matrix,_jit_sym_lock,out_savelock);
   jit_object_method(in_matrix,_jit_sym_lock,in_savelock);
\end{DoxyCode}
\hypertarget{chapter_jit_mopdetails_chapter_jit_mopdetails_info}{}\section{Retrieving Matrix Information}\label{chapter_jit_mopdetails_chapter_jit_mopdetails_info}
Once you have locked the matrices, you are ready to find out some information about them. This is accomplished by calling the getinfo method with a pointer to an instance of the \hyperlink{structt__jit__matrix__info}{t\_\-jit\_\-matrix\_\-info} struct. The \hyperlink{structt__jit__matrix__info}{t\_\-jit\_\-matrix\_\-info} struct contains several common attributes of the matrix and data organization of the matrix data, and is a useful way to obtain this information in one call, rather than querying each attribute individually. This information is typically tested to verify compatibility with any assumptions the matrix\_\-calc method needs to make (since this method might be called from C, Java, or Javascript, you cannot assume that the MOP Max wrapper will have enforced these assumptions). It is also used to perform the appropriate pointer arithmetic based on type, plane count, dimensions, and the byte stride of those dimensions, since higher dimensions may not be tightly packed. The \hyperlink{structt__jit__matrix__info}{t\_\-jit\_\-matrix\_\-info} struct is listed below:


\begin{DoxyCode}
typedef struct _jit_matrix_info
{
   long      size;         // in bytes (0xFFFFFFFF=UNKNOWN)
   t_symbol   *type;         // primitive type
   long      flags;         // matrix flags: my data?, handle?
   long      dimcount;      // # of dimensions
   long      dim[JIT_MATRIX_MAX_DIMCOUNT]; // dimension sizes      
   long      dimstride[JIT_MATRIX_MAX_DIMCOUNT]; // in bytes
   long      planecount;      // # of planes
} t_jit_matrix_info;
\end{DoxyCode}


And here is an example of calling the getinfo method to fill out the \hyperlink{structt__jit__matrix__info}{t\_\-jit\_\-matrix\_\-info} struct: 
\begin{DoxyCode}
   // fill out matrix info structs for input and output      
   jit_object_method(in_matrix,_jit_sym_getinfo,&in_minfo);
   jit_object_method(out_matrix,_jit_sym_getinfo,&out_minfo);
\end{DoxyCode}
\hypertarget{chapter_jit_mopdetails_chapter_jit_mopdetails_data}{}\section{Retrieving the Data Pointer}\label{chapter_jit_mopdetails_chapter_jit_mopdetails_data}
The \hyperlink{structt__jit__matrix__info}{t\_\-jit\_\-matrix\_\-info} struct is the meta data, but the actual matrix data can be accessed by acquiring the data pointer. You accomplish this by calling the matrix's getdata method, passing in a pointer to a pointer. This pointer can be any type, but it is typically a char (or byte) pointer since you may need to perform bytewise pointer arithmetic depending on the type and dimstride of your matrix. It is essential to verify that this pointer is valid before attempting to operate on the data, as demonstrated below.


\begin{DoxyCode}
   // get matrix data pointers
   jit_object_method(in_matrix,_jit_sym_getdata,&in_bp);
   jit_object_method(out_matrix,_jit_sym_getdata,&out_bp);
   
   // if data pointers are invalid, set error, and cleanup
   if (!in_bp) { err=JIT_ERR_INVALID_INPUT; goto out;}
   if (!out_bp) { err=JIT_ERR_INVALID_OUTPUT; goto out;}
\end{DoxyCode}
\hypertarget{chapter_jit_mopdetails_chapter_jit_mopdetails_dataproc}{}\section{Processing the Data}\label{chapter_jit_mopdetails_chapter_jit_mopdetails_dataproc}
While it is possible to incorporate the data processing code inside the matrix\_\-calc method, it is typical to rely on other routines to accomplish the N dimensional processing through recursion, potentially dispatching to multiple processors. The N-\/dimensional recursive processing function (typically named myobject\_\-calculate\_\-ndim) is discussed in the next section. You should pass in to the calculate\_\-ndim function your object pointer, the overall dimension count, dimension sizes, planecount to consider in your calculation, together with the necessary matrix info structs and data pointers for each input and output. You can call this method directly as is the case in the following code:


\begin{DoxyCode}
   // call calculate_ndim function directly in current thread
   jit_scalebias_calculate_ndim(x, dimcount, dim, planecount, 
      &in_minfo, in_bp, &out_minfo, out_bp);
\end{DoxyCode}


Or you can call this method with the parallel processing utility functions provided with Jitter 1.5 to automatically dispatch the processing of large matrices across multiple processors when available. This figure illustrates the dispatching and calculating of the parallel processing utility:



The parallel processing is accomplished by breaking up the matrix into smaller matrices that each reference subregions of the original inputs and outputs. No new objects are created, but rather just additional \hyperlink{structt__jit__matrix__info}{t\_\-jit\_\-matrix\_\-info} structs and offset data pointers. Jitter 1.5 maintains a pool of worker threads for this purpose, so there is no thread creation overhead, but rather only some small thread synchronization overhead. Jitter 1.5 only dispatches across multiple threads when the data count is large enough to justify this thread synchronization overhead.

An important thing worth noting is that if your object performs some kind of spatial operation (e.g. convolution, rotation, scaling, etc.), you will either need to account for the matrix segmentation used by the parallel utilities or avoid using parallel processing and call directly in the current thread. Since the jit.scalebias example only processes one pixel at a time (i.e. a pointwise operation), it is inherently parallelizable, so it takes advantage of multiple processors as below:


\begin{DoxyCode}
   // calculate, using the parallel utility function to
   // call the calculate_ndim function in multiple
   // threads if there are multiple processors available
   jit_parallel_ndim_simplecalc2(
      (method)jit_scalebias_calculate_ndim,
      x, dimcount, dim, planecount, 
      &in_minfo, in_bp, &out_minfo, out_bp,
      0, 0 );
\end{DoxyCode}


Important Note: If you aren't sure if your object is a pointwise operator, or don't fully understand how to make your algorithm parallelizable, you shouldn't use the parallel utility functions in your object. You should simply call the function directly.\hypertarget{chapter_jit_mopdetails_chapter_jit_mopdetails_ndim}{}\section{Processing N-\/Dimensional Matrices}\label{chapter_jit_mopdetails_chapter_jit_mopdetails_ndim}
In the Matrix Operator Quick Start chapter, we discussed how to define a recursive function to process N-\/dimensional data in 2D slices, using the jit.scalebias object as an example. This example was restricted to processing four plane char data, but many Jitter objects work with any type of data and any plane count. In order to support all types and plane counts, there needs to be some case handling to know how to step through the data, and what type data to interpret as so that you can perform the appropriate operations. There are a number of ways to approach this logic, and decisions to make with respect to optimization. All this case handling can be a bit cumbersome, so when initially developing objects, it probably makes sense for you to focus on a single type and plane count, and only after you've adequately defined your operation, attempt to make your code robust to process any type of data and consider optimization of certain cases. The use of C macros, or C++ templates might be useful things to explore for better code re-\/use. As for code optimization, typically a decent atomic element to try and optimize is the \char`\"{}innermost\char`\"{} loop, avoiding branch conditions where possible.

This function is at the heart of the logic you will add in your own custom object. Since there is no \char`\"{}right way\char`\"{} to process this data, we won't cover any more code listings for the recursive N-\/dimensional processing function. However, the SDK projects that are good examples include: jit.clip, which performs a planar independent, pointwise operation (limiting numbers to some specified range); jit.rgb2luma, which performs a planar dependent, pointwise operation (converting RGB color to luminance); and jit.transpose, which performs a planar independent, spatial operation (rows become columns). For more ideas about N-\/dimensional matrix processing, we would recommend reading one of the several books available on 2D signal processing and/or image processing. Most of these concepts are easily generalized to higher dimensions.\hypertarget{chapter_jit_mopdetails_chapter_jit_mopdetails_mopwrapdef}{}\section{Defining the MOP Max Wrapper Class}\label{chapter_jit_mopdetails_chapter_jit_mopdetails_mopwrapdef}
MOP Max wrapper classes typically have a large amount of default behavior, as setup through the max\_\-jit\_\-classex\_\-mop\_\-wrap function, based on the jit\_\-mop Jitter class adornment, and user specified flags. You can either override all of the default behavior or just specific features. If you wish to override all of the default behavior, you can use the flag \hyperlink{group__jitter_ga60cbfeaf26417a8d6561fb9acce523d5}{MAX\_\-JIT\_\-MOP\_\-FLAGS\_\-OWN\_\-ALL}, when calling the \hyperlink{group__maxmopmod_ga7e08584771f58ce1fe0b190d27b5759b}{max\_\-jit\_\-classex\_\-mop\_\-wrap()} function. If you need to make use of the jit\_\-mop adornment(), the jit\_\-mop can be looked up by calling the \hyperlink{group__classmod_ga1b040b25876a0905f60683413ce34ae6}{jit\_\-class\_\-adornment\_\-get()} method on the Jitter class. The jit\_\-mop\_\-io inputs and outputs can be queried and their attributes inspected, similar to how they were set in the MOP Jitter class definition, described earlier in this chapter. Here is an example of how to look up the jit\_\-mop adornment of the jit.scalebias object:


\begin{DoxyCode}
   // look up jitter class by name
   jclass = jit_class_findbyname(gensym("jit_scalebias"));
   // look up jit_mop adornment 
   mop = jit_class_adornment_get(jclass,_jit_sym_jit_mop);
\end{DoxyCode}
\hypertarget{chapter_jit_mopdetails_chapter_jit_mopdetails_override}{}\section{Overriding the jit\_\-matrix Method}\label{chapter_jit_mopdetails_chapter_jit_mopdetails_override}
By default, a jit\_\-matrix method is added which automatically manages matrix copying and calculation based on the incoming data. Most typical MOPs simply use the default jit\_\-matrix method. However there are instances where it is necessary to override the default MOP method to get special behavior, such as recording which matrix input data is being input to as is the case for the jit.op SDK example, or to do something other than standard copying and adaptation as is the case for the jit.pack or jit.str.op SDK examples, or to prevent any jit\_\-matrix method at all, as is the case for the jit.noise SDK example. To prevent the default jit\_\-matrix method from being defined, you can use the flag \hyperlink{group__jitter_ga76b29cb7bf7f194cef194fb65df28ddd}{MAX\_\-JIT\_\-MOP\_\-FLAGS\_\-OWN\_\-JIT\_\-MATRIX}, when calling the \hyperlink{group__maxmopmod_ga7e08584771f58ce1fe0b190d27b5759b}{max\_\-jit\_\-classex\_\-mop\_\-wrap()} function. To define your own jit\_\-matrix method, you can add an \hyperlink{group__atom_gga8aa6700e9f00b132eb376db6e39ade47a81c1a8550f038db16a619167a70a79b6}{A\_\-GIMME} method bound to the symbol jit\_\-matrix, in your main function. Here's an example from jit.op:


\begin{DoxyCode}
   // add custom jit_matrix method in main()
   addmess((method)max_jit_op_jit_matrix, "jit_matrix", A_GIMME, 0);

   void max_jit_op_jit_matrix(t_max_jit_op *x, t_symbol *s, short argc,
               t_atom *argv)
   {
      if (max_jit_obex_inletnumber_get(x)) 
      {
         // if matrix is received in right input, 
         // record to override float or int input
         x->last = OP_LAST_MATRIX;
      }
      
      // now pass on to the default jit_matrix method 
      max_jit_mop_jit_matrix(x,s,argc,argv);
   }
\end{DoxyCode}


The jit.pack and jit.str.op examples are a bit more involved and also better illustrate the kinds of tasks the default jit\_\-matrix method performs.\hypertarget{chapter_jit_mopdetails_chapter_jit_mopdetails_overridebang}{}\section{Overriding the bang and outputmatrix Methods}\label{chapter_jit_mopdetails_chapter_jit_mopdetails_overridebang}
A MOP Max wrapper class typically has a bang and outputmatrix method. These two methods are typically equivalent, and by default, both send out the most recently calcuated matrix output. Certain objects that don't have a matrix output, like the jit.3m SDK example, typcially override these messages with their own bang and sometimes outputmatrix method. These methods can be overridden by using the \hyperlink{group__jitter_gae93fd085f28675389848233a82521942}{MAX\_\-JIT\_\-MOP\_\-FLAGS\_\-OWN\_\-BANG} and \hyperlink{group__jitter_ga7c51c91474bdbc40437dbd946df19cc5}{MAX\_\-JIT\_\-MOP\_\-FLAGS\_\-OWN\_\-OUTPUTMATRIX} flags when calling the \hyperlink{group__maxmopmod_ga7e08584771f58ce1fe0b190d27b5759b}{max\_\-jit\_\-classex\_\-mop\_\-wrap()} function. These flags are typically both passed in together.\hypertarget{chapter_jit_mopdetails_chapter_jit_mopdetails_overridemore}{}\section{Overriding the name, type, dim, and planecount Attributes}\label{chapter_jit_mopdetails_chapter_jit_mopdetails_overridemore}
For each input and output, other than the leftmost input, there is, by default, an attribute added to query and set that input or output's matrix attributes, including name, type, dim, and planecount. While overriding the default attribute behavior is conceivably necessary to perform very specialized behavior, it is not used by any of the SDK examples. To prevent the addition of the default attributes for name, type, dim, and planecount, you can use the \hyperlink{group__jitter_ga2da79e2f2413304655b66637eeff0326}{MAX\_\-JIT\_\-MOP\_\-FLAGS\_\-OWN\_\-NAME}, \hyperlink{group__jitter_gaf85d3bada9b15b7c5371e4cbeeffcaeb}{MAX\_\-JIT\_\-MOP\_\-FLAGS\_\-OWN\_\-TYPE}, \hyperlink{group__jitter_gaf138ee8c3a7120b8914c2e815ed013bd}{MAX\_\-JIT\_\-MOP\_\-FLAGS\_\-OWN\_\-DIM}, and \hyperlink{group__jitter_ga77553b6728bd9d5d6d18fe6e4d65a128}{MAX\_\-JIT\_\-MOP\_\-FLAGS\_\-OWN\_\-PLANECOUNT} flags when calling the \hyperlink{group__maxmopmod_ga7e08584771f58ce1fe0b190d27b5759b}{max\_\-jit\_\-classex\_\-mop\_\-wrap()} function. To define your own attributes, you would follow the same means of defining any attributes for a Max wrapper class with the appropriate attribute name you wish to override.\hypertarget{chapter_jit_mopdetails_chapter_jit_mopdetails_overrideclear}{}\section{Overriding the clear and notify Methods}\label{chapter_jit_mopdetails_chapter_jit_mopdetails_overrideclear}
By default, a clear and a notify method are added. The default clear method clears each of the input and output matrices. The default notify method, \hyperlink{group__maxmopmod_ga5032d682c77bcb7e2dcdf0e77d863d3c}{max\_\-jit\_\-mop\_\-notify()}, is called whenever any of the matrices maintained by the MOP are changed. If it is necessary to respond to additional notifications, it is important to call the max\_\-jit\_\-mop\_\-notify function so that the MOP can perform any necessary maintenance with respect to input and output matrices, as demonstrated by the jit.notify SDK example. These methods can be overridden using the \hyperlink{group__jitter_gaadd7ebf9b850b06496bdeb9414d181e4}{MAX\_\-JIT\_\-MOP\_\-FLAGS\_\-OWN\_\-CLEAR} and \hyperlink{group__jitter_ga669c2f28bba1dfb4181ebae8f19488bc}{MAX\_\-JIT\_\-MOP\_\-FLAGS\_\-OWN\_\-NOTIFY} flags, respectively, when calling the \hyperlink{group__maxmopmod_ga7e08584771f58ce1fe0b190d27b5759b}{max\_\-jit\_\-classex\_\-mop\_\-wrap()} function. Object registration and notification is covered in detail in a future chapter, but the jit.notify notify method is provided as an example.


\begin{DoxyCode}
// s is the servername, msg is the message, ob is the server object pointer, 
// and data is extra data the server might provide for a given message
void max_jit_notify_notify(
   t_max_jit_notify *x, t_symbol *s, t_symbol *msg, void *ob, void *data)
{
   if (msg==gensym("splat")) {
      post("notify: server=%s message=%s",s->s_name,msg->s_name);
      if (!data) {
         error("splat message NULL pointer");
         return;
      }
      // here's where we output using the rightmost outlet
      // we just happen to know that "data" points to a t_atom[3]
      max_jit_obex_dumpout(x,msg,3,(t_atom *)data); 
   } else {
      // pass on to the default Max MOP notification method 
      max_jit_mop_notify(x,s,msg);
   }
}
\end{DoxyCode}
\hypertarget{chapter_jit_mopdetails_chapter_jit_mopdetails_overrideadapt}{}\section{Overriding the adapt and outputmode Attributes}\label{chapter_jit_mopdetails_chapter_jit_mopdetails_overrideadapt}
By default, adapt and outputmode attributes are added to the MOP Max Wrapper. These attributes determine whether or not to adapt to incoming matrix attributes, and whether or not the output should calculate a new output matrix, output the last calculated matrix (freeze), pass on the input matrix (bypass). To prevent the addition of the default attributes for adapt and outputmode, you can use the \hyperlink{group__jitter_ga1c01c9fbad6e41293920117964654f61}{MAX\_\-JIT\_\-MOP\_\-FLAGS\_\-OWN\_\-ADAPT}, and \hyperlink{group__jitter_gadad1691bc68342a60441cb884a89129d}{MAX\_\-JIT\_\-MOP\_\-FLAGS\_\-OWN\_\-OUTPUTMODE} flags when calling the \hyperlink{group__maxmopmod_ga7e08584771f58ce1fe0b190d27b5759b}{max\_\-jit\_\-classex\_\-mop\_\-wrap()} function. To define your own attributes, you would follow the same means of defining any attributes for a Max wrapper class with the appropriate attribute name you wish to override.\hypertarget{chapter_jit_mopdetails_chapter_jit_mopdetails_mproc}{}\section{Defining an mproc Method}\label{chapter_jit_mopdetails_chapter_jit_mopdetails_mproc}
For many types of operations, it's not required to fully override the default jit\_\-matrix method and any adaptation. If your object simply needs to override the way in which the Jitter class' matrix\_\-calc method and outlet functions are called, you can do so by defining an mproc method, which will be called instead of the default behavior. The jit.3m SDK project is an example where after it calls the Jitter class' matrix\_\-calc method, it queries the Jitter class' attributes and outputs max messages rather than the default jit\_\-matrix message output.


\begin{DoxyCode}
void max_jit_3m_mproc(t_max_jit_3m *x, void *mop)
{
   t_jit_err err;
   
   // call internal Jitter object's matrix_calc method
   if (err=(t_jit_err) jit_object_method(
      max_jit_obex_jitob_get(x),
      _jit_sym_matrix_calc,
      jit_object_method(mop,_jit_sym_getinputlist),
      jit_object_method(mop,_jit_sym_getoutputlist))) 
   {
      // report error if present
      jit_error_code(x,err); 
   } else {
      // query Jitter class and makes outlet calls
      max_jit_3m_bang(x);
   }
}
\end{DoxyCode}
\hypertarget{chapter_jit_mopdetails_chapter_jit_mopdetails_maxclassctor}{}\section{The Max Class Constructor/Destructor}\label{chapter_jit_mopdetails_chapter_jit_mopdetails_maxclassctor}
As we discussed in the Matrix Operator Quick Start, inside your Max class' constructor you need to allocate the matrices necessary for the MOP inputs and outputs, the corresponding matrix inlets and outlets, process matrix arguments and other MOP setup. And in your destructor, you need to free oup MOP resources. Typically you would accomplish this all with the standard \hyperlink{group__maxmopmod_gac3eaca207281516b72e81f0dc5f4bf94}{max\_\-jit\_\-mop\_\-setup\_\-simple()} and \hyperlink{group__maxmopmod_ga441ff70d705e1eccff8297437c85e46c}{max\_\-jit\_\-mop\_\-free()} functions, however there are some instances where you may need to introduce custom behavior.\hypertarget{chapter_jit_mopdetails_chapter_jit_mopdetails_maxclassctor_vario}{}\subsection{Variable Inputs/Outputs}\label{chapter_jit_mopdetails_chapter_jit_mopdetails_maxclassctor_vario}
The \hyperlink{group__maxmopmod_gac3eaca207281516b72e81f0dc5f4bf94}{max\_\-jit\_\-mop\_\-setup\_\-simple()} function calls \hyperlink{group__maxmopmod_gaec99be7b60c1cec6a8391097d5008bc6}{max\_\-jit\_\-mop\_\-inputs()} and \hyperlink{group__maxmopmod_ga07f044bc4c7fe4380f31e150844948df}{max\_\-jit\_\-mop\_\-outputs()} to define any necessary proxy inlets, outlets, and internal matrices. The listing for these functions are provided below to illustrate the default behavior, and a few SDK projects we recommend investigating further are jit.scissors, jit.glue, jit.pack, and jit.unpack.


\begin{DoxyCode}
t_jit_err max_jit_mop_inputs(void *x)
{
   void *mop,*p,*m;
   long i,incount;
   t_jit_matrix_info info;
   t_symbol *name;
   
   // look up object's MOP adornment
   if (x&&(mop=max_jit_obex_adornment_get(x,_jit_sym_jit_mop))) 
   {
      incount  = jit_attr_getlong(mop,_jit_sym_inputcount);
      
      // add proxy inlet and internal matrix for
      // all inputs except leftmost inlet 
      for (i=2;i<=incount;i++) {
         max_jit_obex_proxy_new(x,(incount+1)-i); // right to left
         if (p=jit_object_method(mop,_jit_sym_getinput,i)) {
            jit_matrix_info_default(&info);
            max_jit_mop_restrict_info(x,p,&info);
            name = jit_symbol_unique();
            m = jit_object_new(_jit_sym_jit_matrix,&info);
            m = jit_object_register(m,name);
            jit_attr_setsym(p,_jit_sym_matrixname,name);
            jit_object_method(p,_jit_sym_matrix,m);
            jit_object_attach(name, x);
         }
      }   
      return JIT_ERR_NONE;
   } 
   return JIT_ERR_INVALID_PTR;
}

t_jit_err max_jit_mop_outputs(void *x)
{
   void *mop,*p,*m;
   long i,outcount;
   t_jit_matrix_info info;
   t_symbol *name;

   if (x&&(mop=max_jit_obex_adornment_get(x,_jit_sym_jit_mop))) 
   {
      outcount = jit_attr_getlong(mop,_jit_sym_outputcount);

      // add outlet and internal matrix for all outputs
      for (i=1;i<=outcount;i++) {
         max_jit_mop_matrixout_new(x,(outcount)-i);// right to left
         if (p=jit_object_method(mop,_jit_sym_getoutput,i)) {
            jit_matrix_info_default(&info);
            max_jit_mop_restrict_info(x,p,&info);
            name = jit_symbol_unique();
            m = jit_object_new(_jit_sym_jit_matrix,&info);
            m = jit_object_register(m,name);
            jit_attr_setsym(p,_jit_sym_matrixname,name);
            jit_object_method(p,_jit_sym_matrix,m);
            jit_object_attach(name, x);
         }
      }

      return JIT_ERR_NONE;
   } 
   return JIT_ERR_INVALID_PTR;
}
\end{DoxyCode}
\hypertarget{chapter_jit_mopdetails_chapter_jit_mopdetails_maxclassctor_matargs}{}\subsection{Matrix Arguments}\label{chapter_jit_mopdetails_chapter_jit_mopdetails_maxclassctor_matargs}
The \hyperlink{group__maxmopmod_gac3eaca207281516b72e81f0dc5f4bf94}{max\_\-jit\_\-mop\_\-setup\_\-simple()} function calls \hyperlink{group__maxmopmod_ga75f7f306602775484eaa1b3f9d3998f3}{max\_\-jit\_\-mop\_\-matrix\_\-args()} to read any matrix arguments, and if present send them to any linked inputs/outputs and disable the adapt attribute. The listing is provided below to illustrate the default behavior.


\begin{DoxyCode}
t_jit_err max_jit_mop_matrix_args(void *x, long argc, t_atom *argv)
{
   void *mop,*p,*m;
   long incount,outcount,attrstart,i,j;
   t_jit_matrix_info info,info2;
      
   if (!(mop=max_jit_obex_adornment_get(x,_jit_sym_jit_mop)))
      return JIT_ERR_GENERIC;

   incount  = jit_attr_getlong(mop,_jit_sym_inputcount);
   outcount = jit_attr_getlong(mop,_jit_sym_outputcount);
   
   jit_matrix_info_default(&info);
   
   attrstart = max_jit_attr_args_offset(argc,argv);
   if (attrstart&&argv) {
      jit_atom_arg_getlong(&info.planecount, 0, attrstart, argv);
      jit_atom_arg_getsym(&info.type, 1, attrstart, argv);
      i=2; j=0;
      while (i<attrstart) { //dimensions
         jit_atom_arg_getlong(&(info.dim[j]), i, attrstart, argv);
         i++; j++;
      }
      if (j) info.dimcount=j;
      
      jit_attr_setlong(mop,_jit_sym_adapt,0); //adapt off
   }
   
   jit_attr_setlong(mop,_jit_sym_outputmode,1); 
      
   for (i=2;i<=incount;i++) {
      if ((p=jit_object_method(mop,_jit_sym_getinput,i)) &&
         (m=jit_object_method(p,_jit_sym_getmatrix)))
      {
         jit_object_method(m,_jit_sym_getinfo,&info2);
         if (jit_attr_getlong(p,_jit_sym_typelink)) {
            info2.type = info.type;
         }
         if (jit_attr_getlong(p,_jit_sym_planelink)) {
            info2.planecount = info.planecount;
         }
         if (jit_attr_getlong(p,_jit_sym_dimlink)) {
            info2.dimcount = info.dimcount;
            for (j=0;j<info2.dimcount;j++) {
               info2.dim[j] = info.dim[j];
            }
         }
         max_jit_mop_restrict_info(x,p,&info2);
         jit_object_method(m,_jit_sym_setinfo,&info2);
      }
   }

   for (i=1;i<=outcount;i++) {
      if ((p=jit_object_method(mop,_jit_sym_getoutput,i)) &&
         (m=jit_object_method(p,_jit_sym_getmatrix)))
      {
         jit_object_method(m,_jit_sym_getinfo,&info2);
         if (jit_attr_getlong(p,_jit_sym_typelink)) {
            info2.type = info.type;
         }
         if (jit_attr_getlong(p,_jit_sym_planelink)) {
            info2.planecount = info.planecount;
         }
         if (jit_attr_getlong(p,_jit_sym_dimlink)) {
            info2.dimcount = info.dimcount;
            for (j=0;j<info2.dimcount;j++) {
               info2.dim[j] = info.dim[j];
            }
         }
         max_jit_mop_restrict_info(x,p,&info2);
         jit_object_method(m,_jit_sym_setinfo,&info2);
      }
   }
      
   return JIT_ERR_NONE;
}
\end{DoxyCode}
 