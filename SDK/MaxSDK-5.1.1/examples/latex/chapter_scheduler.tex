The Max scheduler permits operations to be delayed until a later time.

It keeps track of time in double-\/precision, but the resolution of the scheduler depends on the user's environment preferences. The scheduler also works in conjunction with a low-\/priority queue, which permits time-\/consuming operations that might be initiated inside the scheduler to be executed in a way that does not disrupt timing accuracy.

Most objects interface with the scheduler via a clock (\hyperlink{group__clocks_ga09c0580122113b4db2517ff8e7c8b0f2}{t\_\-clock}) object. A clock is associated with a task function that will execute when the scheduler's current time reaches the clock's time. There is also a function called \hyperlink{group__threading_ga1eb8ec7623f0806dd079d7be708c19a8}{schedule()} that can be used for one-\/off delayed execution of a function. It creates a clock to do its job however, so if your object is going to be using the scheduler repeatedly, it is more efficient to store references to the clocks it creates so the clocks can be reused.

The scheduler is periodically polled to see if it needs to execute clock tasks. There are numerous preferences Max users can set to determine when and how often this polling occurs. Briefly:


\begin{DoxyItemize}
\item The Overdrive setting determines whether scheduler polling occurs in a high-\/prority timer thread or the main thread
\item The Interval setting determines the number of milliseconds elapse between polling the scheduler
\item The Throttle setting determines how many tasks can be executed in any particular scheduler poll
\end{DoxyItemize}

Similar Throttle and Interval settings exist for the low-\/priority queue as well.

For more information refer to the \hyperlink{group__sched}{Timing} documentation. While the details might be a little overwhelming on first glance, the important point is that the exact time your scheduled task will execute is subject to variability. Max permits this level of user control over the scheduler to balance all computational needs for a specific application.\hypertarget{chapter_scheduler_chapter_scheduler_clocks}{}\section{Creating and Using Clocks}\label{chapter_scheduler_chapter_scheduler_clocks}
There are five steps to using a clock in an external object.

1. Add a member to your object's data structure to hold a pointer to the clock object 
\begin{DoxyCode}
    typedef struct _myobject
    {
        t_object m_obj;
    
        void *m_clock;
    } t_object;
\end{DoxyCode}


2. Write a task function that will do something when the clock is executed. The function has only a single argument, a pointer to your object. The example below gets the current scheduler time and prints it.


\begin{DoxyCode}
    void myobject_task(t_myobject *x)
    {
        double time;

        sched_getftime(&time);
        post("instance %lx is executing at time %.2f", x, time);
    }
\end{DoxyCode}


3. In your new instance routine, create the clock (passing a pointer to your object and the task function) and store the result in your object's data structure. 
\begin{DoxyCode}
        x->m_clock = clock_new((t_object *)x, (method)myobject_task);
\end{DoxyCode}


4. Schedule your clock. Use \hyperlink{group__clocks_ga61719f0e0379fffbe79ae2bd5699b66f}{clock\_\-fdelay()} to schedule the clock in terms of a delay from the current time. Below we schedule the clock to execute 100 milliseconds from now. 
\begin{DoxyCode}
        clock_fdelay(x->m_clock, 100.);
\end{DoxyCode}


If you want to cancel the execution of a clock for some reason, you can use \hyperlink{group__clocks_ga64f5f8a027b39c1c14464744a9cc08ce}{clock\_\-unset()}. 
\begin{DoxyCode}
        clock_unset(x->m_clock);
\end{DoxyCode}


5. In your object's free routine, free the clock 
\begin{DoxyCode}
        object_free(x->m_clock);
\end{DoxyCode}


Note that if you call \hyperlink{group__clocks_ga9ac56d198904627333de740743086920}{clock\_\-delay()} on a clock that is already set, its execution time will be changed. It won't execute twice.\hypertarget{chapter_scheduler_chapter_scheduler_qelems}{}\section{Creating and Using Qelems}\label{chapter_scheduler_chapter_scheduler_qelems}
A qelem (\char`\"{}queue element\char`\"{}) is used to ensure that an operation occurs in the low-\/priority thread. The task function associated with a \hyperlink{group__qelems_ga4d219449d88d2b9648a992152b278090}{t\_\-qelem} is executed when the low-\/priority queue is serviced, always in the main (user interface) thread. Any qelem that is \char`\"{}set\char`\"{} belongs to the low-\/priority queue and will be executed as soon as it serviced.

There are two principal things you want to avoid in the high priority thread: first, time-\/consuming or unpredictable operations such as file access, and second, anything that will block execution for any length of time -\/-\/ for example, showing a dialog box (including a file dialog).

The procedure for using a qelem is analogous to that for using a clock.

1. Add a member to your object's data structure to hold a pointer to the qelem 
\begin{DoxyCode}
    typedef struct _myobject
    {
        t_object m_obj;
    
        void *m_qelem
    } t_myobject;
\end{DoxyCode}


2. Write a task function that will do something when the qelem is executed. The function has only a single argument, a pointer to your object. 
\begin{DoxyCode}
    void myobject_qtask(t_myobject *x)
    {
        post("I am being executed a low priority!"
    }
\end{DoxyCode}


3. In your new instance routine, create the qelem (passing a pointer to your object and the task function) and store the result in your object's data structure. 
\begin{DoxyCode}
        x->m_qelem = qelem_new((t_object *)x, (method)myobject_qtask);
\end{DoxyCode}


4. Set the qelem by using \hyperlink{group__qelems_ga3e292aad133af89a87e167e88cc4a1b5}{qelem\_\-set()}. You could, for example, call \hyperlink{group__qelems_ga3e292aad133af89a87e167e88cc4a1b5}{qelem\_\-set()} in a clock task function or in direct response to a message such as bang or int. 
\begin{DoxyCode}
        qelem_set(x->m_qelem);
\end{DoxyCode}


If you want to cancel the execution of a qelem for some reason, you can use \hyperlink{group__qelems_ga021eca2eff6e47ff97ca112fb2eaf866}{qelem\_\-unset()}. 
\begin{DoxyCode}
        qelem_unset(x->m_qelem);
\end{DoxyCode}


5. In your object's free routine, call \hyperlink{group__qelems_ga7cfcb3134eb0baf335847906a14a08d0}{qelem\_\-free()}. Do not call \hyperlink{group__obj_ga3759846cb356195532c41e35b87522ee}{object\_\-free()} or \hyperlink{group__class__old_gadf30646e52376a37b93cc20efac65636}{freeobject()} -\/-\/ unlike the clock, the qelem is not an object. 
\begin{DoxyCode}
        qelem_free(x->m_qelem);
\end{DoxyCode}


Note that if you call \hyperlink{group__qelems_ga3e292aad133af89a87e167e88cc4a1b5}{qelem\_\-set()} on a qelem that is already set, it won't execute twice. This is a feature, not a bug, as it permits you to execute a low-\/priority task only as fast as the low-\/priority queue operates, not at the high-\/priority rate that the task might be triggered. An example would be that a number box will redraw more slowly than a counter that changes its value. This is not something you need to worry about, even if you are writing UI objects, as Max handles it internally (using a qelem).\hypertarget{chapter_scheduler_chapter_scheduler_defer}{}\section{Defer}\label{chapter_scheduler_chapter_scheduler_defer}
The defer function and its variants use a qelem to ensure that a function executes at low-\/priority. There are three variants: \hyperlink{group__threading_gaa24a0c9896f1ad241e45590065c3f643}{defer()}, \hyperlink{group__threading_ga486daa40ddb16f70b663615695d18315}{defer\_\-low()}, and defer\_\-medium(). The difference between using \hyperlink{group__threading_gaa24a0c9896f1ad241e45590065c3f643}{defer()} and a qelem is that \hyperlink{group__threading_gaa24a0c9896f1ad241e45590065c3f643}{defer()} is a one-\/shot deal -\/-\/ it creates a qelem, sets it, and then gets rid of it when the task function has executed. The effect of this is that if you have some rapid high-\/priority event that needs to trigger something to happen at low-\/priority, \hyperlink{group__threading_gaa24a0c9896f1ad241e45590065c3f643}{defer()} will ensure that this low-\/priority task happens every time the high-\/priority event occurs (in a 1:1 ratio), whereas using a qelem will only run the task at a rate that corresponds to the service interval of the low-\/priority queue. If you repeatedly \hyperlink{group__threading_gaa24a0c9896f1ad241e45590065c3f643}{defer()} something too rapidly, the low-\/priority queue will become backlogged and the responsiveness of the UI will suffer.

A typical use of \hyperlink{group__threading_gaa24a0c9896f1ad241e45590065c3f643}{defer()} is if your object implements a read message to ask the user for a file. Opening the dialog in the timer thread and waiting for user input will likely crash, but even if it didn't, the scheduler would effectively stop.

To use \hyperlink{group__threading_gaa24a0c9896f1ad241e45590065c3f643}{defer()}, you write a deferred task function that will execute at low priority. The function will be passed a pointer to your object, plus a symbol and atom list modeled on the prototype for an anything method. You need not pass any arguments to the deferred task if you don't need them, however.


\begin{DoxyCode}
    void myobject_deferredtask(t_myobject *x, t_symbol *s, long argc, t_atom *arg
      v)
    {
        post("I am deferred");
    }
\end{DoxyCode}


To call the task, use \hyperlink{group__threading_gaa24a0c9896f1ad241e45590065c3f643}{defer()} as shown below. The first example passes no arguments. The second passes a couple of long atoms. 
\begin{DoxyCode}
        defer((t_object *)x, (method)myobject_deferredtask, NULL, 0, NULL);

        t_atom av[2];

        atom_setlong(av, 1);
        atom_setlong(av+ 2, 74);

        defer((t_object *)x, (method)myobject_deferredtask, NULL, 2, av);
\end{DoxyCode}


Defer copies any atoms you pass to newly allocated memory, which it frees when the deferred task has executed.\hypertarget{chapter_scheduler_chapter_scheduler_defer_variants}{}\subsection{Defer Variants}\label{chapter_scheduler_chapter_scheduler_defer_variants}
defer has two variants, \hyperlink{group__threading_ga486daa40ddb16f70b663615695d18315}{defer\_\-low()} and defer\_\-medium(). Here is a comparison:

\hyperlink{group__threading_gaa24a0c9896f1ad241e45590065c3f643}{defer()}

If executing at high priority, \hyperlink{group__threading_gaa24a0c9896f1ad241e45590065c3f643}{defer()} puts the deferred task at the front of the low-\/priority queue. If not executing at highpriority, \hyperlink{group__threading_gaa24a0c9896f1ad241e45590065c3f643}{defer()} calls the deferred task immediately.

\hyperlink{group__threading_ga486daa40ddb16f70b663615695d18315}{defer\_\-low()}

At all priority levels, \hyperlink{group__threading_ga486daa40ddb16f70b663615695d18315}{defer\_\-low()} puts the deferred task at the back of the low-\/priority queue.

defer\_\-medium()

If executing at high priority, defer\_\-medium() puts the deferred task at the back of the low-\/priority queue. If not executing at high priority, defer\_\-medium() calls the deferred task immediately.\hypertarget{chapter_scheduler_chapter_scheduler_sechedule}{}\section{Schedule}\label{chapter_scheduler_chapter_scheduler_sechedule}
The \hyperlink{group__threading_ga1eb8ec7623f0806dd079d7be708c19a8}{schedule()} function is to clocks as \hyperlink{group__threading_gaa24a0c9896f1ad241e45590065c3f643}{defer()} is to qelems. Schedule creates a clock for a task function you specify and calls \hyperlink{group__clocks_ga61719f0e0379fffbe79ae2bd5699b66f}{clock\_\-fdelay()} on it to make the task execute at a desired time. As with \hyperlink{group__threading_gaa24a0c9896f1ad241e45590065c3f643}{defer()}, \hyperlink{group__threading_ga1eb8ec7623f0806dd079d7be708c19a8}{schedule()} can copy arguments to be delivered to the task when it executes.

A \hyperlink{group__threading_ga1eb8ec7623f0806dd079d7be708c19a8}{schedule()} variant, schedule\_\-defer(), executes the task function at low priority after a specified delay. 