<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
		<title>Max5 API Reference</title>
		<link href="c74-doxygen.css" rel="stylesheet" type="text/css">
	</head>
	<body>

		<div id="c74header">
			<img src="max5.png" />
			<p>Max 5 API Reference</p>
		</div>

<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="chapter_jit_networking">Jitter Networking Specification </a></h1><p>This appendix describes the format of the data sent by a jit.net.send object.</p>
<p>The object attempts to form a TCP connection with a host at the IP and port specified by the object's attributes. Any program wishing to receive data will therefore have to set itself up as a host and listen for incoming TCP connections.</p>
<p>Once a connection is formed, data can be sent. Data is sent as a stream of chunks. The first thing received will be a chunk header. It consists of a 32-bit chunk ID and a 32-bit int representing the size of the next chunk to come. The chunk ID can be one of the following 4-char symbols, depending on what kind of packet it is:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#define JIT_MATRIX_PACKET_ID  &apos;JMTX&apos;</span>
<span class="preprocessor"></span><span class="preprocessor">#define JIT_MATRIX_LATENCY_PACKET_ID  &apos;JMLP&apos;</span>
<span class="preprocessor">#define JIT_MESSAGE_PACKET_ID  &apos;JMMP&apos;</span>
</pre></div><p>This chunk header could be represented in C by the following struct: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> <span class="keyword">struct </span>_jit_net_packet_header
{
   <span class="keywordtype">long</span> id;
   <span class="keywordtype">long</span> size; <span class="comment">//size of packet to come</span>
} t_jit_net_packet_header;
</pre></div><p>If the chunk is a matrix packet, the next data received will be a header of 288 bytes with the following contents:</p>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><p>id </p>
</td><td><p>'JMTX'  </p>
</td></tr>
<tr>
<td><p>Size </p>
</td><td><p>288 (32-bit int, size of this header)  </p>
</td></tr>
<tr>
<td><p>Planecount </p>
</td><td><p>32-bit int  </p>
</td></tr>
<tr>
<td><p>Type </p>
</td><td><p>32-bit int, 0 for char, 1 for long, 2 for float32, 3 for float64  </p>
</td></tr>
<tr>
<td><p>Dimcount </p>
</td><td><p>32-bit int  </p>
</td></tr>
<tr>
<td><p>Dim </p>
</td><td><p>Array of 32 32-bit ints  </p>
</td></tr>
<tr>
<td><p>Dimstride </p>
</td><td><p>Array of 32 32-bit ints  </p>
</td></tr>
<tr>
<td><p>Datasize </p>
</td><td><p>32-bit int, size of the data buffer to come  </p>
</td></tr>
<tr>
<td><p>Time </p>
</td><td><p>64-bit double precision float  </p>
</td></tr>
</table>
<p>This chunk could be represented with the following C struct:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> <span class="keyword">struct </span>_jit_net_packet_matrix 
{
   <span class="keywordtype">long</span>   id;
   <span class="keywordtype">long</span>   size;
   <span class="keywordtype">long</span>   planecount;
   <span class="keywordtype">long</span>   type;         <span class="comment">//0=char,1=long,2=float32,3=float64</span>
   <span class="keywordtype">long</span>   dimcount;
   <span class="keywordtype">long</span>   dim[<a class="code" href="group__jitter.html#ga3a74bc72df454ac5618a865fd3c56870" title="maximum dimension count">JIT_MATRIX_MAX_DIMCOUNT</a>];
   <span class="keywordtype">long</span>   dimstride[<a class="code" href="group__jitter.html#ga3a74bc72df454ac5618a865fd3c56870" title="maximum dimension count">JIT_MATRIX_MAX_DIMCOUNT</a>];
   <span class="keywordtype">long</span>   datasize;
   <span class="keywordtype">double</span>   time;

} t_jit_net_packet_matrix;
</pre></div><p>Following this header the next data received will be the matrix data, the size of which was passed in the above header. When using the data, please note the dimstrides transmitted in the header.</p>
<p>The time field in the above header will be set to the time of transmission from the sending computer. jit.net.send expects the server to respond by sending back timing data of its own â€“ it uses this data to estimate the transmission latency. The exact data in the latency chunk that jit.net.send expects to receive is the following:</p>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><p>id </p>
</td><td><p>'JMLP'  </p>
</td></tr>
<tr>
<td><p>client_time_original </p>
</td><td><p>64-bit double, the time value received in the matrix header packet  </p>
</td></tr>
<tr>
<td><p>server_time_before_data </p>
</td><td><p>64-bit double, the time on the server when the packet header is received  </p>
</td></tr>
<tr>
<td><p>server_time_after_data </p>
</td><td><p>64-bit double, the time on the server after the packet has been processed and is in use  </p>
</td></tr>
<tr>
<td><p></p>
</td></tr>
</table>
<p>This chunk can be represnted by the following C struct:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> <span class="keyword">struct </span>_jit_net_packet_latency
{
   <span class="keywordtype">long</span> id;
   <span class="keywordtype">double</span> client_time_original;
   <span class="keywordtype">double</span> server_time_before_data; 
   <span class="keywordtype">double</span> server_time_after_data;
} t_jit_net_packet_latency;
</pre></div><p>The difference between the server time before and server time after processing the data represents the time it takes the server to mobilize the data after it has been received. jit.net.send will send and expects to receive time in milliseconds. When this timing information is received by the transmitting computer, it notes its current time, calculates the round trip time and then estimates the latency as half the round trip time plus half of the server processing time. This estimate is accurate if the time of flight from A to B is the same as the time of flight from B to A, but network topology can be very complicated, and often the route from A to B is not the reverse of the route from B to A. In simple situations, such as a direct connection between two computers or a small LAN, the estimate should be reasonably accurate.</p>
<p>Finally, the last type of packet that can be sent is the message packet. The size of the message packet is sent in the initial header packet. Standard <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a81c1a8550f038db16a619167a70a79b6" title="request that args be passed as an array, the routine will check the types itself...">A_GIMME</a> messages (<a class="el" href="structt__symbol.html" title="The symbol.">t_symbol</a> *s, long ac, <a class="el" href="structt__atom.html" title="An atom is a typed datum.">t_atom</a> *av) are serialized starting with a 32-bit integer that contains the size of the serialized message in bytes. Following that another 32-bit integer gives the argument count for the atoms. Following that comes the message atoms themselves, starting with the leading symbol if it exists. Each atom is represented in memory first with a char that indicates what type of atom it is: 's' for symbol, 'l' for long, and 'f' for float. For long and float atoms, the next 4 bytes contain the value of the atom; for symbol atoms a null terminated character string follows. Below is a C function that will deserialize a message passed in as a data pointer.</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> gimme_deserialize(<span class="keywordtype">char</span> *data, <a class="code" href="structt__symbol.html" title="The symbol.">t_symbol</a> **s, <span class="keywordtype">long</span> *ac, <a class="code" href="structt__atom.html" title="An atom is a typed datum.">t_atom</a> **av)
{
   <span class="keywordtype">char</span> *curr = data;
   <span class="keywordtype">float</span> *currf;
   <span class="keywordtype">long</span> *currl,i;
   <span class="keywordtype">long</span> datasize = BE_I32(*((<span class="keywordtype">long</span> *)curr));
   curr += <span class="keyword">sizeof</span>(long);   
   *ac = BE_I32(*(<span class="keywordtype">long</span> *)(curr));
   curr += <span class="keyword">sizeof</span>(long);
   *av = (<a class="code" href="structt__atom.html" title="An atom is a typed datum.">t_atom</a> *)<a class="code" href="group__memory.html#ga276676be214edff9fe5c9d0681f39ae6" title="Allocate memory.">sysmem_newptr</a>(<span class="keyword">sizeof</span>(<a class="code" href="structt__atom.html" title="An atom is a typed datum.">t_atom</a>)*(*ac));

   <span class="keywordflow">if</span> (*curr == ATOM_SERIALIZATION_SYMBOL_CODE)
   {
      curr++;
      *s = <a class="code" href="group__symbol.html#ga8268797d125a15bae1010af70b559e05" title="Given a C-string, fetch the matching t_symbol pointer from the symbol table, generating...">gensym</a>(curr);
      <span class="keywordflow">while</span> (*(++curr) != <span class="charliteral">&apos;\0&apos;</span>) ;
      curr++;
   }
   <span class="keywordflow">else</span>
      *s = 0L;
   <span class="keywordflow">for</span> (i=0;i&lt;*ac;i++)
      <span class="keywordflow">switch</span> (*curr++)
      {
         <span class="keywordflow">case</span> ATOM_SERIALIZATION_SYMBOL_CODE:
            (*av)[i].a_type = <a class="code" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a2d661c2a5d949566e2f1944c99bceeea" title="t_symbol pointer">A_SYM</a>;
            (*av)[i].a_w.w_sym = <a class="code" href="group__symbol.html#ga8268797d125a15bae1010af70b559e05" title="Given a C-string, fetch the matching t_symbol pointer from the symbol table, generating...">gensym</a>(curr);
            <span class="keywordflow">while</span> (*(++curr) != <span class="charliteral">&apos;\0&apos;</span>) ;
            curr++;
            <span class="keywordflow">break</span>;
         <span class="keywordflow">case</span> ATOM_SERIALIZATION_FLOAT_CODE:
            (*av)[i].a_type = <a class="code" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a0b3aa0ab8104573dfc9cb70b5b08031f" title="32-bit float">A_FLOAT</a>;
            (*av)[i].a_w.w_float = BE_F32(*((<span class="keywordtype">float</span> *)curr));
            curr += <span class="keyword">sizeof</span>(float);
            <span class="keywordflow">break</span>;
         <span class="keywordflow">case</span> ATOM_SERIALIZATION_LONG_CODE:
            (*av)[i].a_type = <a class="code" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a002f28879581a6f66ea492b994b96f1e" title="long integer">A_LONG</a>;
            (*av)[i].a_w.w_long = BE_I32(*((<span class="keywordtype">long</span> *)curr));
            curr += <span class="keyword">sizeof</span>(long);
            <span class="keywordflow">break</span>;
      }
}
</pre></div> </div>
		<div id="c74footer">
			<p>Copyright &copy; 2008, <a href="http://www.cycling74.com/">Cycling '74</a></p>
		</div>
	</body>
</html>
