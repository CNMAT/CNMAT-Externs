<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
		<title>Max5 API Reference</title>
		<link href="c74-doxygen.css" rel="stylesheet" type="text/css">
	</head>
	<body>

		<div id="c74header">
			<img src="max5.png" />
			<p>Max 5 API Reference</p>
		</div>

<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="chapter_itm">ITM </a></h1><p>ITM is the tempo-based timing system introduced with Max 5.</p>
<p>It allows users to express time in tempo-relative units as well as milliseconds, samples, and an ISO 8601 hour-minute-second format. In addition, ITM supports one or more transports, which can be synchronized to external sources. An ITM-aware object can schedule events to occur when the transport reaches a specific time, or find out the current transport state.</p>
<p>The ITM API is provided on two different levels. The time object (<a class="el" href="group__time.html#gab568d2ffd4d84ca17c0b90cf2f7c6a40" title="A high-level time object for tempo-based scheduling.">t_timeobject</a>) interface provides a higher-level way to parse time format information and schedule events. In addition, you can use lower-level routines to access ITM objects (<a class="el" href="group__time.html#gac656fa1f920c69cf77e6631bcec53077" title="A low-level object for tempo-based scheduling.">t_itm</a>) directly. An ITM object is responsible for maintaining the current time and scheduling events. There can be multiple ITM objects in Max, each running independently of the others.</p>
<h2><a class="anchor" id="chapter_itm_temp">
Scheduling Temporary Events</a></h2>
<p>There are two kinds of events in ITM. Temporary events are analogous to Max clock objects in that they are scheduled and fire at a dynamically assigned time. Once they have executed, they are removed from the scheduler. Permanent events always fire when the transport reaches a specific time, and are not removed from the scheduler. The ITM-aware metro is an example of an object that uses temporary events, while the timepoint object uses permanent events. We'll show how to work both types using an example included in the SDK called delay2. The existing Max delay object provides this capability, but this example shows most of the things you can do with the time object interface. To see the complete object, look at the <a href="delay2_8c-source.html">delay2 example</a>. We'll introduce a simpler version of the object, then proceed to add the quantization and the additional outlet that generates a delayed bang based on low-level ITM calls.</p>
<p>The ITM time object API is based on a Max object you create that packages up common ways you will be using ITM, including attribute support, quantization, and, if you want it, the ability to switch between traditional millisecond-based timing and tempo-based timing using an interface that is consistent with the existing Max objects such as metro and delay. (If you haven't familiarized yourself with attributes, you may want to read through the discussion about them in <a class="el" href="group__attr.html">Attributes</a> before reading further.)</p>
<p>To use the time object, you'll first need to provide some space in your object to hold a pointer to the object(s) you'll be creating.</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">typedef</span> <span class="keyword">struct </span>_delay2simple
    {
        <a class="code" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or...">t_object</a> m_ob;
        <a class="code" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or...">t_object</a> *m_timeobj;
        <span class="keywordtype">void</span> *m_outlet;
    } _delay2simple;
</pre></div><p>Next, in your main routine, you'll create attributes associated with the time object using the <a class="el" href="group__time.html#ga95e5b2330715823c8a609ccd500aa361" title="Create an attribute permitting a time object to be changed in a user-friendly way...">class_time_addattr()</a> function. </p>
<div class="fragment"><pre class="fragment">        <a class="code" href="group__time.html#ga95e5b2330715823c8a609ccd500aa361" title="Create an attribute permitting a time object to be changed in a user-friendly way...">class_time_addattr</a>(c, <span class="stringliteral">&quot;delaytime&quot;</span>, <span class="stringliteral">&quot;Delay Time&quot;</span>, <a class="code" href="group__time.html#gga99fb83031ce9923c84392b4e92f956b5af93981eb3922895394877d099323a2e8" title="only ticks-based values (not ms) are acceptable">TIME_FLAGS_TICKSONLY</a> | <a class="code" href="group__time.html#gga99fb83031ce9923c84392b4e92f956b5a91f2cee835f5cf871a657101b6ff7b4e" title="this time object will schedule events, not just hold a value">TIME_FLAGS_USECLOCK</a> | <a class="code" href="group__time.html#gga99fb83031ce9923c84392b4e92f956b5a7ddd9e0fa3dc6a7b346fc3dcee5c5c81" title="add a transport attribute">TIME_FLAGS_TRANSPORT</a>);
</pre></div><p>The second argument, "delaytime", is a string that names the attribute. Users of your object will be able to change the delay value by sending a delaytime message. "Delay Time" is the label users see for the attribute in the inspector. The flags argument permits you to customize the type of time object you'd like. <a class="el" href="group__time.html#gga99fb83031ce9923c84392b4e92f956b5af93981eb3922895394877d099323a2e8" title="only ticks-based values (not ms) are acceptable">TIME_FLAGS_TICKSONLY</a> means that the object can only be specified in tempo-relative units. You would not use this flag if you want the object to use the regular Max scheduler if the user specifies an absolute time (such as milliseconds). <a class="el" href="group__time.html#gga99fb83031ce9923c84392b4e92f956b5a91f2cee835f5cf871a657101b6ff7b4e" title="this time object will schedule events, not just hold a value">TIME_FLAGS_USECLOCK</a> means that it is a time object that will actually schedule events. If you do not use this flag, you can use the time object to hold and convert time values, which you use to schedule events manually. <a class="el" href="group__time.html#gga99fb83031ce9923c84392b4e92f956b5a7ddd9e0fa3dc6a7b346fc3dcee5c5c81" title="add a transport attribute">TIME_FLAGS_TRANSPORT</a> means that an additional attribute for specifying the transport name is added to your object automatically (it's called "transport" and has the label "Transport Name"). The combination of flags above is appropriate for an object that will be scheduling events on a temporary basis that are only synchronized with the transport and specified in tempo-relative units.</p>
<p>The next step is to create a time object in your new instance routine using time_new. The time_new function is something like clock_new -- you pass it a task function that will be executed when the scheduler reaches a certain time (in this case, delay2simple_tick, which will send out a bang). The first argument to time_new is a pointer to your object, the second is the name of the attribute created via class_time_addattr, the third is your task function, and the fourth are flags to control the behavior of the time object, as explained above for class_time_addattr.</p>
<p>Finally, we use time_setvalue to set the initial delay value to 0. </p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> *delay2simple_new()
    {
        t_delay2simple *x;
        <a class="code" href="structt__atom.html" title="An atom is a typed datum.">t_atom</a> a;
 
        x = (t_delay2simple *)<a class="code" href="group__obj.html#gacb89ef27c34b45e9037d877375804284" title="Allocates the memory for an instance of an object class and initialize its object...">object_alloc</a>(s_delay2simple_class);
        x-&gt;m_timeobj = (<a class="code" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or...">t_object</a> *)<a class="code" href="group__time.html#gaf6153d8f28738932c0ea3906a6c51696" title="Create a new time object.">time_new</a>((<a class="code" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or...">t_object</a> *)x, <a class="code" href="group__symbol.html#ga8268797d125a15bae1010af70b559e05" title="Given a C-string, fetch the matching t_symbol pointer from the symbol table, generating...">gensym</a>(<span class="stringliteral">&quot;delaytime&quot;</span>), (<a class="code" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d" title="Function pointer type for generic methods.">method</a>)delay2simple_tick, <a class="code" href="group__time.html#gga99fb83031ce9923c84392b4e92f956b5af93981eb3922895394877d099323a2e8" title="only ticks-based values (not ms) are acceptable">TIME_FLAGS_TICKSONLY</a> | <a class="code" href="group__time.html#gga99fb83031ce9923c84392b4e92f956b5a91f2cee835f5cf871a657101b6ff7b4e" title="this time object will schedule events, not just hold a value">TIME_FLAGS_USECLOCK</a>);
        x-&gt;m_outlet = <a class="code" href="group__inout.html#ga69d26d4f2684aab7dbc1b2d18248eae5" title="Use bangout() to create an outlet that will always send the bang message.">bangout</a>((<a class="code" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or...">t_object</a> *)x);
        <a class="code" href="group__atom.html#gae4faf28f99370e1a4ae9eab7df5bede7" title="Inserts a floating point number into a t_atom and change the t_atom&amp;#39;s type to...">atom_setfloat</a>(&amp;a, 0.);
        <a class="code" href="group__time.html#ga7451e479ce77e4dcf7a13bbd933575ed" title="Set the current value of a time object (either an interval or a position) using a...">time_setvalue</a>(x-&gt;d_timeobj, NULL, 1, &amp;a);
        <span class="keywordflow">return</span> x;
    }
</pre></div><p>To make a delayed bang, we need a delay2simple_bang function that causes our time object to put its task function into the ITM scheduler. This is accomplished using time_schedule. Note that unlike the roughly equivalent clock_fdelay, where the delay time is an argument, the time value must already be stored inside the time object using time_setvalue. The second argument to time_schedule is another time object that can be used to control quantization of an event. Since we aren't using quantization in this simple version of delay2, we pass NULL. </p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> delay2simple_bang(t_delay2 *x)
    {
        <a class="code" href="group__time.html#gae46ab99a9732990170ce0e27fb744c4b" title="Schedule a task, with optional quantization.">time_schedule</a>(x-&gt;d_timeobj, NULL);
    }
</pre></div><p>Next, our simple task routine, delay2simple_tick. After the specified number of ticks in the time object has elapsed after the call to time_schedule, the task routine will be executed. </p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> delay2_tick(t_delay2 *x)
    {
        <a class="code" href="group__inout.html#ga357498d7143fd266facfbfc4efa59029" title="Use outlet_bang() to send a bang message out an outlet.">outlet_bang</a>(x-&gt;d_outlet);
    }
</pre></div><p>Now let's add the two more advanced features found in delay2: quantization and a second (unquantized) bang output using low-level ITM routines. Here is the delay2 data structure. The new elements are a proxy (for receiving a delay time), a time object for quantization (d_quantize), a clock to be used for low-level ITM scheduling, and an outlet for the use of the low-level clock's task.</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">typedef</span> <span class="keyword">struct </span>delay2
    {
        <a class="code" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or...">t_object</a> d_obj;
        <span class="keywordtype">void</span> *d_outlet;
        <span class="keywordtype">void</span> *d_proxy;
        <span class="keywordtype">long</span> d_inletnum;
        <a class="code" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or...">t_object</a> *d_timeobj;
        <a class="code" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or...">t_object</a> *d_outlet2;
        <a class="code" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or...">t_object</a> *d_quantize;
        <span class="keywordtype">void</span> *d_clock;
 } t_delay2;
</pre></div><p>In the initialization routine, we'll define a quantization time attribute to work in conjunction with the d_quantize time object we'll be creating. This attribute does not have its own clock to worry about. It just holds a time value, which we specify will only be in ticks (quantizing in milliseconds doesn't make sense in the ITM context). If you build delay2 and open the inspector, you will see time attributes for both Delay Time and Quantization. </p>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__time.html#ga95e5b2330715823c8a609ccd500aa361" title="Create an attribute permitting a time object to be changed in a user-friendly way...">class_time_addattr</a>(c, <span class="stringliteral">&quot;quantize&quot;</span>, <span class="stringliteral">&quot;Quantization&quot;</span>, <a class="code" href="group__time.html#gga99fb83031ce9923c84392b4e92f956b5af93981eb3922895394877d099323a2e8" title="only ticks-based values (not ms) are acceptable">TIME_FLAGS_TICKSONLY</a>);
</pre></div><p>Here is part of the revised delay2 new instance routine. It now creates two time objects, plus a regular clock object.</p>
<div class="fragment"><pre class="fragment">    x-&gt;d_inletnum = 0;
    x-&gt;d_proxy = <a class="code" href="group__inout.html#ga65676568dda565aba2dd13c9f88c9f91" title="Use proxy_new to create a new Proxy object.">proxy_new</a>(x, 1, &amp;x-&gt;d_inletnum);
    x-&gt;d_outlet2 = <a class="code" href="group__inout.html#ga69d26d4f2684aab7dbc1b2d18248eae5" title="Use bangout() to create an outlet that will always send the bang message.">bangout</a>(x);
    x-&gt;d_outlet = <a class="code" href="group__inout.html#ga69d26d4f2684aab7dbc1b2d18248eae5" title="Use bangout() to create an outlet that will always send the bang message.">bangout</a>(x);

    x-&gt;d_timeobj = (<a class="code" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or...">t_object</a>*) <a class="code" href="group__time.html#gaf6153d8f28738932c0ea3906a6c51696" title="Create a new time object.">time_new</a>((<a class="code" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or...">t_object</a> *)x, <a class="code" href="group__symbol.html#ga8268797d125a15bae1010af70b559e05" title="Given a C-string, fetch the matching t_symbol pointer from the symbol table, generating...">gensym</a>(<span class="stringliteral">&quot;delaytime&quot;</span>), (<a class="code" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d" title="Function pointer type for generic methods.">method</a>)delay2_tick, <a class="code" href="group__time.html#gga99fb83031ce9923c84392b4e92f956b5af93981eb3922895394877d099323a2e8" title="only ticks-based values (not ms) are acceptable">TIME_FLAGS_TICKSONLY</a> | <a class="code" href="group__time.html#gga99fb83031ce9923c84392b4e92f956b5a91f2cee835f5cf871a657101b6ff7b4e" title="this time object will schedule events, not just hold a value">TIME_FLAGS_USECLOCK</a>);
    x-&gt;d_quantize = (<a class="code" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or...">t_object</a>*) <a class="code" href="group__time.html#gaf6153d8f28738932c0ea3906a6c51696" title="Create a new time object.">time_new</a>((<a class="code" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or...">t_object</a> *)x, <a class="code" href="group__symbol.html#ga8268797d125a15bae1010af70b559e05" title="Given a C-string, fetch the matching t_symbol pointer from the symbol table, generating...">gensym</a>(<span class="stringliteral">&quot;quantize&quot;</span>), NULL, <a class="code" href="group__time.html#gga99fb83031ce9923c84392b4e92f956b5af93981eb3922895394877d099323a2e8" title="only ticks-based values (not ms) are acceptable">TIME_FLAGS_TICKSONLY</a>);
    x-&gt;d_clock = <a class="code" href="group__clocks.html#ga6257ddd41904756699208f135f6539fd" title="Create a new Clock object.">clock_new</a>((<a class="code" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or...">t_object</a> *)x, (<a class="code" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d" title="Function pointer type for generic methods.">method</a>)delay2_clocktick);
</pre></div><p>To use the quantization time object, we can pass it as the second argument to time_schedule. If the value of the quantization is 0, there is no effect. Otherwise, time_schedule will move the event time so it lies on a quantization boundary. For example, if the quantization value is 4n (480 ticks), the delay time is 8n (240 ticks) and current time is 650 ticks, the delay time will be adjusted so that the bang comes out of the delay2 object at 980 ticks instead of 890 ticks.</p>
<p>In addition to using quantization with time_schedule, delay2_bang shows how to calculate a millisecond equivalent for an ITM time value using itm_tickstoms. This delay value is not quantized, although you read the time value from the d_quantize object and calculate your own quantized delay if wanted. The "calculated" delay is sent out the right outlet, since the clock we created uses delay2_clocktick.</p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> delay2_bang(t_delay2 *x)
    {
        <span class="keywordtype">double</span> ms, tix;
 
        <a class="code" href="group__time.html#gae46ab99a9732990170ce0e27fb744c4b" title="Schedule a task, with optional quantization.">time_schedule</a>(x-&gt;d_timeobj, x-&gt;d_quantize);
 
        tix = <a class="code" href="group__time.html#ga4f47a0932158cafd04fb2e0cc928b4cc" title="Convert the value of a time object to ticks.">time_getticks</a>(x-&gt;d_timeobj);
        tix += (tix / 2);
        ms = <a class="code" href="group__time.html#ga3ed676dca6666ab9f305ea81b8d1b6b7" title="Convert a time value in ticks to the equivalent value in milliseconds, given the...">itm_tickstoms</a>(<a class="code" href="group__time.html#gaa1d217d3b706f718f0f77dbd78427fb0" title="Return the ITM object associated with this time object.">time_getitm</a>(x-&gt;d_timeobj), tix);
        <a class="code" href="group__clocks.html#ga61719f0e0379fffbe79ae2bd5699b66f" title="Schedule the execution of a Clock using a floating-point argument.">clock_fdelay</a>(x-&gt;d_clock, ms);
    }
 
    <span class="keywordtype">void</span> delay2_clocktick(t_delay2 *x)
    {
        <a class="code" href="group__inout.html#ga357498d7143fd266facfbfc4efa59029" title="Use outlet_bang() to send a bang message out an outlet.">outlet_bang</a>(x-&gt;d_outlet2);
    }
</pre></div><h2><a class="anchor" id="chapter_itm_permanent">
Permanent Events</a></h2>
<p>A permanent event in ITM is one that has been scheduled to occur when the transport reaches a specific time. You can schedule a permanent event in terms of ticks or bars/beats/units. An event based in ticks will occur when the transport reaches the specified tick value, and it will not be affected by changes in time signature. An event specified for a time in bars/beats/units will be affected by the time signature. As an example, consider an event scheduled for bar 2, beat 1, unit 0. If the time signature of the ITM object on which the event has been scheduled is 3/4, the event will occur at 480 times 3 or 1440 ticks. But if the time signature is 4/4, the event will occur at 1920 ticks. If, as an alternative, you had scheduled the event to occur at 1920 ticks, setting the time signature to 3/4 would not have affected when it occurred.</p>
<p>You don't "schedule" a permanent event. Once it is created, it is always in an ITM object's list of permanent events. To specify when the event should occur, use time_setvalue.</p>
<p>The high-level time object interface handles permanent events. Let's say we want to have a time value called "targettime." First, we declare an attribute using class_time_addattr. The flags used are <a class="el" href="group__time.html#gga99fb83031ce9923c84392b4e92f956b5af93981eb3922895394877d099323a2e8" title="only ticks-based values (not ms) are acceptable">TIME_FLAGS_TICKSONLY</a> (required because you can't specify a permanent event in milliseconds), <a class="el" href="group__time.html#gga99fb83031ce9923c84392b4e92f956b5ac80606ccbb9a16c14cf81874e4de2408" title="1 1 0 location-based bar/beat/unit values (as opposed to interval values, which are...">TIME_FLAGS_LOCATION</a> (which interprets the bar/beat/unit times where 1 1 0 is zero ticks), <a class="el" href="group__time.html#gga99fb83031ce9923c84392b4e92f956b5af2db490f1904d9f1e834f9ea062ad67e" title="event will be scheduled in the permanent list (tied to a specific time)">TIME_FLAGS_PERMANENT</a> (for a permanent event), and <a class="el" href="group__time.html#gga99fb83031ce9923c84392b4e92f956b5a7ddd9e0fa3dc6a7b346fc3dcee5c5c81" title="add a transport attribute">TIME_FLAGS_TRANSPORT</a> (which adds a transport attribute permitting a user to choose a transport object as a destination for the event) and <a class="el" href="group__time.html#gga99fb83031ce9923c84392b4e92f956b5a4d4396aa4c56efec83245821ea888235" title="constrain any values &lt; 0 to 0">TIME_FLAGS_POSITIVE</a> (constrains the event to happen only for positive tick and bar/beat/unit values).</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__time.html#ga95e5b2330715823c8a609ccd500aa361" title="Create an attribute permitting a time object to be changed in a user-friendly way...">class_time_addattr</a>(c, <span class="stringliteral">&quot;targettime&quot;</span>, <span class="stringliteral">&quot;Target Time&quot;</span>, <a class="code" href="group__time.html#gga99fb83031ce9923c84392b4e92f956b5af93981eb3922895394877d099323a2e8" title="only ticks-based values (not ms) are acceptable">TIME_FLAGS_TICKSONLY</a> | <a class="code" href="group__time.html#gga99fb83031ce9923c84392b4e92f956b5ac80606ccbb9a16c14cf81874e4de2408" title="1 1 0 location-based bar/beat/unit values (as opposed to interval values, which are...">TIME_FLAGS_LOCATION</a> | <a class="code" href="group__time.html#gga99fb83031ce9923c84392b4e92f956b5af2db490f1904d9f1e834f9ea062ad67e" title="event will be scheduled in the permanent list (tied to a specific time)">TIME_FLAGS_PERMANENT</a> | <a class="code" href="group__time.html#gga99fb83031ce9923c84392b4e92f956b5a7ddd9e0fa3dc6a7b346fc3dcee5c5c81" title="add a transport attribute">TIME_FLAGS_TRANSPORT</a> | <a class="code" href="group__time.html#gga99fb83031ce9923c84392b4e92f956b5a4d4396aa4c56efec83245821ea888235" title="constrain any values &amp;lt; 0 to 0">TIME_FLAGS_POSITIVE</a>);
</pre></div><p>The <a class="el" href="group__time.html#gga99fb83031ce9923c84392b4e92f956b5a7ddd9e0fa3dc6a7b346fc3dcee5c5c81" title="add a transport attribute">TIME_FLAGS_TRANSPORT</a> flag is particularly nice. Without any intervention on your part, it creates a transport attribute for your object, and takes care of scheduling the permanent event on the transport the user specifies, with a default value of the global ITM object. If you want to cause your event to be rescheduled dynamically when the user changes the transport, your object can respond to the reschedule message as follows.</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__class.html#ga1fabf54e0cec8d4e5f732fa347b3f874" title="Adds a method to a previously defined object class.">class_addmethod</a>(c, (<a class="code" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d" title="Function pointer type for generic methods.">method</a>)myobject_reschedule, <span class="stringliteral">&quot;reschedule&quot;</span>,   <a class="code" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47af48193ec36e53b1507d81c49873c8d7a" title="cannot typecheck args">A_CANT</a>, 0);         <span class="comment">// for dynamic transport reassignment</span>
</pre></div><p>All you need to do in your reschedule method is just act as if the user has changed the time value, and use the current time value to call time_setvalue.</p>
<p>In your new instance routine, creating a permanent event with time_new uses the same flags as were passed to class_time_addattr:</p>
<div class="fragment"><pre class="fragment">    x-&gt;t_time = (<a class="code" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or...">t_object</a>*) <a class="code" href="group__time.html#gaf6153d8f28738932c0ea3906a6c51696" title="Create a new time object.">time_new</a>((<a class="code" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or...">t_object</a> *)x, <a class="code" href="group__symbol.html#ga8268797d125a15bae1010af70b559e05" title="Given a C-string, fetch the matching t_symbol pointer from the symbol table, generating...">gensym</a>(<span class="stringliteral">&quot;targettime&quot;</span>), (<a class="code" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d" title="Function pointer type for generic methods.">method</a>)myobject_tick, <a class="code" href="group__time.html#gga99fb83031ce9923c84392b4e92f956b5af93981eb3922895394877d099323a2e8" title="only ticks-based values (not ms) are acceptable">TIME_FLAGS_TICKSONLY</a> | <a class="code" href="group__time.html#gga99fb83031ce9923c84392b4e92f956b5a91f2cee835f5cf871a657101b6ff7b4e" title="this time object will schedule events, not just hold a value">TIME_FLAGS_USECLOCK</a> | <a class="code" href="group__time.html#gga99fb83031ce9923c84392b4e92f956b5af2db490f1904d9f1e834f9ea062ad67e" title="event will be scheduled in the permanent list (tied to a specific time)">TIME_FLAGS_PERMANENT</a> | <a class="code" href="group__time.html#gga99fb83031ce9923c84392b4e92f956b5ac80606ccbb9a16c14cf81874e4de2408" title="1 1 0 location-based bar/beat/unit values (as opposed to interval values, which are...">TIME_FLAGS_LOCATION</a> | <a class="code" href="group__time.html#gga99fb83031ce9923c84392b4e92f956b5a4d4396aa4c56efec83245821ea888235" title="constrain any values &amp;lt; 0 to 0">TIME_FLAGS_POSITIVE</a>);
</pre></div><p>The task called by the permanent time object is identical to a clock task or an ITM temporary event task.</p>
<h2><a class="anchor" id="chapter_itm_clean">
Cleaning Up</a></h2>
<p>With all time objects, both permanent and temporary, it's necessary to free the objects in your object's free method. Failure to do so will lead to crashes if your object is freed but its events remain in the ITM scheduler. For example, here is the delay2 free routine:</p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> delay2_free(t_delay2 *x)
    {
        <a class="code" href="group__class__old.html#gadf30646e52376a37b93cc20efac65636" title="Release the memory used by a Max object.">freeobject</a>(x-&gt;d_timeobj);
        <a class="code" href="group__class__old.html#gadf30646e52376a37b93cc20efac65636" title="Release the memory used by a Max object.">freeobject</a>(x-&gt;d_quantize);
        <a class="code" href="group__class__old.html#gadf30646e52376a37b93cc20efac65636" title="Release the memory used by a Max object.">freeobject</a>((<a class="code" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or...">t_object</a> *) x-&gt;d_proxy);
        <a class="code" href="group__class__old.html#gadf30646e52376a37b93cc20efac65636" title="Release the memory used by a Max object.">freeobject</a>((<a class="code" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or...">t_object</a> *)x-&gt;d_clock);
    }
</pre></div> </div>
		<div id="c74footer">
			<p>Copyright &copy; 2008, <a href="http://www.cycling74.com/">Cycling '74</a></p>
		</div>
	</body>
</html>
