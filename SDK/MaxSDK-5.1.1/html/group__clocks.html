<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
		<title>Max5 API Reference</title>
		<link href="c74-doxygen.css" rel="stylesheet" type="text/css">
	</head>
	<body>

		<div id="c74header">
			<img src="max5.png" />
			<p>Max 5 API Reference</p>
		</div>

<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Clocks<br/>
<small>
[<a class="el" href="group__sched.html">Timing</a>]</small>
</h1>
<p>Clock objects are your interface to Max’s scheduler.  
<a href="#_details">More...</a></p>

<p><div class="dynheader">
Collaboration diagram for Clocks:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__clocks.png" border="0" alt="" usemap="#group____clocks_map"/>
<map name="group____clocks_map" id="group____clocks">
<area shape="rect" href="group__sched.html" title="Timing" alt="" coords="5,5,77,32"/></map></td></tr></table></center>
</div>
</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga09c0580122113b4db2517ff8e7c8b0f2"></a><!-- doxytag: member="clocks::t_clock" ref="ga09c0580122113b4db2517ff8e7c8b0f2" args="" -->
typedef <a class="el" href="structt__object.html">t_object</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clocks.html#ga09c0580122113b4db2517ff8e7c8b0f2">t_clock</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A clock. <br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clocks.html#ga6257ddd41904756699208f135f6539fd">clock_new</a> (void *obj, <a class="el" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d">method</a> fn)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new Clock object.  <a href="#ga6257ddd41904756699208f135f6539fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clocks.html#ga9ac56d198904627333de740743086920">clock_delay</a> (void *x, long n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Schedule the execution of a Clock.  <a href="#ga9ac56d198904627333de740743086920"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clocks.html#ga64f5f8a027b39c1c14464744a9cc08ce">clock_unset</a> (void *x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancel the scheduled execution of a Clock.  <a href="#ga64f5f8a027b39c1c14464744a9cc08ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clocks.html#ga61719f0e0379fffbe79ae2bd5699b66f">clock_fdelay</a> (void *c, double time)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Schedule the execution of a Clock using a floating-point argument.  <a href="#ga61719f0e0379fffbe79ae2bd5699b66f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clocks.html#ga04a49876d29036406f857cf22b99d9ac">clock_getftime</a> (double *time)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find out the current logical time of the scheduler in milliseconds as a floating-point number.  <a href="#ga04a49876d29036406f857cf22b99d9ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clocks.html#gadf4bd364fd019bed91a587337eb4801e">setclock_delay</a> (<a class="el" href="structt__object.html">t_object</a> *x, void *c, long time)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Schedule a Clock on a scheduler.  <a href="#gadf4bd364fd019bed91a587337eb4801e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clocks.html#gafbc6d9baa43a561b1840b8b4ce6bed5c">setclock_unset</a> (<a class="el" href="structt__object.html">t_object</a> *x, void *c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a Clock from a scheduler.  <a href="#gafbc6d9baa43a561b1840b8b4ce6bed5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clocks.html#ga1322ff3659b3d754298c636ad1856903">setclock_gettime</a> (<a class="el" href="structt__object.html">t_object</a> *x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find out the current time value of a setclock object.  <a href="#ga1322ff3659b3d754298c636ad1856903"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clocks.html#ga91badd52e8729b007c22461368a21854">setclock_fdelay</a> (<a class="el" href="structt__object.html">t_object</a> *s, void *c, double time)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Schedule a Clock on a scheduler, using a floating-point time argument.  <a href="#ga91badd52e8729b007c22461368a21854"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clocks.html#gafd1993dc69a6232cf28683961c97b9e4">setclock_getftime</a> (<a class="el" href="structt__object.html">t_object</a> *s, double *time)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find out the current time value of a setclock object in floating-point milliseconds.  <a href="#gafd1993dc69a6232cf28683961c97b9e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clocks.html#ga11fd7e2733b0186ff82e9766db3031e7">systimer_gettime</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">While most Max/MSP timing references "logical" time derived from Max's millisecond scheduler, time values produced by the <a class="el" href="group__clocks.html#ga11fd7e2733b0186ff82e9766db3031e7" title="While most Max/MSP timing references &quot;logical&quot; time derived from Max&#39;s...">systimer_gettime()</a> are referenced from the CPU clock and can be used to time real world events with microsecond precision.  <a href="#ga11fd7e2733b0186ff82e9766db3031e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clocks.html#gabe5d8b1c9f260d13734a328b2a60ff69">gettime</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find out the current logical time of the scheduler in milliseconds.  <a href="#gabe5d8b1c9f260d13734a328b2a60ff69"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clocks.html#ga90e58fdc4b6aa7a1485220d808d6fc4b">scheduler_new</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new local scheduler.  <a href="#ga90e58fdc4b6aa7a1485220d808d6fc4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clocks.html#gae6fc77faa65e6f80a26f072b2b17b31b">scheduler_set</a> (void *x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a scheduler current, so that future related calls (such as <a class="el" href="group__clocks.html#ga9ac56d198904627333de740743086920" title="Schedule the execution of a Clock.">clock_delay()</a>) will affect the appropriate scheduler.  <a href="#gae6fc77faa65e6f80a26f072b2b17b31b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clocks.html#ga7f67cd4fe41445e1d11afe84742a6d5f">scheduler_get</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the currently set scheduler.  <a href="#ga7f67cd4fe41445e1d11afe84742a6d5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clocks.html#ga18134769aacb89b12258898166a99ff2">scheduler_fromobject</a> (<a class="el" href="structt__object.html">t_object</a> *o)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the scheduler associated with a given object, if any.  <a href="#ga18134769aacb89b12258898166a99ff2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clocks.html#ga69f8d9f511899d3f4b30f6b7a032849a">scheduler_run</a> (void *x, double until)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Run scheduler events to a selected time.  <a href="#ga69f8d9f511899d3f4b30f6b7a032849a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clocks.html#gade0e21336c4b2f33046669df0d210a48">scheduler_settime</a> (void *x, double time)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the current time of the scheduler.  <a href="#gade0e21336c4b2f33046669df0d210a48"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clocks.html#gadbaa75aac36f99e3559827a55c12c36e">scheduler_gettime</a> (void *x, double *time)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the current time of the selected scheduler.  <a href="#gadbaa75aac36f99e3559827a55c12c36e"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Clock objects are your interface to Max’s scheduler. </p>
<p>To use the scheduler, you create a new Clock object using clock_new in your instance creation function. You also have to write a clock function that will be executed when the clock goes off, declared as follows:</p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> myobject_tick (myobject *x); 
</pre></div><p>The argument x is determined by the arg argument to <a class="el" href="group__clocks.html#ga6257ddd41904756699208f135f6539fd" title="Create a new Clock object.">clock_new()</a>. Almost always it will be pointer to your object. Then, in one of your methods, use <a class="el" href="group__clocks.html#ga9ac56d198904627333de740743086920" title="Schedule the execution of a Clock.">clock_delay()</a> or <a class="el" href="group__clocks.html#ga61719f0e0379fffbe79ae2bd5699b66f" title="Schedule the execution of a Clock using a floating-point argument.">clock_fdelay()</a> to schedule yourself. If you want unschedule yourself, call <a class="el" href="group__clocks.html#ga64f5f8a027b39c1c14464744a9cc08ce" title="Cancel the scheduled execution of a Clock.">clock_unset()</a>. To find out what time it is now, use <a class="el" href="group__clocks.html#gabe5d8b1c9f260d13734a328b2a60ff69" title="Find out the current logical time of the scheduler in milliseconds.">gettime()</a> or <a class="el" href="group__clocks.html#ga04a49876d29036406f857cf22b99d9ac" title="Find out the current logical time of the scheduler in milliseconds as a floating-point...">clock_getftime()</a>. More advanced clock operations are possible with the setclock object interface described in Chapter 9. We suggest you take advantage of the higher timing precision of the floating-point clock routines—all standard Max 4 timing objects such as metro use them.</p>
<p>When the user has Overdrive mode enabled, your clock function will execute at interrupt level.</p>
<h2><a class="anchor" id="clocks_using_clocks">
Using Clocks</a></h2>
<p>Under normal circumstances, gettime or clock_getftime will not be necessary for scheduling purposes if you use clock_delay or clock_fdelay, but it may be useful for recording the timing of messages or events.</p>
<p>As an example, here’s a fragment of how one might go about writing a metronome using the Max scheduler. First, here’s the data structure we’ll use.</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">typedef</span> <span class="keyword">struct </span>mymetro { 
        <a class="code" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or...">t_object</a> *m_obj; 
        <span class="keywordtype">void</span> *m_clock; 
        <span class="keywordtype">double</span> m_interval; 
        <span class="keywordtype">void</span> *m_outlet; 
    } t_mymetro;
</pre></div><p>We’ll assume that the class has been initialized already. Here’s the instance creation function that will allocate a new Clock.</p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> *mymetro_create (<span class="keywordtype">double</span> defaultInterval) 
    { 
        t_mymetro *x; 
        x = (t_mymetro *)<a class="code" href="group__class__old.html#ga053f428d5edcc7d663980330848e73a6" title="Use newobject to allocate the space for an instance of your class and initialize...">newobject</a>(mymetro_class); <span class="comment">// allocate space</span>
        x-&gt;m_clock = <a class="code" href="group__clocks.html#ga6257ddd41904756699208f135f6539fd" title="Create a new Clock object.">clock_new</a>(x,(<a class="code" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d" title="Function pointer type for generic methods.">method</a>)mymetro_tick); <span class="comment">// make a clock</span>
        x-&gt;m_interval = defaultInterval; <span class="comment">// store the interval </span>
        x-&gt;m_outlet = <a class="code" href="group__inout.html#ga69d26d4f2684aab7dbc1b2d18248eae5" title="Use bangout() to create an outlet that will always send the bang message.">bangout</a>(x); <span class="comment">// outlet for ticks</span>
        <span class="keywordflow">return</span> x; <span class="comment">// return the new object</span>
    } 
</pre></div><p>Here’s the method written to respond to the bang message that starts the metronome.</p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> mymetro_bang (t_mymetro *x) 
    { 
        <a class="code" href="group__clocks.html#ga61719f0e0379fffbe79ae2bd5699b66f" title="Schedule the execution of a Clock using a floating-point argument.">clock_fdelay</a>(x-&gt;m_clock,0.); 
    } 
</pre></div><p>Here’s the Clock function.</p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> mymetro_tick(t_mymetro *x) 
    { 
        <a class="code" href="group__clocks.html#ga61719f0e0379fffbe79ae2bd5699b66f" title="Schedule the execution of a Clock using a floating-point argument.">clock_fdelay</a>(x-&gt;m_clock, x-&gt;m_interval); 
        <span class="comment">// schedule another metronome tick</span>
        <a class="code" href="group__inout.html#ga357498d7143fd266facfbfc4efa59029" title="Use outlet_bang() to send a bang message out an outlet.">outlet_bang</a>(x-&gt;m_outlet); <span class="comment">// send out a bang</span>
    } 
</pre></div><p>You may also want to stop the metronome at some point. Here’s a method written to respond to the message stop. It uses clock_unset.</p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> mymetro_stop (t_mymetro *x) 
    { 
        <a class="code" href="group__clocks.html#ga64f5f8a027b39c1c14464744a9cc08ce" title="Cancel the scheduled execution of a Clock.">clock_unset</a>(x-&gt;m_clock); 
    }
</pre></div><p>In your object’s free function, you should call freeobject on any Clocks you’ve created.</p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> mymetro_free (MyMetro *x) 
    { 
        <a class="code" href="group__class__old.html#gadf30646e52376a37b93cc20efac65636" title="Release the memory used by a Max object.">freeobject</a>((<a class="code" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or...">t_object</a> *)x-&gt;m_clock); 
    }
</pre></div><h2><a class="anchor" id="setclock">
Scheduling with setclock Objects</a></h2>
<p>The setclock object allows a more general way of scheduling Clocks by generalizing the advancement of the time associated with a scheduler. Each setclock object’s "time" can be changed by a process other than the internal millisecond clock. In addition, the object implements routines that modify the mapping of the internal millisecond clock onto the current value of time in an object. Your object can call a set of routines that use either setclock or the normal millisecond clock transparently. Many Max objects accept the message clock followed by an optional symbol to set their internal scheduling to a named setclock object. The typical implementation passes the binding of a Symbol (the s_thing field) to the Setclock functions. By default, the empty symbol is passed. If the binding has been linked to a setclock object, it will be used to schedule the Clock. Otherwise, the Clock is scheduled using the main internal millisecond scheduler. The Setclock data structure is a replacement for void * since there will be no reason for external objects to access it directly.</p>
<h3><a class="anchor" id="setclock_using_the_routines">
Using the setclock Object Routines</a></h3>
<p>Here’s an example implementation of the relevant methods of a metronome object using the Setclock routines.</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">typedef</span> <span class="keyword">struct </span>metro 
    { 
        <a class="code" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or...">t_object</a> m_ob; 
        <span class="keywordtype">long</span> m_interval; 
        <span class="keywordtype">long</span> m_running; 
        <span class="keywordtype">void</span> *m_clock; 
        <a class="code" href="structt__symbol.html" title="The symbol.">t_symbol</a> *m_setclock; 
    } t_metro;
</pre></div><p>Here’s the implementation of the routines for turning the metronome on and off. Assume that in the instance creation function, the <a class="el" href="structt__symbol.html" title="The symbol.">t_symbol</a> m_setclock has been set to the empty symbol (gensym ("")) and m_clock has been created; the clock function metro_tick() is defined further on.</p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> metro_bang(Metro *x) <span class="comment">// turn metronome on</span>
    { 
        x-&gt;m_running = 1; 
        <a class="code" href="group__clocks.html#gadf4bd364fd019bed91a587337eb4801e" title="Schedule a Clock on a scheduler.">setclock_delay</a>(x-&gt;m_setclock-&gt;s_thing,x-&gt;m_clock,0); 
    } 

    <span class="keywordtype">void</span> metro_stop(Metro *x) 
    { 
        x-&gt;m_running = 0; 
        <a class="code" href="group__clocks.html#gafbc6d9baa43a561b1840b8b4ce6bed5c" title="Remove a Clock from a scheduler.">setclock_unset</a>(x-&gt;m_setclock-&gt;s_thing,x-&gt;m_clock); 
    }
</pre></div><p>Here is the implementation of the clock function metro_tick() that runs periodically.</p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> metro_tick(Metro *x) 
    { 
        <a class="code" href="group__inout.html#ga357498d7143fd266facfbfc4efa59029" title="Use outlet_bang() to send a bang message out an outlet.">outlet_bang</a>(x-&gt;m_ob.o_outlet); 
        <span class="keywordflow">if</span> (x-&gt;m_running) 
            <a class="code" href="group__clocks.html#gadf4bd364fd019bed91a587337eb4801e" title="Schedule a Clock on a scheduler.">setclock_delay</a>(x-&gt;m_setclock-&gt;s_thing,x-&gt;m_clock,x-&gt;m_interval); 
    } 
</pre></div><p>Finally, here is an implementation of the method to respond to the clock message. Note that the function tries to verify that a non-zero value bound to the <a class="el" href="structt__symbol.html" title="The symbol.">t_symbol</a> passed as an argument is in fact an instance of setclock by checking to see if it responds to the unset message. If not, the metronome refuses to assign the <a class="el" href="structt__symbol.html" title="The symbol.">t_symbol</a> to its internal m_setclock field.</p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> metro_clock(Metro *x, <a class="code" href="structt__symbol.html" title="The symbol.">t_symbol</a> *s) 
    { 
        <span class="keywordtype">void</span> *old = x-&gt;m_setclock-&gt;s_thing; 
        <span class="keywordtype">void</span> *c = 0; 

        <span class="comment">// the line below can be restated as: </span>
        <span class="comment">//  if s is the empty symbol </span>
        <span class="comment">//  or s-&gt;s_thing is zero </span>
        <span class="comment">//  or s-&gt;s_thing is non-zero and a setclock object  </span>
        <span class="keywordflow">if</span> ((s == <a class="code" href="group__symbol.html#ga8268797d125a15bae1010af70b559e05" title="Given a C-string, fetch the matching t_symbol pointer from the symbol table, generating...">gensym</a>(<span class="stringliteral">&quot;&quot;</span>)) || ((c = s-&gt;<a class="code" href="structt__symbol.html#abd835e42c1c3ef3ed958c22cc73c9e69" title="possible binding to a t_object">s_thing</a>) &amp;&amp; <a class="code" href="group__class__old.html#ga54a45bcc841c2033467be14e6861b548" title="Use zgetfn() to send an untyped message to a Max object without error checking.">zgetfn</a>(c,&amp;s_unset))) 
        { 
            <span class="keywordflow">if</span> (old) 
                <a class="code" href="group__clocks.html#gafbc6d9baa43a561b1840b8b4ce6bed5c" title="Remove a Clock from a scheduler.">setclock_unset</a>(old,x-&gt;m_clock); 
            x-&gt;m_setclock = s; 
            <span class="keywordflow">if</span> (x-&gt;m_running) 
                <a class="code" href="group__clocks.html#gadf4bd364fd019bed91a587337eb4801e" title="Schedule a Clock on a scheduler.">setclock_delay</a>(c,x-&gt;m_clock,0L); 
        } 
    } 
</pre></div><h2><a class="anchor" id="creating_schedulers">
Creating Schedulers</a></h2>
<p>If you want to schedule events independently of the time of the global Max scheduler, you can create your own scheduler with <a class="el" href="group__clocks.html#ga90e58fdc4b6aa7a1485220d808d6fc4b" title="Create a new local scheduler.">scheduler_new()</a>. By calling <a class="el" href="group__clocks.html#gae6fc77faa65e6f80a26f072b2b17b31b" title="Make a scheduler current, so that future related calls (such as clock_delay()) will...">scheduler_set()</a> with the newly created scheduler, calls to <a class="el" href="group__clocks.html#ga6257ddd41904756699208f135f6539fd" title="Create a new Clock object.">clock_new()</a> will create Clocks tied to your scheduler instead of Max’s global one. You can then control the time of the scheduler (using <a class="el" href="group__clocks.html#gade0e21336c4b2f33046669df0d210a48" title="Set the current time of the scheduler.">scheduler_settime()</a>) as well as when it executes clock functions (using <a class="el" href="group__clocks.html#ga69f8d9f511899d3f4b30f6b7a032849a" title="Run scheduler events to a selected time.">scheduler_run()</a>). This is a more general facility than the setclock object routines, but unlike using the time from a setclock object to determine when a Clock function runs, once a Clock is tied to a scheduler. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga9ac56d198904627333de740743086920"></a><!-- doxytag: member="ext_proto.h::clock_delay" ref="ga9ac56d198904627333de740743086920" args="(void *x, long n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clock_delay </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Schedule the execution of a Clock. </p>
<p><a class="el" href="group__clocks.html#ga9ac56d198904627333de740743086920" title="Schedule the execution of a Clock.">clock_delay()</a> sets a clock to go off at a certain number of milliseconds from the current logical time.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Clock to schedule. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>Delay, in milliseconds, before the Clock will execute. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__clocks.html#ga61719f0e0379fffbe79ae2bd5699b66f" title="Schedule the execution of a Clock using a floating-point argument.">clock_fdelay()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga61719f0e0379fffbe79ae2bd5699b66f"></a><!-- doxytag: member="ext_proto.h::clock_fdelay" ref="ga61719f0e0379fffbe79ae2bd5699b66f" args="(void *c, double time)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clock_fdelay </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Schedule the execution of a Clock using a floating-point argument. </p>
<p><a class="el" href="group__clocks.html#ga9ac56d198904627333de740743086920" title="Schedule the execution of a Clock.">clock_delay()</a> sets a clock to go off at a certain number of milliseconds from the current logical time.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>Clock to schedule. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>time</em>&nbsp;</td><td>Delay, in milliseconds, before the Clock will execute. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__clocks.html#ga9ac56d198904627333de740743086920" title="Schedule the execution of a Clock.">clock_delay()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga04a49876d29036406f857cf22b99d9ac"></a><!-- doxytag: member="ext_proto.h::clock_getftime" ref="ga04a49876d29036406f857cf22b99d9ac" args="(double *time)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clock_getftime </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>time</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find out the current logical time of the scheduler in milliseconds as a floating-point number. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>time</em>&nbsp;</td><td>Returns the current time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__clocks.html#gabe5d8b1c9f260d13734a328b2a60ff69" title="Find out the current logical time of the scheduler in milliseconds.">gettime()</a> </dd>
<dd>
<a class="el" href="group__clocks.html#gafd1993dc69a6232cf28683961c97b9e4" title="Find out the current time value of a setclock object in floating-point milliseconds...">setclock_getftime()</a> </dd>
<dd>
<a class="el" href="group__clocks.html#ga1322ff3659b3d754298c636ad1856903" title="Find out the current time value of a setclock object.">setclock_gettime()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga6257ddd41904756699208f135f6539fd"></a><!-- doxytag: member="ext_proto.h::clock_new" ref="ga6257ddd41904756699208f135f6539fd" args="(void *obj, method fn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* clock_new </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d">method</a>&nbsp;</td>
          <td class="paramname"> <em>fn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new Clock object. </p>
<p>Normally, <a class="el" href="group__clocks.html#ga6257ddd41904756699208f135f6539fd" title="Create a new Clock object.">clock_new()</a> is called in your instance creation function—and it cannot be called from a thread other than the main thread. To get rid of a clock object you created, use <a class="el" href="group__class__old.html#gadf30646e52376a37b93cc20efac65636" title="Release the memory used by a Max object.">freeobject()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>Argument that will be passed to clock function fn when it is called. This will almost always be a pointer to your object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fn</em>&nbsp;</td><td>Function to be called when the clock goes off, declared to take a single argument as shown in <a class="el" href="group__clocks.html#clocks_using_clocks">Using Clocks</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to a newly created Clock object. </dd></dl>

</div>
</div>
<a class="anchor" id="ga64f5f8a027b39c1c14464744a9cc08ce"></a><!-- doxytag: member="ext_proto.h::clock_unset" ref="ga64f5f8a027b39c1c14464744a9cc08ce" args="(void *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clock_unset </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cancel the scheduled execution of a Clock. </p>
<p><a class="el" href="group__clocks.html#ga64f5f8a027b39c1c14464744a9cc08ce" title="Cancel the scheduled execution of a Clock.">clock_unset()</a> will do nothing (and not complain) if the Clock passed to it has not been set.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Clock to cancel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabe5d8b1c9f260d13734a328b2a60ff69"></a><!-- doxytag: member="ext_proto.h::gettime" ref="gabe5d8b1c9f260d13734a328b2a60ff69" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long gettime </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find out the current logical time of the scheduler in milliseconds. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the current time. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__clocks.html#ga04a49876d29036406f857cf22b99d9ac" title="Find out the current logical time of the scheduler in milliseconds as a floating-point...">clock_getftime()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga18134769aacb89b12258898166a99ff2"></a><!-- doxytag: member="ext_proto.h::scheduler_fromobject" ref="ga18134769aacb89b12258898166a99ff2" args="(t_object *o)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* scheduler_fromobject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__object.html">t_object</a> *&nbsp;</td>
          <td class="paramname"> <em>o</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the scheduler associated with a given object, if any. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>o</em>&nbsp;</td><td>The object who's scheduler is to be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>This routine returns a pointer to the scheduler or the passed in object, </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__clocks.html#creating_schedulers">Creating Schedulers</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7f67cd4fe41445e1d11afe84742a6d5f"></a><!-- doxytag: member="ext_proto.h::scheduler_get" ref="ga7f67cd4fe41445e1d11afe84742a6d5f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* scheduler_get </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the currently set scheduler. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>This routine returns a pointer to the current scheduler, </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__clocks.html#creating_schedulers">Creating Schedulers</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gadbaa75aac36f99e3559827a55c12c36e"></a><!-- doxytag: member="ext_proto.h::scheduler_gettime" ref="gadbaa75aac36f99e3559827a55c12c36e" args="(void *x, double *time)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void scheduler_gettime </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve the current time of the selected scheduler. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The scheduler to query. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>time</em>&nbsp;</td><td>The current time of the selected scheduler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__clocks.html#creating_schedulers">Creating Schedulers</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga90e58fdc4b6aa7a1485220d808d6fc4b"></a><!-- doxytag: member="ext_proto.h::scheduler_new" ref="ga90e58fdc4b6aa7a1485220d808d6fc4b" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* scheduler_new </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new local scheduler. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the newly created scheduler. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__clocks.html#creating_schedulers">Creating Schedulers</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga69f8d9f511899d3f4b30f6b7a032849a"></a><!-- doxytag: member="ext_proto.h::scheduler_run" ref="ga69f8d9f511899d3f4b30f6b7a032849a" args="(void *x, double until)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void scheduler_run </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>until</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Run scheduler events to a selected time. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The scheduler to advance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>until</em>&nbsp;</td><td>The ending time for this run (in milliseconds). </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__clocks.html#creating_schedulers">Creating Schedulers</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae6fc77faa65e6f80a26f072b2b17b31b"></a><!-- doxytag: member="ext_proto.h::scheduler_set" ref="gae6fc77faa65e6f80a26f072b2b17b31b" args="(void *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* scheduler_set </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a scheduler current, so that future related calls (such as <a class="el" href="group__clocks.html#ga9ac56d198904627333de740743086920" title="Schedule the execution of a Clock.">clock_delay()</a>) will affect the appropriate scheduler. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The scheduler to make current. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>This routine returns a pointer to the previously current scheduler, wsaved and restored when local scheduling is complete. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__clocks.html#creating_schedulers">Creating Schedulers</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gade0e21336c4b2f33046669df0d210a48"></a><!-- doxytag: member="ext_proto.h::scheduler_settime" ref="gade0e21336c4b2f33046669df0d210a48" args="(void *x, double time)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void scheduler_settime </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the current time of the scheduler. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The scheduler to set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>time</em>&nbsp;</td><td>The new current time for the selected scheduler (in milliseconds). </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__clocks.html#creating_schedulers">Creating Schedulers</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gadf4bd364fd019bed91a587337eb4801e"></a><!-- doxytag: member="ext_proto.h::setclock_delay" ref="gadf4bd364fd019bed91a587337eb4801e" args="(t_object *x, void *c, long time)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setclock_delay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__object.html">t_object</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Schedule a Clock on a scheduler. </p>
<p>Schedules the Clock c to execute at time units after the current time. If scheduler x is 0 or does not point to a setclock object, the internal millisecond scheduler is used. Otherwise c is scheduled on the setclock object’s list of Clocks. The Clock should be created with <a class="el" href="group__clocks.html#ga6257ddd41904756699208f135f6539fd" title="Create a new Clock object.">clock_new()</a>, the same as for a Clock passed to <a class="el" href="group__clocks.html#ga9ac56d198904627333de740743086920" title="Schedule the execution of a Clock.">clock_delay()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>A setclock object to be used for scheduling this clock. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>Clock object containing the function to be executed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>time</em>&nbsp;</td><td>Time delay (in the units of the Setclock) from the current time when the Clock will be executed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__clocks.html#setclock">Scheduling with setclock Objects</a> </dd>
<dd>
<a class="el" href="group__clocks.html#ga91badd52e8729b007c22461368a21854" title="Schedule a Clock on a scheduler, using a floating-point time argument.">setclock_fdelay()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga91badd52e8729b007c22461368a21854"></a><!-- doxytag: member="ext_proto.h::setclock_fdelay" ref="ga91badd52e8729b007c22461368a21854" args="(t_object *s, void *c, double time)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setclock_fdelay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__object.html">t_object</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Schedule a Clock on a scheduler, using a floating-point time argument. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>A setclock object to be used for scheduling this clock. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>Clock object containing the function to be executed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>time</em>&nbsp;</td><td>Time delay (in the units of the Setclock) from the current time when the Clock will be executed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__clocks.html#setclock">Scheduling with setclock Objects</a> </dd>
<dd>
<a class="el" href="group__clocks.html#gadf4bd364fd019bed91a587337eb4801e" title="Schedule a Clock on a scheduler.">setclock_delay()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gafd1993dc69a6232cf28683961c97b9e4"></a><!-- doxytag: member="ext_proto.h::setclock_getftime" ref="gafd1993dc69a6232cf28683961c97b9e4" args="(t_object *s, double *time)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setclock_getftime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__object.html">t_object</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find out the current time value of a setclock object in floating-point milliseconds. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>A setclock object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>time</em>&nbsp;</td><td>The current time in milliseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__clocks.html#setclock">Scheduling with setclock Objects</a> </dd>
<dd>
<a class="el" href="group__clocks.html#ga1322ff3659b3d754298c636ad1856903" title="Find out the current time value of a setclock object.">setclock_gettime()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga1322ff3659b3d754298c636ad1856903"></a><!-- doxytag: member="ext_proto.h::setclock_gettime" ref="ga1322ff3659b3d754298c636ad1856903" args="(t_object *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long setclock_gettime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__object.html">t_object</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find out the current time value of a setclock object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>A setclock object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the current time value of the setclock object scheduler. If scheduler is 0, setclock_gettime is equivalent to the function gettime that returns the current value of the internal millisecond clock. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__clocks.html#setclock">Scheduling with setclock Objects</a> </dd>
<dd>
<a class="el" href="group__clocks.html#gafd1993dc69a6232cf28683961c97b9e4" title="Find out the current time value of a setclock object in floating-point milliseconds...">setclock_getftime()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gafbc6d9baa43a561b1840b8b4ce6bed5c"></a><!-- doxytag: member="ext_proto.h::setclock_unset" ref="gafbc6d9baa43a561b1840b8b4ce6bed5c" args="(t_object *x, void *c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setclock_unset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__object.html">t_object</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a Clock from a scheduler. </p>
<p>This function unschedules the Clock c in the list of Clocks in the setclock object x, or the internal millisecond scheduler if scheduler is 0.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The setclock object that was used to schedule this clock. If 0, the clock is unscheduled from the internal millisecond scheduler. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>Clock object to be removed from the scheduler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__clocks.html#setclock">Scheduling with setclock Objects</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga11fd7e2733b0186ff82e9766db3031e7"></a><!-- doxytag: member="ext_proto.h::systimer_gettime" ref="ga11fd7e2733b0186ff82e9766db3031e7" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double systimer_gettime </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>While most Max/MSP timing references "logical" time derived from Max's millisecond scheduler, time values produced by the <a class="el" href="group__clocks.html#ga11fd7e2733b0186ff82e9766db3031e7" title="While most Max/MSP timing references &quot;logical&quot; time derived from Max&#39;s...">systimer_gettime()</a> are referenced from the CPU clock and can be used to time real world events with microsecond precision. </p>
<p>The standard 'cpuclock' external in Max is a simple wrapper around this function.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the current real-world time. </dd></dl>

</div>
</div>
</div>
		<div id="c74footer">
			<p>Copyright &copy; 2008, <a href="http://www.cycling74.com/">Cycling '74</a></p>
		</div>
	</body>
</html>
