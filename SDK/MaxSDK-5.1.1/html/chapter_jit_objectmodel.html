<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
		<title>Max5 API Reference</title>
		<link href="c74-doxygen.css" rel="stylesheet" type="text/css">
	</head>
	<body>

		<div id="c74header">
			<img src="max5.png" />
			<p>Max 5 API Reference</p>
		</div>

<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="chapter_jit_objectmodel">Jitter Object Model </a></h1><h2><a class="anchor" id="chapter_jit_objectmodel_basics">
Jitter Object Model Basics</a></h2>
<p>Jitter objects use an object model which is somewhat different than the one traditionally used for developing Max external objects. The first big difference between Jitter objects and traditional Max external objects is that Jitter objects don't have any notion of the patcher themselves. This allows for the flexible instantiation and use of Jitter objects from C, Java, JavaScript, as well as in the Max patcher. The use of these Jitter objects is exposed to the patcher with a Max "wrapper" object, which will be discussed in the following chapter.</p>
<p>In this chapter we'll restrict our discussion to the fundamentals of defining the Jitter object which can be used in any of these languages. While Jitter's primary focus is matrix processing and real-time graphics, these tasks are unrelated to the object model, and will be covered in later chapters on developing Matrix Operator (MOP) and OB3D objects. Like Max objects, Jitter objects are typically written in C. While C++ can be used to develop Jitter objects, none of the object oriented language features will be used to define your object as far as Jitter is concerned. Similar to C++ or Java objects, Jitter objects are defined by a class with methods and member variables - we will refer to the member variables as "attributes". Unlike C++ or Java, there are no language facilities that manage class definition, class inheritance, or making use of class instances. In Jitter this must all be managed with sets of standard C function calls that will define your class, exercise methods, and get and set object attributes.</p>
<p>Max and Jitter implement their object models by maintaining a registry of ordinary C functions and struct members that map to methods and attributes associated with names. When some other code wishes to make use of these methods or attributes, it asks the Jitter object to look up the method or attribute in its registry based on a name. This is called dynamic binding, and is similar to Smalltalk or Objective C's object model. C++ and Java typically make use of static binding — i.e. methods and member variables are resolved at compile time rather than being dynamically looked up at run time.</p>
<h2><a class="anchor" id="chapter_jit_objectmodel_classdef">
Defining a Jitter Class</a></h2>
<p>A Jitter class is typically defined in a C function named something like your_object_name_init(). Class definition begins with a call to <a class="el" href="group__classmod.html#ga6c1c213a5c883bf32d0f22678ce2f02b" title="Creates a new class with the name specified by the name argument.">jit_class_new()</a>, which creates a new class associated with a specified name, constructor, destructor, and size in bytes of the object as stored in a C structure. This is followed by calls to <a class="el" href="group__classmod.html#gab3b84bc08f9f3ee0b29010f653c5ea77" title="Adds a named method to a class.">jit_class_addmethod()</a> and <a class="el" href="group__classmod.html#ga37e39db544b4d73596da1557e6c7563a" title="Adds an attribute to a class.">jit_class_addattr()</a>, which register methods and attributes with their corresponding names in the class. The class is finally registered with a call to <a class="el" href="group__classmod.html#ga1cf03eba09d7b3b53a8cde269c47765d" title="Registers class in the class registry.">jit_class_register()</a>. A minimal example class definition is shown below:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> <span class="keyword">struct </span>_jit_foo
{
   <a class="code" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or...">t_jit_object</a>    ob;
   <span class="keywordtype">float</span>          myval;
} t_jit_foo;

<span class="keyword">static</span> <a class="code" href="structt__class.html" title="The data structure for a Max class.">t_jit_class</a> *_jit_foo_class=NULL;

t_jit_err jit_foo_init(<span class="keywordtype">void</span>) 
{
   <span class="keywordtype">long</span> attrflags=0;
   <a class="code" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or...">t_jit_object</a> *attr;
   
   <span class="comment">// create new class named &quot;jit_foo&quot; with constructor + destructor</span>
   _jit_foo_class = <a class="code" href="group__classmod.html#ga6c1c213a5c883bf32d0f22678ce2f02b" title="Creates a new class with the name specified by the name argument.">jit_class_new</a>(<span class="stringliteral">&quot;jit_foo&quot;</span>,(<a class="code" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d" title="Function pointer type for generic methods.">method</a>)jit_foo_new,   
      (<a class="code" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d" title="Function pointer type for generic methods.">method</a>)jit_foo_free, <span class="keyword">sizeof</span>(t_jit_foo), 0L);

   <span class="comment">// add method to class</span>
   <a class="code" href="group__classmod.html#gab3b84bc08f9f3ee0b29010f653c5ea77" title="Adds a named method to a class.">jit_class_addmethod</a>(jit_foo_scream, <span class="stringliteral">&quot;scream&quot;</span>, <a class="code" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a7bd979db3dcf86909e24a1d1452e2205" title="long but defaults to zero">A_DEFLONG</a>, 0L);

   <span class="comment">// define attribute   </span>
   attr = <a class="code" href="group__objectmod.html#gabde2eb49750992ec4125af862b402342" title="Instantiates an object specified by class name.">jit_object_new</a>(      <span class="comment">// instantiate an object</span>
      _jit_sym_jit_attr_offset,   <span class="comment">// of class jit_attr_offset</span>
      <span class="stringliteral">&quot;myval&quot;</span>,         <span class="comment">// with name &quot;myval&quot;</span>
      _jit_sym_float32,       <span class="comment">// type float32</span>
      attrflags,         <span class="comment">// default flags</span>
      (<a class="code" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d" title="Function pointer type for generic methods.">method</a>)0L,         <span class="comment">// default getter accessor</span>
      (<a class="code" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d" title="Function pointer type for generic methods.">method</a>)0L,         <span class="comment">// default setter accessor</span>
      <a class="code" href="group__misc.html#gaad95899dfbc7b5b8fe11921643ef46f0" title="Find byte offset of a named member of a struct, relative to the beginning of that...">calcoffset</a>(t_jit_foo,myval)); <span class="comment">// byte offset to struct member</span>
   
   <span class="comment">// add attribute object to class</span>
   <a class="code" href="group__classmod.html#ga37e39db544b4d73596da1557e6c7563a" title="Adds an attribute to a class.">jit_class_addattr</a>(_jit_foo_class, attr);
   
   <span class="comment">// register class</span>
   <a class="code" href="group__classmod.html#ga1cf03eba09d7b3b53a8cde269c47765d" title="Registers class in the class registry.">jit_class_register</a>(_jit_foo_class);

   <span class="keywordflow">return</span> JIT_ERR_NONE;
} 

<span class="comment">// constructor</span>
t_jit_foo *jit_foo_new(<span class="keywordtype">void</span>)
{
   t_jit_foo *x;
   
   <span class="comment">// allocate object</span>
   <span class="keywordflow">if</span> (x=jit_object_alloc(_jit_foo_class))
   {
      <span class="comment">// if successful, perform any initialization</span>
      x-&gt;myval = 0;
   }
   <span class="keywordflow">return</span> x;
}

<span class="comment">// destructor</span>
<span class="keywordtype">void</span> jit_foo_free(t_jit_foo *x)
{
   <span class="comment">// would free any necessary resources here</span>
}

<span class="comment">// scream method</span>
<span class="keywordtype">void</span> jit_foo_scream(t_jit_foo *x, <span class="keywordtype">long</span> i)
{   
   <a class="code" href="group__console.html#ga3714108f42b44384b4d58009eafc1806" title="Print text to the Max window.">post</a>(<span class="stringliteral">&quot;MY VALUE IS %f! AND MY ARGUMENT IS %d&quot;</span>, x-&gt;myval, i);
}
</pre></div><p>The above example has a constructor, jit_foo_new(); a destructor, jit_foo_free(); one 32 bit floating point attribute, myval, a member of the object struct accessed with default accessor methods; and a method jit_foo_scream(), which posts the current value of myval to the Max window.</p>
<h2><a class="anchor" id="chapter_jit_objectmodel_struct">
Object Struct</a></h2>
<p>Each instance of an object occupies some region of organized memory. The C structure that defines this organization of memory is typically referred to as the "object struct". It is important that the object struct always begin with an entry of type <a class="el" href="group__jitter.html#ga0eb2cd9c8e3b9803ba31069575a1ffb9" title="object header">t_jit_object</a>. It is within the <a class="el" href="group__jitter.html#ga0eb2cd9c8e3b9803ba31069575a1ffb9" title="object header">t_jit_object</a> where special information about the class is kept. The C structure can contain additional information, either exposed as attributes or not, but it is important that the size of the object struct does not exceed 16384 bytes. This means that it is not safe to define a large array as a struct entry if it will cause the size of the object struct to be larger than this limit. If additional memory is required, the object struct should contain a pointer to memory allocated from within the constructor, and freed within the destructor.</p>
<p>The class registration in the above code makes use of the object struct both to record in the class how large each object instance should be—i.e. sizeof(t_jit_foo) ; and at what byte offset in the object struct an attribute is located—i.e. <a class="el" href="group__misc.html#gaad95899dfbc7b5b8fe11921643ef46f0" title="Find byte offset of a named member of a struct, relative to the beginning of that...">calcoffset(t_jit_foo, myval)</a> . When methods of an object are called, the instance of the object struct is passed as the first argument to the C functions which define the object methods. This instance may be thought of as similar to the "this" keyword used in C++ and Java - actually the C++ and Java underlying implementation works quite similarly to what has been implemented here in pure C. Object struct entries may be thought of as similar to object member variables, but methods must be called via functions rather than simply dereferencing instances of the class as you might do in C++ or Java. The list of object methods and other class information is referenced by your object's <a class="el" href="group__jitter.html#ga0eb2cd9c8e3b9803ba31069575a1ffb9" title="object header">t_jit_object</a> entry.</p>
<h2><a class="anchor" id="chapter_jit_objectmodel_ctordtor">
Constructor/Destructor</a></h2>
<p>The two most important methods that are required for all objects are the constructor and the destructor. These are typically named your_object_name_new(), and your_object_name_free(), respectively. It is the constructor's responsibility to allocate and initialize the object struct and any additional resources the object instance requires. The object struct is allocated via jit_object_alloc(), which also initializes the <a class="el" href="group__jitter.html#ga0eb2cd9c8e3b9803ba31069575a1ffb9" title="object header">t_jit_object</a> struct entry to point at your relevant class information. The class information resides in your global class variable, e.g. _jit_foo_class, which you pass as an argument to jit_object_alloc(). This allocation does not, however initialize the other struct entries, such as "myval", which you must explicitly initialize if your allocation is successful. Note that because the constructor allocates the object instance, no object instance is passed as the first argument to the function which defines the constructor, unlike other object methods.</p>
<p>The constructor also has the option of having a typed argument signature with the same types as defined in the Writing Max Externals documentation—i.e. <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a002f28879581a6f66ea492b994b96f1e" title="long integer">A_LONG</a>, <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a0b3aa0ab8104573dfc9cb70b5b08031f" title="32-bit float">A_FLOAT</a>, <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a2d661c2a5d949566e2f1944c99bceeea" title="t_symbol pointer">A_SYM</a>, <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a81c1a8550f038db16a619167a70a79b6" title="request that args be passed as an array, the routine will check the types itself...">A_GIMME</a>, etc. Typically, Jitter object constructors either have no arguments or use the <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a81c1a8550f038db16a619167a70a79b6" title="request that args be passed as an array, the routine will check the types itself...">A_GIMME</a> typed argument signature.</p>
<p>In earlier versions of Jitter, the constructors were often specified as private and "untyped" using the <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47af48193ec36e53b1507d81c49873c8d7a" title="cannot typecheck args">A_CANT</a> type signature. While this obsolete style of an untyped constructor will work for the exposure of a Jitter class to the patcher and C, it is now discouraged, as there must be a valid type signature for exposure of a class to Javascript or Java, though that signature may be the empty list.</p>
<p>It is the destructor's responsibility to free any resources allocated, with the exception of the object struct itself. The object struct is freed for you after your destructor exits.</p>
<h2><a class="anchor" id="chapter_jit_objectmodel_methods">
Methods</a></h2>
<p>You can define additional methods using the <a class="el" href="group__classmod.html#gab3b84bc08f9f3ee0b29010f653c5ea77" title="Adds a named method to a class.">jit_class_addmethod()</a> function. This example defines the scream method associated with the function jit_foo_scream(), with no additional arguments aside from the standard first argument of a pointer to the object struct. Just like methods for ordinary Max objects, these methods could have a typed argument signature with the same types as defined in the Writing Max Externals documentation — i.e. <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a002f28879581a6f66ea492b994b96f1e" title="long integer">A_LONG</a>, <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a0b3aa0ab8104573dfc9cb70b5b08031f" title="32-bit float">A_FLOAT</a>, <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a2d661c2a5d949566e2f1944c99bceeea" title="t_symbol pointer">A_SYM</a>, <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a81c1a8550f038db16a619167a70a79b6" title="request that args be passed as an array, the routine will check the types itself...">A_GIMME</a>. Typically in Jitter objects, public methods are specified either without arguments, or use <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a81c1a8550f038db16a619167a70a79b6" title="request that args be passed as an array, the routine will check the types itself...">A_GIMME</a>, or the low priority variants, <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a4556bc5fe0d4f8cc55eda5aeeee55cf2" title="A special signature for declaring methods. This is like A_GIMME, but the call is...">A_DEFER_LOW</a>, or <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a8c844b0a1b551341a6a5e3b95d2f1152" title="A special signature for declaring methods. This is like A_GIMME, but the call is...">A_USURP_LOW</a>, which will be discussed in following chapters. Private methods, just like their Max equivalent should be defined as untyped, using the <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47af48193ec36e53b1507d81c49873c8d7a" title="cannot typecheck args">A_CANT</a> type signature. Object methods can be called from C either by calling the C function directly, or by using <a class="el" href="group__objectmod.html#ga9e1b9b8ed4fce611de26a74c6e1452c8" title="Calls an object method specified by method name.">jit_object_method()</a> or <a class="el" href="group__objectmod.html#ga9c9b8591a887cddd19b313c8e995fbea" title="Calls a typed object method specified by method name.">jit_object_method_typed()</a>. For example, the following calls that relate to the above jit_foo example are equivalent:</p>
<div class="fragment"><pre class="fragment"><span class="comment">// call scream method directly</span>
jit_foo_scream(x, 74); 

<span class="comment">// dynamically resolve and call scream method </span>
<a class="code" href="group__objectmod.html#ga9e1b9b8ed4fce611de26a74c6e1452c8" title="Calls an object method specified by method name.">jit_object_method</a>(x, <a class="code" href="group__symbol.html#ga8268797d125a15bae1010af70b559e05" title="Given a C-string, fetch the matching t_symbol pointer from the symbol table, generating...">gensym</a>(<span class="stringliteral">&quot;scream&quot;</span>), 74); 

<span class="comment">// dynamically resolve and call scream method with typed atom arguments </span>
<a class="code" href="structt__atom.html" title="An atom is a typed datum.">t_atom</a> a[1];
<a class="code" href="group__atommod.html#ga3ba793bf8d970488f7fdee721fafcc16" title="Sets atom value to long integer.">jit_atom_setlong</a>(a, 74);
<a class="code" href="group__objectmod.html#ga9c9b8591a887cddd19b313c8e995fbea" title="Calls a typed object method specified by method name.">jit_object_method_typed</a>(x, <a class="code" href="group__symbol.html#ga8268797d125a15bae1010af70b559e05" title="Given a C-string, fetch the matching t_symbol pointer from the symbol table, generating...">gensym</a>(<span class="stringliteral">&quot;scream&quot;</span>), 1, a, NULL);
</pre></div><p>What the <a class="el" href="group__objectmod.html#ga9e1b9b8ed4fce611de26a74c6e1452c8" title="Calls an object method specified by method name.">jit_object_method()</a> and <a class="el" href="group__objectmod.html#ga9c9b8591a887cddd19b313c8e995fbea" title="Calls a typed object method specified by method name.">jit_object_method_typed()</a> functions do is look up the provided method symbol in the object's class information, and then calls the corresponding C function associated with the provided symbol. The difference between <a class="el" href="group__objectmod.html#ga9e1b9b8ed4fce611de26a74c6e1452c8" title="Calls an object method specified by method name.">jit_object_method()</a> and <a class="el" href="group__objectmod.html#ga9c9b8591a887cddd19b313c8e995fbea" title="Calls a typed object method specified by method name.">jit_object_method_typed()</a> is that <a class="el" href="group__objectmod.html#ga9e1b9b8ed4fce611de26a74c6e1452c8" title="Calls an object method specified by method name.">jit_object_method()</a> will not require that the method is typed and public, and blindly pass all of the arguments following the method symbol on to the corresponding method. For this reason, it is required that you know the signature of the method you are calling, and pass the correct arguments. This is not type checked at compile time, so you must be extremely attentive to the arguments you pass via <a class="el" href="group__objectmod.html#ga9e1b9b8ed4fce611de26a74c6e1452c8" title="Calls an object method specified by method name.">jit_object_method()</a>. It is also possible for you to define methods which have a typed return value with the <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47ad150bf3de9c8dc2ddfa0ca0ca2382360" title="request that args be passed as an array, the routine will check the types itself...">A_GIMMEBACK</a> type signature. When calling such methods, the final argument to <a class="el" href="group__objectmod.html#ga9c9b8591a887cddd19b313c8e995fbea" title="Calls a typed object method specified by method name.">jit_object_method_typed()</a>, should point to a <a class="el" href="structt__atom.html" title="An atom is a typed datum.">t_atom</a> to be filled in by the callee. This and the subject of "typed wrappers" for exposing otherwise private methods to language bindings that require typed methods (e.g. Java/!JavaScript) will be covered in a later chapter.</p>
<h2><a class="anchor" id="chapter_jit_objectmodel_attrs">
Attributes</a></h2>
<p>You can add attributes to the class with <a class="el" href="group__classmod.html#ga37e39db544b4d73596da1557e6c7563a" title="Adds an attribute to a class.">jit_class_addattr()</a>. Attributes themselves are Jitter objects which share a common interface for getting and setting values. While any class which conforms to the attribute interface could be used to define attributes of a given class, there are a few common classes which are currently used: jit_attr_offset(), which specifies a scalar attribute of a specific type (char, long, float32, float64, symbol, or atom) at some byte offset in the object struct; jit_attr_offset_array() which specifies an array (vector) attribute of a specific type (char, long, float32, float64, symbol, or atom) at some byte offset in the object struct; and jit_attribute, which is a more generic attribute object that can be instantiated on a per object basis. We will not document the usage of jit_attribute at this time. The constructor for the class jit_attr_offset() has the following prototype:</p>
<div class="fragment"><pre class="fragment"><a class="code" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or...">t_jit_object</a> *<a class="code" href="group__attrmod.html#gaf1539159e0a0bb0238b2cf9b03ac3308" title="Constructs instance of t_jit_attr_offset.">jit_attr_offset_new</a>(<span class="keywordtype">char</span> *name, <a class="code" href="structt__symbol.html" title="The symbol.">t_symbol</a> *type, <span class="keywordtype">long</span> flags,
   <a class="code" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d" title="Function pointer type for generic methods.">method</a> mget, <a class="code" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d" title="Function pointer type for generic methods.">method</a> mset, <span class="keywordtype">long</span> offset);
</pre></div><p>When this constructor is called via <a class="el" href="group__objectmod.html#gabde2eb49750992ec4125af862b402342" title="Instantiates an object specified by class name.">jit_object_new()</a>, additionally the class name, _jit_sym_jit_attr_offset (a global variable equivalent to gensym("jit_attr_offset") ) must be passed as the first parameter, followed by the above arguments, which are passed on to the constructor. The name argument specifies the attribute name as a null terminated C string. The type argument specifies the attribute type, which may be one of the following symbols: _jit_sym_char, _jit_sym_long, _jit_sym_float32, _jit_sym_float64, _jit_sym_symbol, _jit_sym_atom, _jit_sym_object, or _jit_sym_pointer. The latter two are only useful for private attributes as these types are not exposed to, or converted from Max message atom values.</p>
<p>The flags argument specifies the attribute flags, which may be a bitwise combination of the following constants:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#define JIT_ATTR_GET_OPAQUE           0x00000001 // cannot query</span>
<span class="preprocessor"></span><span class="preprocessor">#define JIT_ATTR_SET_OPAQUE           0x00000002 // cannot set</span>
<span class="preprocessor"></span><span class="preprocessor">#define JIT_ATTR_GET_OPAQUE_USER      0x00000100 // user cannot query</span>
<span class="preprocessor"></span><span class="preprocessor">#define JIT_ATTR_SET_OPAQUE_USER      0x00000200 // user cannot set</span>
<span class="preprocessor"></span><span class="preprocessor">#define JIT_ATTR_GET_DEFER            0x00010000 // (deprecated)</span>
<span class="preprocessor"></span><span class="preprocessor">#define JIT_ATTR_GET_USURP            0x00020000 // (deprecated)</span>
<span class="preprocessor"></span><span class="preprocessor">#define JIT_ATTR_GET_DEFER_LOW        0x00040000 // query in low priority</span>
<span class="preprocessor"></span><span class="preprocessor">#define JIT_ATTR_GET_USURP_LOW        0x00080000 // query in low, usurping </span>
<span class="preprocessor"></span><span class="preprocessor">#define JIT_ATTR_SET_DEFER            0x01000000 // (deprecated)</span>
<span class="preprocessor"></span><span class="preprocessor">#define JIT_ATTR_SET_USURP            0x02000000 // (deprecated)</span>
<span class="preprocessor"></span><span class="preprocessor">#define JIT_ATTR_SET_DEFER_LOW        0x04000000 // set at low priority</span>
<span class="preprocessor">#define JIT_ATTR_SET_USURP_LOW        0x08000000 // set at low, usurping</span>
</pre></div><p>Typically attributes in Jitter are defined with flags <a class="el" href="group__jitter.html#ga810447020b75b5173d4c6776cd2653d8" title="defer getter">JIT_ATTR_GET_DEFER_LOW</a>, and <a class="el" href="group__jitter.html#ga2ffda4034665d46f65461d67b1004715" title="usurp setter">JIT_ATTR_SET_USURP_LOW</a>. This means that multiple queries from the patcher will generate a response for each query, and that multiple attempts to set the value at high priority will collapse into a single call with the last received value. For more information on defer and usurp, see the chapter on Jitter scheduling issues.</p>
<p>The mget argument specifies the attribute "getter" accessor method, used to query the attribute value. If this argument is zero (NULL), then the default getter accessor will be used. If you need to define a custom accessor, it should have a prototype and form comparable to the following custom getter:</p>
<div class="fragment"><pre class="fragment">t_jit_err jit_foo_myval_get(t_jit_foo *x, <span class="keywordtype">void</span> *attr, <span class="keywordtype">long</span> *ac, <a class="code" href="structt__atom.html" title="An atom is a typed datum.">t_atom</a> **av) 
{
   <span class="keywordflow">if</span> ((*ac)&amp;&amp;(*av)) {
      <span class="comment">//memory passed in, use it</span>
   } <span class="keywordflow">else</span> {
      <span class="comment">//otherwise allocate memory</span>
      *ac = 1;
      <span class="keywordflow">if</span> (!(*av = <a class="code" href="group__memorymod.html#ga348f78687a0aabb79d772d633cc679cc" title="Allocates a pointer to memory.">jit_getbytes</a>(<span class="keyword">sizeof</span>(<a class="code" href="structt__atom.html" title="An atom is a typed datum.">t_atom</a>)*(*ac)))) {
         *ac = 0;
         <span class="keywordflow">return</span> JIT_ERR_OUT_OF_MEM;
      }
   }
   <a class="code" href="group__atommod.html#gafa6fc51c30c70d54d6dd4af45042d3bd" title="Sets atom value to floating point number.">jit_atom_setfloat</a>(*av,x-&gt;myval);
   
   <span class="keywordflow">return</span> JIT_ERR_NONE;
}
</pre></div><p>Note that getters require memory to be allocated, if there is not memory passed into the getter. Also the attr argument is the class' attribute object and can be queried using <a class="el" href="group__objectmod.html#ga9e1b9b8ed4fce611de26a74c6e1452c8" title="Calls an object method specified by method name.">jit_object_method()</a> for things like the attribute flags, names, filters, etc.. The mset argument specifies the attribute "setter" accessor method, used to set the attribute value. If this argument is zero (NULL), then the default setter accessor will be used. If we need to define a custom accessor, it should have a prototype and form comparable to the following custom setter:</p>
<div class="fragment"><pre class="fragment">t_jit_err jit_foo_myval_set(t_jit_foo *x, <span class="keywordtype">void</span> *attr, <span class="keywordtype">long</span> ac, <a class="code" href="structt__atom.html" title="An atom is a typed datum.">t_atom</a> *av) 
{
   <span class="keywordflow">if</span> (ac&amp;&amp;av) {
      x-&gt;myval = <a class="code" href="group__atommod.html#gae5882d0bf97c939882126ba235eee409" title="Retrieves atom value as floating point number.">jit_atom_getfloat</a>(av);
   } <span class="keywordflow">else</span> {
      <span class="comment">// no args, set to zero</span>
      x-&gt;myval = 0;
   }
   <span class="keywordflow">return</span> JIT_ERR_NONE;
}
</pre></div><p>The offset argument specifies the attribute's byte offset in the object struct, used by default getters and setters to automatically query and set the attribute's value. If you have both custom accessors, this value is ignored. This can be a useful strategy to employ if you wish to have an object attribute that does not correspond to any actual entry in your object struct. For example, this is how we implement the time attribute of jit.qt.movie — i.e. it uses a custom getter and setter which make QuickTime API calls to query and set the current movie time, rather than manipulating the object struct itself, where no information about movie time is actually stored. In such an instance, you should set this offset to zero.</p>
<p>After creating the attribute, it must be added to the Jitter class using the <a class="el" href="group__classmod.html#ga37e39db544b4d73596da1557e6c7563a" title="Adds an attribute to a class.">jit_class_addattr()</a> function:</p>
<div class="fragment"><pre class="fragment">t_jit_err <a class="code" href="group__classmod.html#ga37e39db544b4d73596da1557e6c7563a" title="Adds an attribute to a class.">jit_class_addattr</a>(<span class="keywordtype">void</span> *c, <a class="code" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or...">t_jit_object</a> *attr);
</pre></div><p>To put it all together: to define a jit_attribute_offset() with the custom getter and setter functions defined above, you'd make the following call:</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">long</span> attrflags = <a class="code" href="group__jitter.html#ga810447020b75b5173d4c6776cd2653d8" title="defer getter">JIT_ATTR_GET_DEFER_LOW</a> | <a class="code" href="group__jitter.html#ga2ffda4034665d46f65461d67b1004715" title="usurp setter">JIT_ATTR_SET_USURP_LOW</a>;
<a class="code" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or...">t_jit_object</a> *attr = <a class="code" href="group__objectmod.html#gabde2eb49750992ec4125af862b402342" title="Instantiates an object specified by class name.">jit_object_new</a>(_jit_sym_jit_attr_offset, <span class="stringliteral">&quot;myval&quot;</span>, _jit_sym_float32, attrflags, 
   (<a class="code" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d" title="Function pointer type for generic methods.">method</a>)jit_foo_myval_get, (<a class="code" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d" title="Function pointer type for generic methods.">method</a>)jit_foo_myval_set, NULL);
<a class="code" href="group__classmod.html#ga37e39db544b4d73596da1557e6c7563a" title="Adds an attribute to a class.">jit_class_addattr</a>(_jit_foo_class, attr);
</pre></div><p>And to define a completely standard jit_attribute_offset(), using the default getter and setter methods:</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">long</span> attrflags = <a class="code" href="group__jitter.html#ga810447020b75b5173d4c6776cd2653d8" title="defer getter">JIT_ATTR_GET_DEFER_LOW</a> | <a class="code" href="group__jitter.html#ga2ffda4034665d46f65461d67b1004715" title="usurp setter">JIT_ATTR_SET_USURP_LOW</a>;
<a class="code" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or...">t_jit_object</a> *attr = <a class="code" href="group__objectmod.html#gabde2eb49750992ec4125af862b402342" title="Instantiates an object specified by class name.">jit_object_new</a>(_jit_sym_jit_attr_offset, <span class="stringliteral">&quot;myval&quot;</span>, _jit_sym_float32, attrflags, 
   (<a class="code" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d" title="Function pointer type for generic methods.">method</a>)NULL, (<a class="code" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d" title="Function pointer type for generic methods.">method</a>)NULL, <a class="code" href="group__misc.html#gaad95899dfbc7b5b8fe11921643ef46f0" title="Find byte offset of a named member of a struct, relative to the beginning of that...">calcoffset</a>(t_jit_foo, myval));
<a class="code" href="group__classmod.html#ga37e39db544b4d73596da1557e6c7563a" title="Adds an attribute to a class.">jit_class_addattr</a>(_jit_foo_class, attr);
</pre></div><h2><a class="anchor" id="chapter_jit_objectmodel_arrayattrs">
Array Attributes</a></h2>
<p>Attributes can, in addition to referencing single values, also refer to arrays of data. The class jit_attribute_offset_array is used in this instance. The constructor for the class jit_attr_offset_array() has the following prototype:</p>
<div class="fragment"><pre class="fragment"><a class="code" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or...">t_jit_object</a> *<a class="code" href="group__attrmod.html#ga8da2f33df7efd0c23b0b7a68ec402724" title="Constructs instance of t_jit_attr_offset_array.">jit_attr_offset_array_new</a>(<span class="keywordtype">char</span> *name, <a class="code" href="structt__symbol.html" title="The symbol.">t_symbol</a> *type, <span class="keywordtype">long</span> size, 
   <span class="keywordtype">long</span> flags, <a class="code" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d" title="Function pointer type for generic methods.">method</a> mget, <a class="code" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d" title="Function pointer type for generic methods.">method</a> mset, <span class="keywordtype">long</span> offsetcount, <span class="keywordtype">long</span> offset);
</pre></div><p>When this constructor is called via <a class="el" href="group__objectmod.html#gabde2eb49750992ec4125af862b402342" title="Instantiates an object specified by class name.">jit_object_new()</a>, additionally the class name, _jit_sym_jit_attr_offset_array() (a global variable equivalent to gensym("jit_attr_offset_array") ) must be passed as the first parameter, followed by the above arguments, which are passed on to the constructor.</p>
<p>The name, type, flags, mget, mset and offset arguments are identical to those specified above.</p>
<p>The size argument specifies the maximum length of the array (the allocated size of the array in the Jitter object struct). The offsetcount specifies the byte offset in the object struct, where the actual length of the array can be queried/set. This value should be specified as a long. This value is used by default getters and setters when querying and setting the attribute's value. As with the jit_attr_offset object, if you have both custom accessors, this value is ignored.</p>
<p>The following sample listing demonstrates the creation of a simple instance of the jit_attr_offset_array() class for an object defined as:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> <span class="keyword">struct </span>_jit_foo
{
   <a class="code" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or...">t_jit_object</a>     ob;
   <span class="keywordtype">long</span>             myarray[10]; <span class="comment">// max of 10 entries in this array</span>
   <span class="keywordtype">long</span>             myarraycount; <span class="comment">// actual number being used</span>
} t_jit_foo;

<span class="keywordtype">long</span> attrflags = <a class="code" href="group__jitter.html#ga810447020b75b5173d4c6776cd2653d8" title="defer getter">JIT_ATTR_GET_DEFER_LOW</a> | <a class="code" href="group__jitter.html#ga2ffda4034665d46f65461d67b1004715" title="usurp setter">JIT_ATTR_SET_USURP_LOW</a>;
<a class="code" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or...">t_jit_object</a> *attr = <a class="code" href="group__objectmod.html#gabde2eb49750992ec4125af862b402342" title="Instantiates an object specified by class name.">jit_object_new</a>(_jit_sym_jit_attr_offset_array, <span class="stringliteral">&quot;myarray&quot;</span>, 
   _jit_sym_long, 10, attrflags, (<a class="code" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d" title="Function pointer type for generic methods.">method</a>)0L, (<a class="code" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d" title="Function pointer type for generic methods.">method</a>)0L, 
   <a class="code" href="group__misc.html#gaad95899dfbc7b5b8fe11921643ef46f0" title="Find byte offset of a named member of a struct, relative to the beginning of that...">calcoffset</a>(t_jit_foo, myarraycount), <a class="code" href="group__misc.html#gaad95899dfbc7b5b8fe11921643ef46f0" title="Find byte offset of a named member of a struct, relative to the beginning of that...">calcoffset</a>(t_jit_foo, myarray));
<a class="code" href="group__classmod.html#ga37e39db544b4d73596da1557e6c7563a" title="Adds an attribute to a class.">jit_class_addattr</a>(_jit_foo_class, attr);
</pre></div><h2><a class="anchor" id="chapter_jit_objectmodel_attrnotifications">
Attribute Notification</a></h2>
<p>Although the subject of object registration and notification will be covered in greater depth in a forthcoming chapter, it bears noting that attributes of all types (e.g. jit_attr_offset, jit_attr_offset_array and jit_attribute) will, if registered, automatically send notifications to all attached client objects, each time the attribute's value is set. </p>
</div>
		<div id="c74footer">
			<p>Copyright &copy; 2008, <a href="http://www.cycling74.com/">Cycling '74</a></p>
		</div>
	</body>
</html>
