<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
		<title>Max5 API Reference</title>
		<link href="c74-doxygen.css" rel="stylesheet" type="text/css">
	</head>
	<body>

		<div id="c74header">
			<img src="max5.png" />
			<p>Max 5 API Reference</p>
		</div>

<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Memory Management</h1>
<p>In the past, Max has provided two separate APIs for memory management.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga6ae185a510cc76224680e6156b843055">MM_UNIFIED</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This macro being defined means that getbytes and sysmem APIs for memory management are unified.  <a href="#ga6ae185a510cc76224680e6156b843055"></a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#gaa513b95a076519ec168b62d85881f643">getbytes</a> (short size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate small amounts of non-relocatable memory.  <a href="#gaa513b95a076519ec168b62d85881f643"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#gaa1dc485c42515917ca377dbaf15b7dcd">freebytes</a> (void *b, short size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free memory allocated with <a class="el" href="group__memory.html#gaa513b95a076519ec168b62d85881f643" title="Allocate small amounts of non-relocatable memory.">getbytes()</a>.  <a href="#gaa1dc485c42515917ca377dbaf15b7dcd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga198147e2629edde67218d8a759e9d5a0">getbytes16</a> (short size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use <a class="el" href="group__memory.html#ga198147e2629edde67218d8a759e9d5a0" title="Use getbytes16() to allocate small amounts of non-relocatable memory that is aligned...">getbytes16()</a> to allocate small amounts of non-relocatable memory that is aligned on a 16-byte boundary for use with vector optimization.  <a href="#ga198147e2629edde67218d8a759e9d5a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#gafba42d2b23405e29469392394cf41555">freebytes16</a> (char *mem, short size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free memory allocated with <a class="el" href="group__memory.html#ga198147e2629edde67218d8a759e9d5a0" title="Use getbytes16() to allocate small amounts of non-relocatable memory that is aligned...">getbytes16()</a>.  <a href="#gafba42d2b23405e29469392394cf41555"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga50135e5f9bb18030ff1d12e9976253ab">newhandle</a> (long size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate relocatable memory.  <a href="#ga50135e5f9bb18030ff1d12e9976253ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga6402eb4bbf3acd03d3e2f1133195bac3">growhandle</a> (void *h, long size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the size of a handle.  <a href="#ga6402eb4bbf3acd03d3e2f1133195bac3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#gae325435a83824eb6b42e0885b68b9110">disposhandle</a> (char **h)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free the memory used by a handle you no longer need.  <a href="#gae325435a83824eb6b42e0885b68b9110"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__datatypes.html#ga70766a030fcd392d4574fa59b296a68e">t_ptr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga276676be214edff9fe5c9d0681f39ae6">sysmem_newptr</a> (long size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate memory.  <a href="#ga276676be214edff9fe5c9d0681f39ae6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__datatypes.html#ga70766a030fcd392d4574fa59b296a68e">t_ptr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga1c178a079247f715c6e34c828d375324">sysmem_newptrclear</a> (long size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate memory and set it to zero.  <a href="#ga1c178a079247f715c6e34c828d375324"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__datatypes.html#ga70766a030fcd392d4574fa59b296a68e">t_ptr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#gacad6bca165c7b2849fc81d8449245755">sysmem_resizeptr</a> (void *ptr, long newsize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resize an existing pointer.  <a href="#gacad6bca165c7b2849fc81d8449245755"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__datatypes.html#ga70766a030fcd392d4574fa59b296a68e">t_ptr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#gaf458ca679d665984dbaa8125c88a417e">sysmem_resizeptrclear</a> (void *ptr, long newsize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resize an existing pointer and clear it.  <a href="#gaf458ca679d665984dbaa8125c88a417e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga4f847713a1bd083030d60e8752d7c28d">sysmem_ptrsize</a> (void *ptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the size of a pointer.  <a href="#ga4f847713a1bd083030d60e8752d7c28d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga200c82639e547869db1f3887d17102d3">sysmem_freeptr</a> (void *ptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free memory allocated with <a class="el" href="group__memory.html#ga276676be214edff9fe5c9d0681f39ae6" title="Allocate memory.">sysmem_newptr()</a>.  <a href="#ga200c82639e547869db1f3887d17102d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga527cceb7178a110b73ca01fdc41702b4">sysmem_copyptr</a> (const void *src, void *dst, long bytes)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy memory the contents of one pointer to another pointer.  <a href="#ga527cceb7178a110b73ca01fdc41702b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#gacdacfad4785c71dc8c4ce5d4d9714d54">sysmem_newhandle</a> (long size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a handle (a pointer to a pointer).  <a href="#gacdacfad4785c71dc8c4ce5d4d9714d54"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga56406e70880d954e3d51b87e606c1398">sysmem_newhandleclear</a> (unsigned long size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a handle (a pointer to a pointer) whose memory is set to zero.  <a href="#ga56406e70880d954e3d51b87e606c1398"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga420520dda6015ec33876b18b860083dd">sysmem_resizehandle</a> (<a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a> handle, long newsize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resize an existing handle.  <a href="#ga420520dda6015ec33876b18b860083dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga84cf5e5a070edef2834faf3b7beed5fe">sysmem_handlesize</a> (<a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a> handle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the size of a handle.  <a href="#ga84cf5e5a070edef2834faf3b7beed5fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga5815994f7d02b77c24f8c684df9acd83">sysmem_freehandle</a> (<a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a> handle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free memory allocated with <a class="el" href="group__memory.html#gacdacfad4785c71dc8c4ce5d4d9714d54" title="Allocate a handle (a pointer to a pointer).">sysmem_newhandle()</a>.  <a href="#ga5815994f7d02b77c24f8c684df9acd83"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga545ea0e5d3d8f14bda62f8ac6b3e6d71">sysmem_lockhandle</a> (<a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a> handle, long lock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the locked/unlocked state of a handle.  <a href="#ga545ea0e5d3d8f14bda62f8ac6b3e6d71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#gab59295d789b6a720b9ab981a39441cbc">sysmem_ptrandhand</a> (void *p, <a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a> h, long size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add memory to an existing handle and copy memory to the resized portion from a pointer.  <a href="#gab59295d789b6a720b9ab981a39441cbc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga52dd152965c42f6b1e14cfdf8b102a30">sysmem_ptrbeforehand</a> (void *p, <a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a> h, unsigned long size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add memory to an existing handle and copy memory to the resized portion from a pointer.  <a href="#ga52dd152965c42f6b1e14cfdf8b102a30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga2d07c8171a047d92e8bd95f8bb5b2a70">sysmem_nullterminatehandle</a> (<a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a> h)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a null terminator to a handle.  <a href="#ga2d07c8171a047d92e8bd95f8bb5b2a70"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>In the past, Max has provided two separate APIs for memory management. </p>
<p>One for allocating memory on the stack so that it was interrupt safe, including the <a class="el" href="group__memory.html#gaa513b95a076519ec168b62d85881f643" title="Allocate small amounts of non-relocatable memory.">getbytes()</a> and <a class="el" href="group__memory.html#gaa1dc485c42515917ca377dbaf15b7dcd" title="Free memory allocated with getbytes().">freebytes()</a> functions. The other, the "sysmem" API, were for allocating memory on the heap where larger amounts of memory were needed and the code could be guaranteed to operate at non-interrupt level.</p>
<p>Many things have changed in the environment of recent operating systems (MacOS X and Windows XP/Vista), the memory routines function differently, and the scheduler is no longer directly triggered by a hardware interrupt. In Max 5, the sysmem and getbytes API's have been unified, and thus may be used interchangeably.</p>
<p>The memory management unification can be switched on and off in the header files if needed, to compile code for older versions of Max for example, by changing the use of <a class="el" href="group__memory.html#ga6ae185a510cc76224680e6156b843055" title="This macro being defined means that getbytes and sysmem APIs for memory management...">MM_UNIFIED</a> in the Max headers.</p>
<h2><a class="anchor" id="The">
Sysmem API</a></h2>
<p>The Sysmem API provides a number of utilities for allocating and managing memory. It is relatively similar to some of the Macintosh Memory Manager API, and not too different from Standard C library memory functions. It is <em>not</em> safe to mix these routines with other memory routines (e.g. donâ€™t use malloc() to allocate a pointer, and <a class="el" href="group__memory.html#ga200c82639e547869db1f3887d17102d3" title="Free memory allocated with sysmem_newptr().">sysmem_freeptr()</a> to free it). </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga6ae185a510cc76224680e6156b843055"></a><!-- doxytag: member="ext.h::MM_UNIFIED" ref="ga6ae185a510cc76224680e6156b843055" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MM_UNIFIED</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This macro being defined means that getbytes and sysmem APIs for memory management are unified. </p>
<p>This is correct for Max 5, but should be commented out when compiling for old max targets. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gae325435a83824eb6b42e0885b68b9110"></a><!-- doxytag: member="ext_proto.h::disposhandle" ref="gae325435a83824eb6b42e0885b68b9110" args="(char **h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void disposhandle </td>
          <td>(</td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>h</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free the memory used by a handle you no longer need. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td>The handle to dispose. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__memory.html#ga5815994f7d02b77c24f8c684df9acd83" title="Free memory allocated with sysmem_newhandle().">sysmem_freehandle()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa1dc485c42515917ca377dbaf15b7dcd"></a><!-- doxytag: member="ext_proto.h::freebytes" ref="gaa1dc485c42515917ca377dbaf15b7dcd" args="(void *b, short size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freebytes </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free memory allocated with <a class="el" href="group__memory.html#gaa513b95a076519ec168b62d85881f643" title="Allocate small amounts of non-relocatable memory.">getbytes()</a>. </p>
<p>As of Max 5 it is unified with <a class="el" href="group__memory.html#ga276676be214edff9fe5c9d0681f39ae6" title="Allocate memory.">sysmem_newptr()</a>, which is the preferred method for allocating memory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>A pointer to the block of memory previously allocated that you want to free. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The size the block specified (as parameter b) in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafba42d2b23405e29469392394cf41555"></a><!-- doxytag: member="ext_proto.h::freebytes16" ref="gafba42d2b23405e29469392394cf41555" args="(char *mem, short size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freebytes16 </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free memory allocated with <a class="el" href="group__memory.html#ga198147e2629edde67218d8a759e9d5a0" title="Use getbytes16() to allocate small amounts of non-relocatable memory that is aligned...">getbytes16()</a>. </p>
<p>As of Max 5 it is unified with <a class="el" href="group__memory.html#ga276676be214edff9fe5c9d0681f39ae6" title="Allocate memory.">sysmem_newptr()</a>, which is the preferred method for allocating memory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mem</em>&nbsp;</td><td>A pointer to the block of memory previously allocated that you want to free. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The size the block specified (as parameter b) in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Note that <a class="el" href="group__memory.html#gafba42d2b23405e29469392394cf41555" title="Free memory allocated with getbytes16().">freebytes16()</a> will cause memory corruption if you pass it memory that was allocated with <a class="el" href="group__memory.html#gaa513b95a076519ec168b62d85881f643" title="Allocate small amounts of non-relocatable memory.">getbytes()</a>. Use it only with memory allocated with <a class="el" href="group__memory.html#ga198147e2629edde67218d8a759e9d5a0" title="Use getbytes16() to allocate small amounts of non-relocatable memory that is aligned...">getbytes16()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa513b95a076519ec168b62d85881f643"></a><!-- doxytag: member="ext_proto.h::getbytes" ref="gaa513b95a076519ec168b62d85881f643" args="(short size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* getbytes </td>
          <td>(</td>
          <td class="paramtype">short&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate small amounts of non-relocatable memory. </p>
<p>As of Max 5 it is unified with <a class="el" href="group__memory.html#ga276676be214edff9fe5c9d0681f39ae6" title="Allocate memory.">sysmem_newptr()</a>, which is the preferred method for allocating memory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The size to allocate in bytes (up to 32767 bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the allocated memory. </dd></dl>

</div>
</div>
<a class="anchor" id="ga198147e2629edde67218d8a759e9d5a0"></a><!-- doxytag: member="ext_proto.h::getbytes16" ref="ga198147e2629edde67218d8a759e9d5a0" args="(short size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* getbytes16 </td>
          <td>(</td>
          <td class="paramtype">short&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use <a class="el" href="group__memory.html#ga198147e2629edde67218d8a759e9d5a0" title="Use getbytes16() to allocate small amounts of non-relocatable memory that is aligned...">getbytes16()</a> to allocate small amounts of non-relocatable memory that is aligned on a 16-byte boundary for use with vector optimization. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The size to allocate in bytes (up to 32767 bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the allocated memory.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><a class="el" href="group__memory.html#ga198147e2629edde67218d8a759e9d5a0" title="Use getbytes16() to allocate small amounts of non-relocatable memory that is aligned...">getbytes16()</a> is identical to getbytes except that it returns memory that is aligned to a 16-byte boundary. This allows you to allocate storage for vector-optimized memory at interrupt level. Note that any memory allocated with <a class="el" href="group__memory.html#ga198147e2629edde67218d8a759e9d5a0" title="Use getbytes16() to allocate small amounts of non-relocatable memory that is aligned...">getbytes16()</a> must be freed with <a class="el" href="group__memory.html#gafba42d2b23405e29469392394cf41555" title="Free memory allocated with getbytes16().">freebytes16()</a>, not <a class="el" href="group__memory.html#gaa1dc485c42515917ca377dbaf15b7dcd" title="Free memory allocated with getbytes().">freebytes()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6402eb4bbf3acd03d3e2f1133195bac3"></a><!-- doxytag: member="ext_proto.h::growhandle" ref="ga6402eb4bbf3acd03d3e2f1133195bac3" args="(void *h, long size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short growhandle </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the size of a handle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td>The handle to resize. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The new size to allocate in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Ignored. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__memory.html#ga420520dda6015ec33876b18b860083dd" title="Resize an existing handle.">sysmem_resizehandle()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga50135e5f9bb18030ff1d12e9976253ab"></a><!-- doxytag: member="ext_proto.h::newhandle" ref="ga50135e5f9bb18030ff1d12e9976253ab" args="(long size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** newhandle </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate relocatable memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The size to allocate in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The allocated handle. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__memory.html#gacdacfad4785c71dc8c4ce5d4d9714d54" title="Allocate a handle (a pointer to a pointer).">sysmem_newhandle()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga527cceb7178a110b73ca01fdc41702b4"></a><!-- doxytag: member="ext_sysmem.h::sysmem_copyptr" ref="ga527cceb7178a110b73ca01fdc41702b4" args="(const void *src, void *dst, long bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sysmem_copyptr </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>bytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy memory the contents of one pointer to another pointer. </p>
<p>This function is similar to BlockMove() or memcpy(). It copies the contents of the memory from the source to the destination pointer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>A pointer to the memory whose bytes will be copied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>A pointer to the memory where the data will be copied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bytes</em>&nbsp;</td><td>The size in bytes of the data to be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5815994f7d02b77c24f8c684df9acd83"></a><!-- doxytag: member="ext_sysmem.h::sysmem_freehandle" ref="ga5815994f7d02b77c24f8c684df9acd83" args="(t_handle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sysmem_freehandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free memory allocated with <a class="el" href="group__memory.html#gacdacfad4785c71dc8c4ce5d4d9714d54" title="Allocate a handle (a pointer to a pointer).">sysmem_newhandle()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>The handle whose memory will be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga200c82639e547869db1f3887d17102d3"></a><!-- doxytag: member="ext_sysmem.h::sysmem_freeptr" ref="ga200c82639e547869db1f3887d17102d3" args="(void *ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sysmem_freeptr </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free memory allocated with <a class="el" href="group__memory.html#ga276676be214edff9fe5c9d0681f39ae6" title="Allocate memory.">sysmem_newptr()</a>. </p>
<p>This function is similar to DisposePtr or free. It frees the memory that had been allocated to the given pointer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>The pointer whose memory will be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga84cf5e5a070edef2834faf3b7beed5fe"></a><!-- doxytag: member="ext_sysmem.h::sysmem_handlesize" ref="ga84cf5e5a070edef2834faf3b7beed5fe" args="(t_handle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long sysmem_handlesize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the size of a handle. </p>
<p>This function is similar to GetHandleSize().</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>The handle whose size will be queried. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes allocated to the specified handle. </dd></dl>

</div>
</div>
<a class="anchor" id="ga545ea0e5d3d8f14bda62f8ac6b3e6d71"></a><!-- doxytag: member="ext_sysmem.h::sysmem_lockhandle" ref="ga545ea0e5d3d8f14bda62f8ac6b3e6d71" args="(t_handle handle, long lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long sysmem_lockhandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>lock</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the locked/unlocked state of a handle. </p>
<p>This function is similar to HLock or HUnlock. It sets the lock state of a handle, using a zero or non-zero number.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>The handle that will be locked. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lock</em>&nbsp;</td><td>The new lock state of the handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The previous lock state. </dd></dl>

</div>
</div>
<a class="anchor" id="gacdacfad4785c71dc8c4ce5d4d9714d54"></a><!-- doxytag: member="ext_sysmem.h::sysmem_newhandle" ref="gacdacfad4785c71dc8c4ce5d4d9714d54" args="(long size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a> sysmem_newhandle </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a handle (a pointer to a pointer). </p>
<p>This function is similar to NewHandle(). It allocates a handle of a given number of bytes and returns a <a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad" title="Generic pointer-to-a-pointer type.">t_handle</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The size of the handle in bytes that will be allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new <a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad" title="Generic pointer-to-a-pointer type.">t_handle</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga56406e70880d954e3d51b87e606c1398"></a><!-- doxytag: member="ext_sysmem.h::sysmem_newhandleclear" ref="ga56406e70880d954e3d51b87e606c1398" args="(unsigned long size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a> sysmem_newhandleclear </td>
          <td>(</td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a handle (a pointer to a pointer) whose memory is set to zero. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The size of the handle in bytes that will be allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new <a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad" title="Generic pointer-to-a-pointer type.">t_handle</a>. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__memory.html#gacdacfad4785c71dc8c4ce5d4d9714d54" title="Allocate a handle (a pointer to a pointer).">sysmem_newhandle()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga276676be214edff9fe5c9d0681f39ae6"></a><!-- doxytag: member="ext_sysmem.h::sysmem_newptr" ref="ga276676be214edff9fe5c9d0681f39ae6" args="(long size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__datatypes.html#ga70766a030fcd392d4574fa59b296a68e">t_ptr</a> sysmem_newptr </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate memory. </p>
<p>This function is similar to NewPtr() or malloc(). It allocates a pointer of a given number of bytes and returns a pointer to the memory allocated.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The amount of memory to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the allocated memory, or NULL if the allocation fails. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1c178a079247f715c6e34c828d375324"></a><!-- doxytag: member="ext_sysmem.h::sysmem_newptrclear" ref="ga1c178a079247f715c6e34c828d375324" args="(long size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__datatypes.html#ga70766a030fcd392d4574fa59b296a68e">t_ptr</a> sysmem_newptrclear </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate memory and set it to zero. </p>
<p>This function is similar to NewPtrClear() or calloc(). It allocates a pointer of a given number of bytes, zeroing all memory, and returns a pointer to the memory allocated.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The amount of memory to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the allocated memory, or NULL if the allocation fails. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2d07c8171a047d92e8bd95f8bb5b2a70"></a><!-- doxytag: member="ext_sysmem.h::sysmem_nullterminatehandle" ref="ga2d07c8171a047d92e8bd95f8bb5b2a70" args="(t_handle h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long sysmem_nullterminatehandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a>&nbsp;</td>
          <td class="paramname"> <em>h</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a null terminator to a handle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td>A handle to null terminate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An error code. </dd></dl>

</div>
</div>
<a class="anchor" id="gab59295d789b6a720b9ab981a39441cbc"></a><!-- doxytag: member="ext_sysmem.h::sysmem_ptrandhand" ref="gab59295d789b6a720b9ab981a39441cbc" args="(void *p, t_handle h, long size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long sysmem_ptrandhand </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a>&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add memory to an existing handle and copy memory to the resized portion from a pointer. </p>
<p>This function is similar to PtrAndHand(). It resizes an existing handle by adding a given number of bytes to it and copies data from a pointer into those bytes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>The existing pointer whose data will be copied into the resized handle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td>The handle which will be enlarged by the size of the pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The size in bytes that will be added to the handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes allocated to the specified handle. </dd></dl>

</div>
</div>
<a class="anchor" id="ga52dd152965c42f6b1e14cfdf8b102a30"></a><!-- doxytag: member="ext_sysmem.h::sysmem_ptrbeforehand" ref="ga52dd152965c42f6b1e14cfdf8b102a30" args="(void *p, t_handle h, unsigned long size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long sysmem_ptrbeforehand </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a>&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add memory to an existing handle and copy memory to the resized portion from a pointer. </p>
<p>Unlike <a class="el" href="group__memory.html#gab59295d789b6a720b9ab981a39441cbc" title="Add memory to an existing handle and copy memory to the resized portion from a pointer...">sysmem_ptrandhand()</a>, however, this copies the ptr before the previously exising handle data.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>The existing pointer whose data will be copied into the resized handle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td>The handle which will be enlarged by the size of the pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The size in bytes that will be added to the handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4f847713a1bd083030d60e8752d7c28d"></a><!-- doxytag: member="ext_sysmem.h::sysmem_ptrsize" ref="ga4f847713a1bd083030d60e8752d7c28d" args="(void *ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long sysmem_ptrsize </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the size of a pointer. </p>
<p>This function is similar to _msize().</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>The pointer whose size will be queried </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes allocated to the pointer specified. </dd></dl>

</div>
</div>
<a class="anchor" id="ga420520dda6015ec33876b18b860083dd"></a><!-- doxytag: member="ext_sysmem.h::sysmem_resizehandle" ref="ga420520dda6015ec33876b18b860083dd" args="(t_handle handle, long newsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long sysmem_resizehandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>newsize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resize an existing handle. </p>
<p>This function is similar to SetHandleSize(). It resizes an existing handle to the size specified.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>The handle that will be resized. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newsize</em>&nbsp;</td><td>The new size of the handle in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes allocated to the specified handle. </dd></dl>

</div>
</div>
<a class="anchor" id="gacad6bca165c7b2849fc81d8449245755"></a><!-- doxytag: member="ext_sysmem.h::sysmem_resizeptr" ref="gacad6bca165c7b2849fc81d8449245755" args="(void *ptr, long newsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__datatypes.html#ga70766a030fcd392d4574fa59b296a68e">t_ptr</a> sysmem_resizeptr </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>newsize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resize an existing pointer. </p>
<p>This function is similar to realloc(). It resizes an existing pointer and returns a new pointer to the resized memory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>The pointer to the memory that will be resized. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newsize</em>&nbsp;</td><td>The new size of the pointer in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the resized memory, or NULL if the allocation fails. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf458ca679d665984dbaa8125c88a417e"></a><!-- doxytag: member="ext_sysmem.h::sysmem_resizeptrclear" ref="gaf458ca679d665984dbaa8125c88a417e" args="(void *ptr, long newsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__datatypes.html#ga70766a030fcd392d4574fa59b296a68e">t_ptr</a> sysmem_resizeptrclear </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>newsize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resize an existing pointer and clear it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>The pointer to the memory that will be resized. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newsize</em>&nbsp;</td><td>The new size of the pointer in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the resized memory, or NULL if the allocation fails. </dd></dl>

</div>
</div>
</div>
		<div id="c74footer">
			<p>Copyright &copy; 2008, <a href="http://www.cycling74.com/">Cycling '74</a></p>
		</div>
	</body>
</html>
