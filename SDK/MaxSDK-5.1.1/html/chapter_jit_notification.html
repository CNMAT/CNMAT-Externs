<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
		<title>Max5 API Reference</title>
		<link href="c74-doxygen.css" rel="stylesheet" type="text/css">
	</head>
	<body>

		<div id="c74header">
			<img src="max5.png" />
			<p>Max 5 API Reference</p>
		</div>

<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="chapter_jit_notification">Jitter Object Registration and Notification </a></h1><p>In Jitter, matrices are passed around as named references between Max objects.</p>
<p>This named reference is created since Jitter registers these matrices with the corresponding name using the <a class="el" href="group__objectmod.html#gabcf088a00f36b6af8ce5896b81e4d0ef" title="Registers an object in the named object registry.">jit_object_register()</a> function. Object registration is useful for a few reasons. First, registered matrices can be resolved by name using the <a class="el" href="group__objectmod.html#ga328c0beb469f32437b756852fe8583bf" title="Retrieves a registered object associated with name.">jit_object_findregistered()</a> function. Secondly, registered objects can sent event notification to clients who have attached to them using <a class="el" href="group__objectmod.html#ga213166e8beeb29aca36c57cd07c722f1" title="Attaches an object as a client of a named server object for notification.">jit_object_attach()</a>. Lastly, under certain circumstances, the object registration process can be used to have multiple external references to a single instance of an object as is the case with jit.matrix.</p>
<h2><a class="anchor" id="chapter_jit_notification_reg">
Registering Named Objects</a></h2>
<p>To register an object, one can use the <a class="el" href="group__objectmod.html#gabcf088a00f36b6af8ce5896b81e4d0ef" title="Registers an object in the named object registry.">jit_object_register()</a> function, which is equivalent to the Max <a class="el" href="group__obj.html#gaaa97beba179d6aebd3f3ede1b5c781fa" title="Registers an object in a namespace.">object_register()</a> function in the namespace associated with gensym("jitter"). For more information about <a class="el" href="group__obj.html#gaaa97beba179d6aebd3f3ede1b5c781fa" title="Registers an object in a namespace.">object_register()</a>, please consult the Pattr SDK, which covers this and other aspects of Max's new "obex" object model. Traditionally in Jitter, we bind <a class="el" href="group__objectmod.html#gabcf088a00f36b6af8ce5896b81e4d0ef" title="Registers an object in the named object registry.">jit_object_register()</a> to the "register" method for an object and use <a class="el" href="group__objectmod.html#ga9e1b9b8ed4fce611de26a74c6e1452c8" title="Calls an object method specified by method name.">jit_object_method()</a> to call this method. For example, from the jit.notify SDK example:</p>
<div class="fragment"><pre class="fragment"><span class="comment">// allocate the Jitter object</span>
<span class="keywordflow">if</span> (o=<a class="code" href="group__objectmod.html#gabde2eb49750992ec4125af862b402342" title="Instantiates an object specified by class name.">jit_object_new</a>(<a class="code" href="group__symbol.html#ga8268797d125a15bae1010af70b559e05" title="Given a C-string, fetch the matching t_symbol pointer from the symbol table, generating...">gensym</a>(<span class="stringliteral">&quot;jit_notify&quot;</span>))) {
   ...
   <span class="comment">// generate a unique name</span>
   x-&gt;servername = jit_symbol_unique(); 

   <span class="comment">// register the object with the given name</span>
   <a class="code" href="group__objectmod.html#ga9e1b9b8ed4fce611de26a74c6e1452c8" title="Calls an object method specified by method name.">jit_object_method</a>(o,_jit_sym_register,x-&gt;servername); 
   ...
}      
</pre></div><p>If not using a specific name, it is good to use the jit_symbol_unique() function as above to generate a unique name which is slated for re-use once a registered object is freed. This prevents excess memory usage by the symbol table as associated with these unique names.</p>
<p>If you wish the object to have multiple references to a single instance with some name, as is common with the jit.matrix object, it is essential to use the return value of <a class="el" href="group__objectmod.html#gabcf088a00f36b6af8ce5896b81e4d0ef" title="Registers an object in the named object registry.">jit_object_register()</a> in any instance where the object pointer is saved after registration. This is because if the registered object with the same class already exists, the object attempting to be registered will be freed, and the already registered object of the same class will be returned, its reference count having been incremented. This is not typically an issue outside of registering jit.matrix objects, although you may have a need for this type of implementation in other situations. Most other situations in which object registration is used within Jitter only expects and/or permits a single instance to be registered. In the above example, we know that this is safe to do, as we are using jit_symbol_unique() to generate a unique name.</p>
<p>It is also possible to unregister named objects, with the <a class="el" href="group__objectmod.html#ga21f77a08c1a98aaf68e4b2913487be0f" title="Unregisters an object from the named object registry.">jit_object_unregister()</a> function, but typically this is handled for you when your object is freed, or if your object is registered again with a different name. This is not often used in the Jitter code base except within these contexts.</p>
<h2><a class="anchor" id="chapter_jit_notification_lookup">
Looking Up an Object by Name</a></h2>
<p>Registered objects can be found by name using the <a class="el" href="group__objectmod.html#ga328c0beb469f32437b756852fe8583bf" title="Retrieves a registered object associated with name.">jit_object_findregistered()</a> function. For example named matrices are resolved using this function. Most Matrix Operator objects have this done for them by the default MOP code, but for example any MOP which has its own jit_matrix method, such as the jit.pack SDK example will make use of <a class="el" href="group__objectmod.html#ga328c0beb469f32437b756852fe8583bf" title="Retrieves a registered object associated with name.">jit_object_findregistered()</a> inside its jit_matrix method:</p>
<div class="fragment"><pre class="fragment"><span class="comment">// get our matrix name from the atom arguments provided</span>
matrixname = <a class="code" href="group__atommod.html#ga73b81472812e4c5475d07d9914d84f89" title="Retrieves atom value as symbol pointer.">jit_atom_getsym</a>(argv);

<span class="comment">// look up based on name</span>
matrix = <a class="code" href="group__objectmod.html#ga328c0beb469f32437b756852fe8583bf" title="Retrieves a registered object associated with name.">jit_object_findregistered</a>(matrixname);

<span class="comment">// make sure that it is a valid pointer and has a &quot;class_jit_matrix&quot; method which returns 1</span>
<span class="keywordflow">if</span> (matrix&amp;&amp;<a class="code" href="group__objectmod.html#ga9e1b9b8ed4fce611de26a74c6e1452c8" title="Calls an object method specified by method name.">jit_object_method</a>(matrix, _jit_sym_class_jit_matrix)) {
   ...
}    
</pre></div><h2><a class="anchor" id="chapter_jit_notification_attach">
Attaching to Named Objects</a></h2>
<p>Once an object has been registered, it can be considered a server to which clients attach to be notified of various events. To attach to a named object, use the the <a class="el" href="group__objectmod.html#ga213166e8beeb29aca36c57cd07c722f1" title="Attaches an object as a client of a named server object for notification.">jit_object_attach()</a> function. Similarly to detach from a named object, use the <a class="el" href="group__objectmod.html#gaa286218b643371fe28cbe261facd5b21" title="Detaches a client object from a named server object.">jit_object_detach()</a> function. It is typical to detach from a server in your object's destructor, or any time your object is switching which server it is attached to. For your client object to receive any notification from the server object, it is important for your object to have defined a "notify" method which will receive the notification from all objects it is attached to.</p>
<p>Below is the jit.notify SDK example's max wrapper object's notify method, which receives some atom values from its internal Jitter object instance. Since this object is a Matrix Operator, it is important in the following example that jit.notify calls the <a class="el" href="group__maxmopmod.html#ga7e08584771f58ce1fe0b190d27b5759b" title="Adds default methods and attributes to the MOP Max wrapper class.">max_jit_classex_mop_wrap()</a> function with the <a class="el" href="group__jitter.html#ga669c2f28bba1dfb4181ebae8f19488bc" title="mop flag">MAX_JIT_MOP_FLAGS_OWN_NOTIFY</a> flag to override the default MOP notify method, and that we pass on all other messages to the standard <a class="el" href="group__maxmopmod.html#ga5032d682c77bcb7e2dcdf0e77d863d3c" title="Default notify method for a MOP Max wrapper object.">max_jit_mop_notify()</a> method so that the default MOP code is informed of any changes to the input and output matrices.</p>
<div class="fragment"><pre class="fragment"><span class="comment">// s is the servername, msg is the message, ob is the server object pointer, </span>
<span class="comment">// and data is extra data the server might provide for a given message</span>
<span class="keywordtype">void</span> max_jit_notify_notify(t_max_jit_notify *x, <a class="code" href="structt__symbol.html" title="The symbol.">t_symbol</a> *s, <a class="code" href="structt__symbol.html" title="The symbol.">t_symbol</a> *msg, <span class="keywordtype">void</span> *ob, <span class="keywordtype">void</span> *data)
{
   <span class="keywordflow">if</span> (msg==<a class="code" href="group__symbol.html#ga8268797d125a15bae1010af70b559e05" title="Given a C-string, fetch the matching t_symbol pointer from the symbol table, generating...">gensym</a>(<span class="stringliteral">&quot;splat&quot;</span>)) {
      <a class="code" href="group__console.html#ga3714108f42b44384b4d58009eafc1806" title="Print text to the Max window.">post</a>(<span class="stringliteral">&quot;notify: server=%s message=%s&quot;</span>,s-&gt;<a class="code" href="structt__symbol.html#ae2bf70cea045897c171f39116bf536c8" title="name: a c-string">s_name</a>,msg-&gt;<a class="code" href="structt__symbol.html#ae2bf70cea045897c171f39116bf536c8" title="name: a c-string">s_name</a>);
      <span class="keywordflow">if</span> (!data) {
         <a class="code" href="group__console.html#gaa7733e30b2951f225e24dca1ed4632b2" title="Print an error to the Max window.">error</a>(<span class="stringliteral">&quot;splat message NULL pointer&quot;</span>);
         <span class="keywordflow">return</span>;
      }
      <span class="comment">// here&apos;s where we output using the rightmost outlet</span>
      <span class="comment">// we just happen to know that &quot;data&quot; points to a t_atom[3]</span>
      <span class="comment">// alternately you could use max_jit_obex_dumpout_get just to get </span>
      <span class="comment">// the outlet pointer</span>
      <a class="code" href="group__maxwrapmod.html#ga161cd54f4612d26057e4140b56e14729" title="Sends a message and arguments out the dump outlet.">max_jit_obex_dumpout</a>(x,msg,3,(<a class="code" href="structt__atom.html" title="An atom is a typed datum.">t_atom</a> *)data); 
   } <span class="keywordflow">else</span> {
      <span class="comment">// since we are a MOP, we are also attached to all the matrices for each input/output</span>
      <span class="comment">// so we need to deal with this by calling the default mop notify method </span>
      <span class="comment">// (this is how mops handle their matrices getting new names/freed/modified)</span>
      <a class="code" href="group__maxmopmod.html#ga5032d682c77bcb7e2dcdf0e77d863d3c" title="Default notify method for a MOP Max wrapper object.">max_jit_mop_notify</a>(x,s,msg);
   }
}
</pre></div><h2><a class="anchor" id="chapter_jit_notification_notify">
Notifying Clients</a></h2>
<p>If you are making an object which is to be registered, and wish to send custom notification to clients in addition to the default notification that attributes send to all clients when the attribute is modified, and the default object free notification, then you will want to use the <a class="el" href="group__objectmod.html#ga4bbd50b2d1e34de44d36e1a66a477b9f" title="Notifies all client objects for a named server object.">jit_object_notify()</a> function. This function lets you determine a message name to use for notification and optionally specify additional, but untyped data to all clients. If you choose to send additional data to clients, it is necessary for all client code to know how to unpack this information. Below is the example from the jit.notify SDK example which uses the notification mechanism to send some data to its max wrapper object:</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="structt__atom.html" title="An atom is a typed datum.">t_atom</a> foo[3];
 
    <a class="code" href="group__atommod.html#ga3ba793bf8d970488f7fdee721fafcc16" title="Sets atom value to long integer.">jit_atom_setlong</a>(&amp;foo[0],1);
    <a class="code" href="group__atommod.html#ga3ba793bf8d970488f7fdee721fafcc16" title="Sets atom value to long integer.">jit_atom_setlong</a>(&amp;foo[1],2);
    <a class="code" href="group__atommod.html#ga3ba793bf8d970488f7fdee721fafcc16" title="Sets atom value to long integer.">jit_atom_setlong</a>(&amp;foo[2],3);
    <a class="code" href="group__objectmod.html#ga4bbd50b2d1e34de44d36e1a66a477b9f" title="Notifies all client objects for a named server object.">jit_object_notify</a>(x,<a class="code" href="group__symbol.html#ga8268797d125a15bae1010af70b559e05" title="Given a C-string, fetch the matching t_symbol pointer from the symbol table, generating...">gensym</a>(<span class="stringliteral">&quot;splat&quot;</span>), foo);
</pre></div> </div>
		<div id="c74footer">
			<p>Copyright &copy; 2008, <a href="http://www.cycling74.com/">Cycling '74</a></p>
		</div>
	</body>
</html>
