<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
		<title>Max5 API Reference</title>
		<link href="c74-doxygen.css" rel="stylesheet" type="text/css">
	</head>
	<body>

		<div id="c74header">
			<img src="max5.png" />
			<p>Max 5 API Reference</p>
		</div>

<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="chapter_jit_mopqs">Matrix Operator QuickStart </a></h1><p>The purpose of this chapter is to give a quick and high level overview of how to develop a simple Matrix Operator (MOP), which can process the matrix type most commonly used for video streamsâ€”i.e.</p>
<p>4 plane char data. For this task, we will use the jit.scalebias SDK example. More details such as how to make a Matrix Operator which deals with multiple types, plane count, dimensionality, inputs, outputs, etc. will appear in the following chapter. This chapter assumes familiarity with Jitter's multi-dimensional matrix representation and Matrix Operators used from the Max patcher, as discussed in the Jitter Tutorial, and as well as the preceding chapters on the Jitter object model and Max wrapper classes.</p>
<h2><a class="anchor" id="chapter_jit_mopqs_classes">
Defining the MOP Jitter Class</a></h2>
<p>In the Jitter class definition, we introduce a few new concepts for Matrix Operators. In addition to the standard method and attribute definitions discussed in the Jitter object model chapter, you will want to define things like how many inputs and outputs the operator has, and what type, plane count, and dimension restrictions the operator has. These are accomplished by creating an instance of the jit_mop class, setting some state for the jit_mop object and adding this object as an adornment to your Jitter class. The following code segment references the jit.scalebias SDK example.</p>
<div class="fragment"><pre class="fragment">   <span class="comment">// create a new instance of jit_mop with 1 input, and 1 output </span>
   mop = <a class="code" href="group__objectmod.html#gabde2eb49750992ec4125af862b402342" title="Instantiates an object specified by class name.">jit_object_new</a>(<a class="code" href="group__jitter.html#gace980d3ad9ef9fe8599b0802a5bc94cc" title="cached t_symbol">_jit_sym_jit_mop</a>,1,1);
   
   <span class="comment">// enforce a single type for all inputs and outputs</span>
   <a class="code" href="group__mopmod.html#ga8923e590eaf3cdb7d92c7f982ddc169f" title="Utility function to set the type attribute for all MOP inputs and outputs.">jit_mop_single_type</a>(mop,<a class="code" href="group__jitter.html#ga3a06cf8d41c4f4c017c0bf825fec59f8" title="cached t_symbol">_jit_sym_char</a>);   

   <span class="comment">// enforce a single plane count for all inputs and outputs</span>
   <a class="code" href="group__mopmod.html#gada02eaa2a5dc001cdb120a83cb093e25" title="Utility function to set the planecount attribute for all MOP inputs and outputs.">jit_mop_single_planecount</a>(mop,4);   

   <span class="comment">// add the jit_mop object as an adornment to the class</span>
   <a class="code" href="group__classmod.html#ga408738c800435bf50d092ce52b223327" title="Adds an adornment to a class.">jit_class_addadornment</a>(_jit_scalebias_class,mop);
</pre></div><p>You create your jit_mop instance in a similar fashion to creating your attribute instances, using <a class="el" href="group__objectmod.html#gabde2eb49750992ec4125af862b402342" title="Instantiates an object specified by class name.">jit_object_new()</a>. The jit_mop constructor has two integer arguments for inputs and outputs, respectively. By default, each MOP input and output is unrestricted in plane count, type, and dimension, and also are linked to the plane count, type, and dimensions of the first (i.e. leftmost) input. This default behavior can be overridden, and this simple 4 plane, char type, jit.scalebias example enforces the corresponding type and plane count restrictions via the <a class="el" href="group__mopmod.html#ga8923e590eaf3cdb7d92c7f982ddc169f" title="Utility function to set the type attribute for all MOP inputs and outputs.">jit_mop_single_type()</a> and <a class="el" href="group__mopmod.html#gada02eaa2a5dc001cdb120a83cb093e25" title="Utility function to set the planecount attribute for all MOP inputs and outputs.">jit_mop_single_planecount()</a> utility functions. For more information on the jit_mop class, please see the following chapter on MOP details and the Jitter API reference.</p>
<p>Once you have created your jit_mop instance, and configured it according to the needs of your object, you add it as an adornment to your Jitter class with the jit_class_add_adornment() function. Adornments are one way for Jitter objects to have additional information, and in some instances behavior, tacked onto an existing class. Adornments will be discussed in detail in a later chapter.</p>
<p>You also want to define your matrix calculation method, where most of the work of a Matrix Operator occurs, with the <a class="el" href="group__classmod.html#gab3b84bc08f9f3ee0b29010f653c5ea77" title="Adds a named method to a class.">jit_class_addmethod()</a> function as a private, untyped method bound to the symbol matrix_calc.</p>
<div class="fragment"><pre class="fragment">   <a class="code" href="group__classmod.html#gab3b84bc08f9f3ee0b29010f653c5ea77" title="Adds a named method to a class.">jit_class_addmethod</a>(_jit_scalebias_class, 
      (<a class="code" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d" title="Function pointer type for generic methods.">method</a>)jit_scalebias_matrix_calc,
      <span class="stringliteral">&quot;matrix_calc&quot;</span>, <a class="code" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47af48193ec36e53b1507d81c49873c8d7a" title="cannot typecheck args">A_CANT</a>, 0L);
</pre></div><h2><a class="anchor" id="chapter_jit_mopqs_ctordtor">
The Jitter Class Constructor/Destructor</a></h2>
<p>You don't need to add anything special to your Matrix Operator's constructor or destructor, aside from the standard initialization and cleanup any Jitter object would need to do. Any internal matrices for input and outputs are maintained, and only required, by the Max wrapper's asynchronous interface. The Jitter MOP contains no matrices for inputs and outputs, but rather expects that the matrix calculation method is called with all inputs and outputs synchronously. When used from languages like C, Java, and JavaScript, it is up to the programmer to maintain and provide any matrices which are being passed into the matrix calculation method.</p>
<h2><a class="anchor" id="chapter_jit_mopqs_calc">
The Matrix Calculation Method</a></h2>
<p>The most important method for Matrix Operators, and the one in which the most work typically occurs is in the matrix calculation, or "matrix_calc" method, which should be defined as a private, untyped method with the <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47af48193ec36e53b1507d81c49873c8d7a" title="cannot typecheck args">A_CANT</a> type signature, and bound to the symbol "matrix_calc". In this method your object receives a list of input matrices and output matrices to use in its calculation. You need to lock access to these matrices, inquire about important attributes, and ensure that any requirements with respect to type, plane count, or dimensionality for the inputs are met before actually processing the data, unlocking access to the matrices and returning. It should be defined as in the following example.</p>
<div class="fragment"><pre class="fragment">t_jit_err jit_scalebias_matrix_calc(t_jit_scalebias *x, 
   <span class="keywordtype">void</span> *inputs, <span class="keywordtype">void</span> *outputs)
{
   t_jit_err err=JIT_ERR_NONE;
   <span class="keywordtype">long</span> in_savelock,out_savelock;
   <a class="code" href="structt__jit__matrix__info.html" title="Matrix information struct.">t_jit_matrix_info</a> in_minfo,out_minfo;
   <span class="keywordtype">char</span> *in_bp,*out_bp;
   <span class="keywordtype">long</span> i,dimcount,planecount,dim[<a class="code" href="group__jitter.html#ga3a74bc72df454ac5618a865fd3c56870" title="maximum dimension count">JIT_MATRIX_MAX_DIMCOUNT</a>];
   <span class="keywordtype">void</span> *in_matrix,*out_matrix;
   
   <span class="comment">// get the zeroth index input and output from </span>
   <span class="comment">// the corresponding input and output lists</span>
   in_matrix    = <a class="code" href="group__objectmod.html#ga9e1b9b8ed4fce611de26a74c6e1452c8" title="Calls an object method specified by method name.">jit_object_method</a>(inputs,<a class="code" href="group__jitter.html#ga8479bd2e249eeebe55b73d505ddb3c5f" title="cached t_symbol">_jit_sym_getindex</a>,0);
   out_matrix    = <a class="code" href="group__objectmod.html#ga9e1b9b8ed4fce611de26a74c6e1452c8" title="Calls an object method specified by method name.">jit_object_method</a>(outputs,<a class="code" href="group__jitter.html#ga8479bd2e249eeebe55b73d505ddb3c5f" title="cached t_symbol">_jit_sym_getindex</a>,0);

   <span class="comment">// if the object and both input and output matrices</span>
   <span class="comment">// are valid, then process, else return an error</span>
   <span class="keywordflow">if</span> (x&amp;&amp;in_matrix&amp;&amp;out_matrix) 
   {
      <span class="comment">// lock input and output matrices   </span>
      in_savelock = 
         (long) <a class="code" href="group__objectmod.html#ga9e1b9b8ed4fce611de26a74c6e1452c8" title="Calls an object method specified by method name.">jit_object_method</a>(in_matrix,<a class="code" href="group__jitter.html#ga27170862accb34a4a7d5940747ab93c2" title="cached t_symbol">_jit_sym_lock</a>,1);
      out_savelock = 
         (long) <a class="code" href="group__objectmod.html#ga9e1b9b8ed4fce611de26a74c6e1452c8" title="Calls an object method specified by method name.">jit_object_method</a>(out_matrix,<a class="code" href="group__jitter.html#ga27170862accb34a4a7d5940747ab93c2" title="cached t_symbol">_jit_sym_lock</a>,1);

      <span class="comment">// fill out matrix info structs for input and output</span>
      <a class="code" href="group__objectmod.html#ga9e1b9b8ed4fce611de26a74c6e1452c8" title="Calls an object method specified by method name.">jit_object_method</a>(in_matrix,<a class="code" href="group__jitter.html#gaa54d88c62f83bcde09d3e819f5cedf65" title="cached t_symbol">_jit_sym_getinfo</a>,&amp;in_minfo);
      <a class="code" href="group__objectmod.html#ga9e1b9b8ed4fce611de26a74c6e1452c8" title="Calls an object method specified by method name.">jit_object_method</a>(out_matrix,<a class="code" href="group__jitter.html#gaa54d88c62f83bcde09d3e819f5cedf65" title="cached t_symbol">_jit_sym_getinfo</a>,&amp;out_minfo);
      
      <span class="comment">// get matrix data pointers</span>
      <a class="code" href="group__objectmod.html#ga9e1b9b8ed4fce611de26a74c6e1452c8" title="Calls an object method specified by method name.">jit_object_method</a>(in_matrix,<a class="code" href="group__jitter.html#ga3783fcca6255fb75cd048647ddebda3d" title="cached t_symbol">_jit_sym_getdata</a>,&amp;in_bp);
      <a class="code" href="group__objectmod.html#ga9e1b9b8ed4fce611de26a74c6e1452c8" title="Calls an object method specified by method name.">jit_object_method</a>(out_matrix,<a class="code" href="group__jitter.html#ga3783fcca6255fb75cd048647ddebda3d" title="cached t_symbol">_jit_sym_getdata</a>,&amp;out_bp);
      
      <span class="comment">// if data pointers are invalid, set error, and cleanup</span>
      <span class="keywordflow">if</span> (!in_bp) { err=JIT_ERR_INVALID_INPUT; <span class="keywordflow">goto</span> out;}
      <span class="keywordflow">if</span> (!out_bp) { err=JIT_ERR_INVALID_OUTPUT; <span class="keywordflow">goto</span> out;}
      
      <span class="comment">// enforce compatible types</span>
      <span class="keywordflow">if</span> ((in_minfo.<a class="code" href="structt__jit__matrix__info.html#a37a2ef0a44ee55587b56b2fea63ef217" title="primitifve type (char, long, float32, or float64)">type</a>!=<a class="code" href="group__jitter.html#ga3a06cf8d41c4f4c017c0bf825fec59f8" title="cached t_symbol">_jit_sym_char</a>) ||
         (in_minfo.<a class="code" href="structt__jit__matrix__info.html#a37a2ef0a44ee55587b56b2fea63ef217" title="primitifve type (char, long, float32, or float64)">type</a>!=out_minfo.<a class="code" href="structt__jit__matrix__info.html#a37a2ef0a44ee55587b56b2fea63ef217" title="primitifve type (char, long, float32, or float64)">type</a>)) 
      { 
         err=JIT_ERR_MISMATCH_TYPE; 
         <span class="keywordflow">goto</span> out;
      }      

      <span class="comment">// enforce compatible planecount</span>
      <span class="keywordflow">if</span> ((in_minfo.<a class="code" href="structt__jit__matrix__info.html#a4f8e32123477684b18c83ca3d9079803" title="number of planes">planecount</a>!=4) || 
         (out_minfo.<a class="code" href="structt__jit__matrix__info.html#a4f8e32123477684b18c83ca3d9079803" title="number of planes">planecount</a>!=4)) 
      { 
         err=JIT_ERR_MISMATCH_PLANE; 
         <span class="keywordflow">goto</span> out;
      }      

      <span class="comment">// get dimensions/planecount </span>
      dimcount   = out_minfo.<a class="code" href="structt__jit__matrix__info.html#a51f55844070b10955b23235f6ef68d1c" title="number of dimensions">dimcount</a>;
      planecount = out_minfo.<a class="code" href="structt__jit__matrix__info.html#a4f8e32123477684b18c83ca3d9079803" title="number of planes">planecount</a>;         
      <span class="keywordflow">for</span> (i=0;i&lt;dimcount;i++) 
      {
         <span class="comment">// if input and output are not matched in</span>
         <span class="comment">// size, use the intersection of the two</span>
         dim[i] = <a class="code" href="group__misc.html#ga3acffbd305ee72dcd4593c0d8af64a4f" title="Return the lower of two values.">MIN</a>(in_minfo.<a class="code" href="structt__jit__matrix__info.html#a500e46ec5cc4182111fb01931968c6d4" title="dimension sizes">dim</a>[i],out_minfo.<a class="code" href="structt__jit__matrix__info.html#a500e46ec5cc4182111fb01931968c6d4" title="dimension sizes">dim</a>[i]);
      }      
            
      <span class="comment">// calculate, using the parallel utility function to</span>
      <span class="comment">// call the calculate_ndim function in multiple</span>
      <span class="comment">// threads if there are multiple processors available</span>
      <a class="code" href="group__parallelutilmod.html#gaeb6c9b472d61bdda9fd33aa61a36df1f" title="Tasks two input/output N-dimensional matrix calcuations to multiple threads if appropriate...">jit_parallel_ndim_simplecalc2</a>(
         (<a class="code" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d" title="Function pointer type for generic methods.">method</a>)jit_scalebias_calculate_ndim,
         x, dimcount, dim, planecount, 
         &amp;in_minfo, in_bp, &amp;out_minfo, out_bp,
         0, 0);
   } <span class="keywordflow">else</span> {
      <span class="keywordflow">return</span> JIT_ERR_INVALID_PTR;
   }
   
out:
   <span class="comment">// restore matrix lock state to previous value</span>
   <a class="code" href="group__objectmod.html#ga9e1b9b8ed4fce611de26a74c6e1452c8" title="Calls an object method specified by method name.">jit_object_method</a>(out_matrix,<a class="code" href="group__jitter.html#ga27170862accb34a4a7d5940747ab93c2" title="cached t_symbol">_jit_sym_lock</a>,out_savelock);
   <a class="code" href="group__objectmod.html#ga9e1b9b8ed4fce611de26a74c6e1452c8" title="Calls an object method specified by method name.">jit_object_method</a>(in_matrix,<a class="code" href="group__jitter.html#ga27170862accb34a4a7d5940747ab93c2" title="cached t_symbol">_jit_sym_lock</a>,in_savelock);
   <span class="keywordflow">return</span> err;
}
</pre></div><h2><a class="anchor" id="chapter_jit_mopqs_ndim">
Processing N-Dimensional Matrices</a></h2>
<p>Since Jitter supports the processing of N-dimensional matrices where N can be any number from 1 to 32, most Matrix Operators are designed with a recursive function that will process the data in some lower dimensional slice, most often 2 dimensional. The recursive function that does this is typically named myobject_calculate_ndim(), and is called by your matrix_calc method either directly or via one of the parallel processing utility functions, which are discussed in a future chapter.</p>
<p>It is out of the scope of this documentation to provide a detailed tutorial on fixed point or pointer arithmetic, both of which are used in this example. The code increments a pointer through the matrix data, scaling each planar element of each matrix cell by some factor and adding some bias amount. This is done with fixed point arithmetic (assuming an 8bit fractional component), since a conversion from integer to floating point data and back is an expensive operation. The jit.scalebias object also has two modes, one which sums the planes together, and one which processes each plane independently. You can improve performance by case handling on a per row, rather than per cell basis, and reduce your code somewhat by case handling on a per row, rather than per matrix basis. While a slight performance increase could be made by handling on a per matrix basis, per row is usually a decent point at which to make such an optimization trade off.</p>
<div class="fragment"><pre class="fragment"><span class="comment">// recursive function to handle higher dimension matrices,</span>
<span class="comment">// by processing 2D sections at a time </span>
<span class="keywordtype">void</span> jit_scalebias_calculate_ndim(t_jit_scalebias *x, 
   <span class="keywordtype">long</span> dimcount, <span class="keywordtype">long</span> *dim, <span class="keywordtype">long</span> planecount, 
   <a class="code" href="structt__jit__matrix__info.html" title="Matrix information struct.">t_jit_matrix_info</a> *in_minfo, <span class="keywordtype">char</span> *bip, 
   <a class="code" href="structt__jit__matrix__info.html" title="Matrix information struct.">t_jit_matrix_info</a> *out_minfo, <span class="keywordtype">char</span> *bop)
{
   <span class="keywordtype">long</span> i,j,width,height;
   <a class="code" href="group__datatypes.html#ga65f85814a8290f9797005d3b28e7e5fc" title="An unsigned char.">uchar</a> *ip,*op;
   <span class="keywordtype">long</span> ascale,rscale,gscale,bscale;
   <span class="keywordtype">long</span> abias,rbias,gbias,bbias,sumbias;
   <span class="keywordtype">long</span> tmp;
      
   <span class="keywordflow">if</span> (dimcount&lt;1) <span class="keywordflow">return</span>; <span class="comment">//safety</span>
   
   <span class="keywordflow">switch</span>(dimcount) 
   {
   <span class="keywordflow">case</span> 1:   
      <span class="comment">// if only 1D, interpret as 2D, falling through to 2D case </span>
      dim[1]=1;
   <span class="keywordflow">case</span> 2:
      <span class="comment">// convert floating point scale factors to a fixed point int</span>
      ascale = x-&gt;ascale*256.;   
      rscale = x-&gt;rscale*256.;   
      gscale = x-&gt;gscale*256.;   
      bscale = x-&gt;bscale*256.;   

      <span class="comment">// convert floating point bias values to a fixed point int</span>
      abias  = x-&gt;abias*256.;   
      rbias  = x-&gt;rbias*256.;   
      gbias  = x-&gt;gbias*256.;   
      bbias  = x-&gt;bbias*256.;   

      <span class="comment">// for efficiency in sum mode (1), make a single bias value</span>
      sumbias = (x-&gt;abias+x-&gt;rbias+x-&gt;gbias+x-&gt;bbias)*256.;
            
      width  = dim[0];
      height = dim[1];
      
      <span class="comment">// for each row</span>
      <span class="keywordflow">for</span> (i=0;i&lt;height;i++)
      {
         <span class="comment">// increment data pointers according to byte stride </span>
         ip = bip + i*in_minfo-&gt;<a class="code" href="structt__jit__matrix__info.html#a1fa371b72de180c778c382e2b3286b2f" title="stride across dimensions in bytes">dimstride</a>[1];
         op = bop + i*out_minfo-&gt;<a class="code" href="structt__jit__matrix__info.html#a1fa371b72de180c778c382e2b3286b2f" title="stride across dimensions in bytes">dimstride</a>[1];
         
         <span class="keywordflow">switch</span> (x-&gt;mode) {
         <span class="keywordflow">case</span> 1:   
            <span class="comment">// sum together, clamping to the range 0-255 </span>
            <span class="comment">// and set all output planes</span>
            <span class="keywordflow">for</span> (j=0;j&lt;width;j++) {
               tmp  = (long)(*ip++)*ascale;
               tmp += (long)(*ip++)*rscale;
               tmp += (long)(*ip++)*gscale;
               tmp += (long)(*ip++)*bscale;
               tmp  = (tmp&gt;&gt;8L) + sumbias;
               tmp  = (tmp&gt;255)?255:((tmp&lt;0)?0:tmp);
               *op++ = tmp;
               *op++ = tmp;
               *op++ = tmp;
               *op++ = tmp;               
            }
            <span class="keywordflow">break</span>;            
         <span class="keywordflow">default</span>:   
            <span class="comment">// apply to each plane individually </span>
            <span class="comment">// clamping to the range 0-255</span>
            <span class="keywordflow">for</span> (j=0;j&lt;width;j++) {
               tmp = (((long)(*ip++)*ascale)&gt;&gt;8L)+abias;
               *op++ = (tmp&gt;255)?255:((tmp&lt;0)?0:tmp);
               tmp = (((long)(*ip++)*rscale)&gt;&gt;8L)+rbias;
               *op++ = (tmp&gt;255)?255:((tmp&lt;0)?0:tmp);
               tmp = (((long)(*ip++)*gscale)&gt;&gt;8L)+gbias;
               *op++ = (tmp&gt;255)?255:((tmp&lt;0)?0:tmp);
               tmp = (((long)(*ip++)*bscale)&gt;&gt;8L)+bbias;
               *op++ = (tmp&gt;255)?255:((tmp&lt;0)?0:tmp);
            }
            <span class="keywordflow">break</span>;
         }
      }
      <span class="keywordflow">break</span>;
   <span class="keywordflow">default</span>:
      <span class="comment">// if processing higher dimension than 2D,</span>
      <span class="comment">// for each lower dimensioned slice, set </span>
      <span class="comment">// base pointer and recursively call this function</span>
      <span class="comment">// with decremented dimcount and new base pointers </span>
      <span class="keywordflow">for</span>   (i=0;i&lt;dim[dimcount-1];i++) 
      {
         ip = bip + i*in_minfo-&gt;<a class="code" href="structt__jit__matrix__info.html#a1fa371b72de180c778c382e2b3286b2f" title="stride across dimensions in bytes">dimstride</a>[dimcount-1];
         op = bop + i*out_minfo-&gt;<a class="code" href="structt__jit__matrix__info.html#a1fa371b72de180c778c382e2b3286b2f" title="stride across dimensions in bytes">dimstride</a>[dimcount-1];
         jit_scalebias_calculate_ndim(x,dimcount1,
            dim,planecount,in_minfo,ip,out_minfo,op);
      }
   }
}
</pre></div><p>Rather than using multidimensional arrays, Jitter matrix data is packed in a single dimensional array, with defined byte strides for each dimension for greatest flexibility. This permits matrices to reference subregions of larger matrices, as well as support data that is not tightly packed. Therefore, rather than using multidimensional array syntax, this code uses pointer arithmetic to access each plane of each cell of the matrix, adding the corresponding byte strides to the base pointer for each dimension across which it is iterating. These byte strides are stored in the dimstride entry of the <a class="el" href="structt__jit__matrix__info.html" title="Matrix information struct.">t_jit_matrix_info</a> struct. Note that Jitter requires that planes within a cell, and cells across the first dimension (dim[0]) are tightly packed. The above code assumes that this is the case, using a simple pointer increment for each plane and cell, rather than looking up byte strides for dim[0].</p>
<h2><a class="anchor" id="chapter_jit_mopqs_wrapperdef">
Defining the MOP Max Wrapper Class</a></h2>
<p>In order to use the MOP class in a Max patcher you need to make a Max wrapper class. In addition to the standard methods used to wrap any Jitter class, MOPs need to add special methods and information to the Max class. One of the things that needs to happen is that the Max wrapper class needs to allocate and maintain instances of jit.matrix for each matrix input and output other than the leftmost input, to accommodate Max's asynchronous event model. In order to perform this maintenance, the Max wrapper class must have special methods and attributes for setting the type, plane count, dimensions, adaptability, and named references for the internal matrices. All of these messages are exclusive to the Max wrapper implementation, and are not used by the C, Java, or JavaScript usage of Matrix Operators. There are also common methods and attributes for the matrix output mode, and the jit_matrix and bang messages, all of which are specific to the MOP's Max wrapper. These special attributes and methods are added by the <a class="el" href="group__maxmopmod.html#ga7e08584771f58ce1fe0b190d27b5759b" title="Adds default methods and attributes to the MOP Max wrapper class.">max_jit_classex_mop_wrap()</a> function, which should be called inside your Max external's main function, after calling <a class="el" href="group__maxwrapmod.html#ga773b6e6430d9de2e295419c7f038979e" title="Allocates and initializes special t_max_jit_classex data, used by the Max wrapper...">max_jit_classex_setup()</a> and <a class="el" href="group__classmod.html#ga63eb9d25f881cd6fba11e24f9ac9b02f" title="Retrieves class pointer associated with name provided.">jit_class_findbyname()</a>, and before calling <a class="el" href="group__maxwrapmod.html#ga9b8377bdccc2497e02582c72204b5250" title="Adds standard Jitter methods, as well as public methods and attributes of the specified...">max_jit_classex_standard_wrap()</a>. Several default methods and attributes can be overridden using the various flags that can be combined for the flags argument to <a class="el" href="group__maxmopmod.html#ga7e08584771f58ce1fe0b190d27b5759b" title="Adds default methods and attributes to the MOP Max wrapper class.">max_jit_classex_mop_wrap()</a>. These flags, which for most simple MOPs won't be necessary, are listed below.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#define MAX_JIT_MOP_FLAGS_OWN_ALL           0xFFFFFFFF</span>
<span class="preprocessor"></span><span class="preprocessor">#define MAX_JIT_MOP_FLAGS_OWN_JIT_MATRIX    0x00000001</span>
<span class="preprocessor"></span><span class="preprocessor">#define MAX_JIT_MOP_FLAGS_OWN_BANG          0x00000002</span>
<span class="preprocessor"></span><span class="preprocessor">#define MAX_JIT_MOP_FLAGS_OWN_OUTPUTMATRIX  0x00000004</span>
<span class="preprocessor"></span><span class="preprocessor">#define MAX_JIT_MOP_FLAGS_OWN_NAME          0x00000008</span>
<span class="preprocessor"></span><span class="preprocessor">#define MAX_JIT_MOP_FLAGS_OWN_TYPE          0x00000010</span>
<span class="preprocessor"></span><span class="preprocessor">#define MAX_JIT_MOP_FLAGS_OWN_DIM           0x00000020</span>
<span class="preprocessor"></span><span class="preprocessor">#define MAX_JIT_MOP_FLAGS_OWN_PLANECOUNT    0x00000040</span>
<span class="preprocessor"></span><span class="preprocessor">#define MAX_JIT_MOP_FLAGS_OWN_CLEAR         0x00000080</span>
<span class="preprocessor"></span><span class="preprocessor">#define MAX_JIT_MOP_FLAGS_OWN_NOTIFY        0x00000100</span>
<span class="preprocessor"></span><span class="preprocessor">#define MAX_JIT_MOP_FLAGS_OWN_ADAPT         0x00000200</span>
<span class="preprocessor">#define MAX_JIT_MOP_FLAGS_OWN_OUTPUTMODE    0x00000400</span>
</pre></div><h2><a class="anchor" id="chapter_jit_mopqs_maxctordtor">
The Max Class Constructor/Destructor</a></h2>
<p>Inside your Max class' constructor you need to allocate the matrices necessary for the MOP inputs and outputs, the corresponding matrix inlets and outlets, process matrix arguments and other MOP setup. The <a class="el" href="group__maxmopmod.html#gac3eaca207281516b72e81f0dc5f4bf94" title="Initializes default state and resources for MOP Max wrapper class.">max_jit_mop_setup_simple()</a> function takes care of these functions and some of the other necessary tasks of wrapping your Jitter instance. As such, the use of this function simplifies your Jitter class wrapping even further for the simple case where no special behavior, incompatible with <a class="el" href="group__maxmopmod.html#gac3eaca207281516b72e81f0dc5f4bf94" title="Initializes default state and resources for MOP Max wrapper class.">max_jit_mop_setup_simple()</a> is required. Here is the constructor for the Max class of the jit.scalebias object.</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> *max_jit_scalebias_new(<a class="code" href="structt__symbol.html" title="The symbol.">t_symbol</a> *s, <span class="keywordtype">long</span> argc, <a class="code" href="structt__atom.html" title="An atom is a typed datum.">t_atom</a> *argv)
{
   t_max_jit_scalebias *x;
   <span class="keywordtype">void</span> *o;

   <span class="keywordflow">if</span> (x = (t_max_jit_scalebias *)
      <a class="code" href="group__maxwrapmod.html#gacf7fc6f3f87db8515f61b12efbcc9073" title="Allocates an initializes a new Max wrapper object instance.">max_jit_obex_new</a>(
      max_jit_scalebias_class,
      <a class="code" href="group__symbol.html#ga5d8db08b384aeb76eaee85a15f46fbcb" title="Given a C-string, fetch the matching t_symbol pointer from the symbol table, generating...">gensym</a>(<span class="stringliteral">&quot;jit_scalebias&quot;</span>))) 
   {
      <span class="comment">// instantiate Jitter object</span>
      <span class="keywordflow">if</span> (o=<a class="code" href="group__objectmod.html#gabde2eb49750992ec4125af862b402342" title="Instantiates an object specified by class name.">jit_object_new</a>(<a class="code" href="group__symbol.html#ga5d8db08b384aeb76eaee85a15f46fbcb" title="Given a C-string, fetch the matching t_symbol pointer from the symbol table, generating...">gensym</a>(<span class="stringliteral">&quot;jit_scalebias&quot;</span>))) 
      {
         <span class="comment">// handle standard MOP max wrapper setup tasks</span>
         <a class="code" href="group__maxmopmod.html#gac3eaca207281516b72e81f0dc5f4bf94" title="Initializes default state and resources for MOP Max wrapper class.">max_jit_mop_setup_simple</a>(x,o,argc,argv);         

         <span class="comment">// process attribute arguments</span>
         <a class="code" href="group__maxwrapmod.html#gac1ffd4864421154c8e6364b5df9a09ff" title="Processes attribtue arguments.">max_jit_attr_args</a>(x,argc,argv);
      } 
      <span class="keywordflow">else</span> 
      {
         <a class="code" href="group__console.html#ga8a87d2e25431900a88722759ec115757" title="Print an error to the Max window.">error</a>(<span class="stringliteral">&quot;jit.scalebias: could not allocate object&quot;</span>);
         <a class="code" href="group__class__old.html#gadf30646e52376a37b93cc20efac65636" title="Release the memory used by a Max object.">freeobject</a>(x);
      }
   }
   <span class="keywordflow">return</span> (x);
}
</pre></div><p>Below is the listing of the <a class="el" href="group__maxmopmod.html#gac3eaca207281516b72e81f0dc5f4bf94" title="Initializes default state and resources for MOP Max wrapper class.">max_jit_mop_setup_simple()</a> function, demonstrating the smaller pieces, it manages for you. If your object has special requirements, you can use whatever subset of the following function as necessary.</p>
<div class="fragment"><pre class="fragment">t_jit_err <a class="code" href="group__maxmopmod.html#gac3eaca207281516b72e81f0dc5f4bf94" title="Initializes default state and resources for MOP Max wrapper class.">max_jit_mop_setup_simple</a>(<span class="keywordtype">void</span> *x, <span class="keywordtype">void</span> *o, <span class="keywordtype">long</span> argc, <a class="code" href="structt__atom.html" title="An atom is a typed datum.">t_atom</a> *argv)
{
   <a class="code" href="group__maxwrapmod.html#gaa1b174cf92680ca46bfb189a812d2a65" title="Sets the wrapped Jitter object for a Max wrapper object.">max_jit_obex_jitob_set</a>(x,o);
   <a class="code" href="group__maxwrapmod.html#ga8e63a402ecf8cef78a9093c774159a9e" title="Sets the Max wrapper object&amp;#39;s dump outlet&amp;#39;s outlet pointer.">max_jit_obex_dumpout_set</a>(x,<a class="code" href="group__inout.html#gac25db50a2a7eb76c5e057dd907c11d44" title="Use outlet_new() to create an outlet that can send a specific non-standard message...">outlet_new</a>(x,NULL));
   <a class="code" href="group__maxmopmod.html#ga21f81f6d30f54a671a78a6b44986392a" title="Sets up necessary resources for MOP Max wrapper object.">max_jit_mop_setup</a>(x);
   <a class="code" href="group__maxmopmod.html#gaec99be7b60c1cec6a8391097d5008bc6" title="Creates input resources for a MOP Max wrapper object.">max_jit_mop_inputs</a>(x);
   <a class="code" href="group__maxmopmod.html#ga07f044bc4c7fe4380f31e150844948df" title="Creates output resources for a MOP Max wrapper object.">max_jit_mop_outputs</a>(x);
   <a class="code" href="group__maxmopmod.html#ga75f7f306602775484eaa1b3f9d3998f3" title="Process matrix arguments for a MOP Max wrapper object.">max_jit_mop_matrix_args</a>(x,argc,argv);

   <span class="keywordflow">return</span> JIT_ERR_NONE;
}
</pre></div><p>In your Max class' destructor, you need to free the resources allocated for your MOP. This is accomplished with the <a class="el" href="group__maxmopmod.html#ga441ff70d705e1eccff8297437c85e46c" title="Frees additional resources used by a MOP Max wrapper object.">max_jit_mop_free()</a> function, which should be called before you free your internal Jitter instance, and your Max class' obex data. As an example, the jit.scalebias destructor is listed below.</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> max_jit_scalebias_free(t_max_jit_scalebias *x)
{
   <span class="comment">// free MOP max wrapper resources</span>
   <a class="code" href="group__maxmopmod.html#ga441ff70d705e1eccff8297437c85e46c" title="Frees additional resources used by a MOP Max wrapper object.">max_jit_mop_free</a>(x);

   <span class="comment">// lookup internal Jitter object instance and free</span>
   <a class="code" href="group__objectmod.html#ga64970b62e5afe7a2cbd57efd6e9e9f74" title="Frees an object.">jit_object_free</a>(<a class="code" href="group__maxwrapmod.html#ga063ab88bfc92c1a666f3ad6251834e20" title="Retrieves the wrapped Jitter object from a Max wrapper object.">max_jit_obex_jitob_get</a>(x));

   
   <span class="comment">// free resources associated with obex entry</span>
   <a class="code" href="group__maxwrapmod.html#gabcf9c466a6baa22994a66e30b54e7dd6" title="Frees additional resources for the Max wrapper object instance.">max_jit_obex_free</a>(x);
}
</pre></div> </div>
		<div id="c74footer">
			<p>Copyright &copy; 2008, <a href="http://www.cycling74.com/">Cycling '74</a></p>
		</div>
	</body>
</html>
