<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
		<title>Max5 API Reference</title>
		<link href="c74-doxygen.css" rel="stylesheet" type="text/css">
	</head>
	<body>

		<div id="c74header">
			<img src="max5.png" />
			<p>Max 5 API Reference</p>
		</div>

<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Qelems<br/>
<small>
[<a class="el" href="group__sched.html">Timing</a>]</small>
</h1>
<p>Your object’s methods may be called at interrupt level.  
<a href="#_details">More...</a></p>

<p><div class="dynheader">
Collaboration diagram for Qelems:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__qelems.png" border="0" alt="" usemap="#group____qelems_map"/>
<map name="group____qelems_map" id="group____qelems">
<area shape="rect" href="group__sched.html" title="Timing" alt="" coords="5,5,77,32"/></map></td></tr></table></center>
</div>
</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4d219449d88d2b9648a992152b278090"></a><!-- doxytag: member="qelems::t_qelem" ref="ga4d219449d88d2b9648a992152b278090" args="" -->
typedef void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qelems.html#ga4d219449d88d2b9648a992152b278090">t_qelem</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A qelem. <br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qelems.html#gaffa7e9d4d5468a8ae3c825a353609b1b">qelem_new</a> (void *obj, <a class="el" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d">method</a> fn)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new Qelem.  <a href="#gaffa7e9d4d5468a8ae3c825a353609b1b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qelems.html#ga3e292aad133af89a87e167e88cc4a1b5">qelem_set</a> (void *q)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cause a Qelem to execute.  <a href="#ga3e292aad133af89a87e167e88cc4a1b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qelems.html#ga021eca2eff6e47ff97ca112fb2eaf866">qelem_unset</a> (void *q)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancel a Qelem's execution.  <a href="#ga021eca2eff6e47ff97ca112fb2eaf866"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qelems.html#ga7cfcb3134eb0baf335847906a14a08d0">qelem_free</a> (void *x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a Qelem object created with <a class="el" href="group__qelems.html#gaffa7e9d4d5468a8ae3c825a353609b1b" title="Create a new Qelem.">qelem_new()</a>.  <a href="#ga7cfcb3134eb0baf335847906a14a08d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qelems.html#gab5fa3e43e7851d1a2049ee28f5275955">qelem_front</a> (void *x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cause a Qelem to execute with a higher priority.  <a href="#gab5fa3e43e7851d1a2049ee28f5275955"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Your object’s methods may be called at interrupt level. </p>
<p>This happens when the user has Overdrive mode enabled and one of your methods is called, directly or indirectly, from a scheduler Clock function. This means that you cannot count on doing certain things—like drawing, asking the user what file they would like opened, or calling any Macintosh toolbox trap that allocates or purges memory—from within any method that responds to any message that could be sent directly from another Max object. The mechanism you’ll use to get around this limitation is the Qelem (queue element) structure. Qelems also allow processor-intensive tasks to be done at a lower priority than in an interrupt. As an example, drawing on the screen, especially in color, takes a long time in comparison with a task like sending MIDI data.</p>
<p>A Qelem works very much like a Clock. You create a new Qelem in your creation function with qelem_new and store a pointer to it in your object. Then you write a queue function, very much like the clock function (it takes the same single argument that will usually be a pointer to your object) that will be called when the Qelem has been set. You set the Qelem to run its function by calling <a class="el" href="group__qelems.html#ga3e292aad133af89a87e167e88cc4a1b5" title="Cause a Qelem to execute.">qelem_set()</a>.</p>
<p>Often you’ll want to use Qelems and Clocks together. For example, suppose you want to update the display for a counter that changes 20 times a second. This can be accomplished by writing a Clock function that calls <a class="el" href="group__qelems.html#ga3e292aad133af89a87e167e88cc4a1b5" title="Cause a Qelem to execute.">qelem_set()</a> and then reschedules itself for 50 milliseconds later using the technique shown in the metronome example above. This scheme works even if you call <a class="el" href="group__qelems.html#ga3e292aad133af89a87e167e88cc4a1b5" title="Cause a Qelem to execute.">qelem_set()</a> faster than the computer can draw the counter, because if a Qelem is already set, <a class="el" href="group__qelems.html#ga3e292aad133af89a87e167e88cc4a1b5" title="Cause a Qelem to execute.">qelem_set()</a> will not set it again. However, when drawing the counter, you’ll display its current value, not a specific value generated in the Clock function.</p>
<p>Note that the Qelem-based defer mechanism discussed later in this chapter may be easier for lowering the priority of one-time events, such as opening a standard file dialog box in response to a read message.</p>
<p>If your Qelem routine sends messages using <a class="el" href="group__inout.html#ga0b2b38216f2f4dba486bfcd2273f255e" title="Use outlet_int() to send a float message out an outlet.">outlet_int()</a> or any other of the outlet functions, it needs to use the lockout mechanism described in the Interrupt Level Considerations section. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga7cfcb3134eb0baf335847906a14a08d0"></a><!-- doxytag: member="ext_proto.h::qelem_free" ref="ga7cfcb3134eb0baf335847906a14a08d0" args="(void *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qelem_free </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free a Qelem object created with <a class="el" href="group__qelems.html#gaffa7e9d4d5468a8ae3c825a353609b1b" title="Create a new Qelem.">qelem_new()</a>. </p>
<p>Typically this will be in your object's free funtion.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The Qelem to destroy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab5fa3e43e7851d1a2049ee28f5275955"></a><!-- doxytag: member="ext_proto.h::qelem_front" ref="gab5fa3e43e7851d1a2049ee28f5275955" args="(void *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qelem_front </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cause a Qelem to execute with a higher priority. </p>
<p>This function is identical to <a class="el" href="group__qelems.html#ga3e292aad133af89a87e167e88cc4a1b5" title="Cause a Qelem to execute.">qelem_set()</a>, except that the Qelem's function is placed at the front of the list of routines to execute in the main thread instead of the back. Be polite and only use <a class="el" href="group__qelems.html#gab5fa3e43e7851d1a2049ee28f5275955" title="Cause a Qelem to execute with a higher priority.">qelem_front()</a> only for special time-critical applications.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The Qelem whose function will be executed in the main thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaffa7e9d4d5468a8ae3c825a353609b1b"></a><!-- doxytag: member="ext_proto.h::qelem_new" ref="gaffa7e9d4d5468a8ae3c825a353609b1b" args="(void *obj, method fn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* qelem_new </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d">method</a>&nbsp;</td>
          <td class="paramname"> <em>fn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new Qelem. </p>
<p>The created Qelem will need to be freed using <a class="el" href="group__qelems.html#ga7cfcb3134eb0baf335847906a14a08d0" title="Free a Qelem object created with qelem_new().">qelem_free()</a>, do not use <a class="el" href="group__class__old.html#gadf30646e52376a37b93cc20efac65636" title="Release the memory used by a Max object.">freeobject()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>Argument to be passed to function fun when the Qelem executes. Normally a pointer to your object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fn</em>&nbsp;</td><td>Function to execute. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to a Qelem instance. You need to store this value to pass to <a class="el" href="group__qelems.html#ga3e292aad133af89a87e167e88cc4a1b5" title="Cause a Qelem to execute.">qelem_set()</a>.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Any kind of drawing or calling of Macintosh Toolbox routines that allocate or purge memory should be done in a Qelem function. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3e292aad133af89a87e167e88cc4a1b5"></a><!-- doxytag: member="ext_proto.h::qelem_set" ref="ga3e292aad133af89a87e167e88cc4a1b5" args="(void *q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qelem_set </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>q</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cause a Qelem to execute. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>The Qelem whose function will be executed in the main thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The key behavior of <a class="el" href="group__qelems.html#ga3e292aad133af89a87e167e88cc4a1b5" title="Cause a Qelem to execute.">qelem_set()</a> is this: if the Qelem object has already been set, it will not be set again. (If this is not what you want, see <a class="el" href="group__threading.html#gaa24a0c9896f1ad241e45590065c3f643" title="Defer execution of a function to the main thread if (and only if) your function is...">defer()</a>.) This is useful if you want to redraw the state of some data when it changes, but not in response to changes that occur faster than can be drawn. A Qelem object is unset after its queue function has been called. </dd></dl>

</div>
</div>
<a class="anchor" id="ga021eca2eff6e47ff97ca112fb2eaf866"></a><!-- doxytag: member="ext_proto.h::qelem_unset" ref="ga021eca2eff6e47ff97ca112fb2eaf866" args="(void *q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qelem_unset </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>q</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cancel a Qelem's execution. </p>
<p>If the Qelem's function is set to be called, <a class="el" href="group__qelems.html#ga021eca2eff6e47ff97ca112fb2eaf866" title="Cancel a Qelem&#39;s execution.">qelem_unset()</a> will stop it from being called. Otherwise, <a class="el" href="group__qelems.html#ga021eca2eff6e47ff97ca112fb2eaf866" title="Cancel a Qelem&#39;s execution.">qelem_unset()</a> does nothing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>The Qelem whose execution you wish to cancel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
		<div id="c74footer">
			<p>Copyright &copy; 2008, <a href="http://www.cycling74.com/">Cycling '74</a></p>
		</div>
	</body>
</html>
