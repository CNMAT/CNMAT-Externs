<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
		<title>Max5 API Reference</title>
		<link href="c74-doxygen.css" rel="stylesheet" type="text/css">
	</head>
	<body>

		<div id="c74header">
			<img src="max5.png" />
			<p>Max 5 API Reference</p>
		</div>

<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Linked List Module<br/>
<small>
[<a class="el" href="group__jitter.html">Jitter</a>]</small>
</h1>
<p><div class="dynheader">
Collaboration diagram for Linked List Module:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__linklistmod.png" border="0" alt="" usemap="#group____linklistmod_map"/>
<map name="group____linklistmod_map" id="group____linklistmod">
<area shape="rect" href="group__jitter.html" title="Jitter" alt="" coords="7,5,60,32"/></map></td></tr></table></center>
</div>
</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__linklistmod.html#gae31b06dd709cdaf1e035ad562bd5626f">jit_linklist_new</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs instance of t_jit_linklist.  <a href="#gae31b06dd709cdaf1e035ad562bd5626f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__linklistmod.html#gaab0a8e1a6848d0d6713d703ebe7b9427">jit_linklist_getsize</a> (t_jit_linklist *x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the linked list size.  <a href="#gaab0a8e1a6848d0d6713d703ebe7b9427"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__linklistmod.html#ga727e60be2a2ff3426661dbac83119599">jit_linklist_getindex</a> (t_jit_linklist *x, long index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the object at the specified list index.  <a href="#ga727e60be2a2ff3426661dbac83119599"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__linklistmod.html#ga2861d793a9f33c725e5d49946bb7e6bc">jit_linklist_objptr2index</a> (t_jit_linklist *x, void *p)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the list index for an object pointer.  <a href="#ga2861d793a9f33c725e5d49946bb7e6bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__linklistmod.html#ga46b1ab616dda1cd288c0ef2bcff09ae8">jit_linklist_makearray</a> (t_jit_linklist *x, void **a, long max)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flatten the linked list into an array.  <a href="#ga46b1ab616dda1cd288c0ef2bcff09ae8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__linklistmod.html#gabd11461161921960afdceb120d039a04">jit_linklist_insertindex</a> (t_jit_linklist *x, void *o, long index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert object at specified index.  <a href="#gabd11461161921960afdceb120d039a04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__linklistmod.html#ga1c5f6c883c11c9a9f3a2ccbf2fe96f94">jit_linklist_append</a> (t_jit_linklist *x, void *o)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append object to the end of the linked list.  <a href="#ga1c5f6c883c11c9a9f3a2ccbf2fe96f94"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__linklistmod.html#ga5939ee7afe931f55c10fe78b4f562b00">jit_linklist_deleteindex</a> (t_jit_linklist *x, long index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete object at specified index, freeing the object.  <a href="#ga5939ee7afe931f55c10fe78b4f562b00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__linklistmod.html#gac4958696256b4573074b1b5b48fac9db">jit_linklist_chuckindex</a> (t_jit_linklist *x, long index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove object at specified index, without freeing the object.  <a href="#gac4958696256b4573074b1b5b48fac9db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__linklistmod.html#gad38efced2bcc418a6daa82a41221ea3c">jit_linklist_clear</a> (t_jit_linklist *x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears the linked list, freeing all objects in list.  <a href="#gad38efced2bcc418a6daa82a41221ea3c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__linklistmod.html#gaba0236de39f684e338ae6bf5736ae4ad">jit_linklist_chuck</a> (t_jit_linklist *x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all objects from the linked list, without freeing any objects in list.  <a href="#gaba0236de39f684e338ae6bf5736ae4ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__linklistmod.html#gaba23e6020b0364064707661e188037ac">jit_linklist_reverse</a> (t_jit_linklist *x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reverses the order of objects in the linked list.  <a href="#gaba23e6020b0364064707661e188037ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__linklistmod.html#ga596c1db3539f73b998755bcb46296111">jit_linklist_rotate</a> (t_jit_linklist *x, long i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotates the order of objects in the linked list, by the specified number of indeces.  <a href="#ga596c1db3539f73b998755bcb46296111"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__linklistmod.html#ga28d9508c94d221c86ce8dc6897443992">jit_linklist_shuffle</a> (t_jit_linklist *x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Randomizes the order of objects in the linked list.  <a href="#ga28d9508c94d221c86ce8dc6897443992"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__linklistmod.html#gae989e1d64d2bba31133aa79d7107f3fc">jit_linklist_swap</a> (t_jit_linklist *x, long a, long b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap list location of the indeces specified.  <a href="#gae989e1d64d2bba31133aa79d7107f3fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__linklistmod.html#gad879a11361215edf7d233c8c67ec66f9">jit_linklist_findfirst</a> (t_jit_linklist *x, void **o, long cmpfn(void *, void *), void *cmpdata)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the first object that satisfies the comparison function.  <a href="#gad879a11361215edf7d233c8c67ec66f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__linklistmod.html#ga0d8554428ade7ae33962323087eb1809">jit_linklist_findall</a> (t_jit_linklist *x, t_jit_linklist **out, long cmpfn(void *, void *), void *cmpdata)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a linked list of all objects that satisfy the comparison function.  <a href="#ga0d8554428ade7ae33962323087eb1809"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__linklistmod.html#gad09f6bfef859b63516a2c54a347250f8">jit_linklist_findcount</a> (t_jit_linklist *x, long cmpfn(void *, void *), void *cmpdata)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the number of objects that satisfy the comparison function.  <a href="#gad09f6bfef859b63516a2c54a347250f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__linklistmod.html#gaeba2a3ea3a843bcae52247957926b2bc">jit_linklist_methodall</a> (t_jit_linklist *x, <a class="el" href="structt__symbol.html">t_symbol</a> *s,...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls a method on all objects in linked list.  <a href="#gaeba2a3ea3a843bcae52247957926b2bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__linklistmod.html#ga0c9f6670c63e65887edca9f67a6982ec">jit_linklist_methodindex</a> (t_jit_linklist *x, long i, <a class="el" href="structt__symbol.html">t_symbol</a> *s,...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls a method on the object at the specified index.  <a href="#ga0c9f6670c63e65887edca9f67a6982ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__linklistmod.html#ga31462d238515067801b11b9b55f99e7a">jit_linklist_sort</a> (t_jit_linklist *x, long cmpfn(void *, void *))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts linked list based on the provided comparison function.  <a href="#ga31462d238515067801b11b9b55f99e7a"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga1c5f6c883c11c9a9f3a2ccbf2fe96f94"></a><!-- doxytag: member="jit.linklist.c::jit_linklist_append" ref="ga1c5f6c883c11c9a9f3a2ccbf2fe96f94" args="(t_jit_linklist *x, void *o)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long jit_linklist_append </td>
          <td>(</td>
          <td class="paramtype">t_jit_linklist *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>o</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append object to the end of the linked list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>t_jit_linklist object pointer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>o</em>&nbsp;</td><td>object pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>new list length, or -1 if unsuccessful</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>While exported, it is recommend to use jit_object_method to call methods on an object when the object may not be an instance of t_jit_linklist, but instead an object that supports some portion of the t_jit_linklist interface. One instance where this is the case is inside of a MOP matrix_calc method, where the arguments can be either an instance of t_jit_linklist, or t_jit_matrix which has a getindex method. </dd></dl>

</div>
</div>
<a class="anchor" id="gaba0236de39f684e338ae6bf5736ae4ad"></a><!-- doxytag: member="jit.linklist.c::jit_linklist_chuck" ref="gaba0236de39f684e338ae6bf5736ae4ad" args="(t_jit_linklist *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jit_linklist_chuck </td>
          <td>(</td>
          <td class="paramtype">t_jit_linklist *&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all objects from the linked list, without freeing any objects in list. </p>
<p>To remove all objects from the linked list, reeing the objects, use the jit_linklist_clear method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>t_jit_linklist object pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>While exported, it is recommend to use jit_object_method to call methods on an object when the object may not be an instance of t_jit_linklist, but instead an object that supports some portion of the t_jit_linklist interface. One instance where this is the case is inside of a MOP matrix_calc method, where the arguments can be either an instance of t_jit_linklist, or t_jit_matrix which has a getindex method. </dd></dl>

</div>
</div>
<a class="anchor" id="gac4958696256b4573074b1b5b48fac9db"></a><!-- doxytag: member="jit.linklist.c::jit_linklist_chuckindex" ref="gac4958696256b4573074b1b5b48fac9db" args="(t_jit_linklist *x, long index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long jit_linklist_chuckindex </td>
          <td>(</td>
          <td class="paramtype">t_jit_linklist *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove object at specified index, without freeing the object. </p>
<p>This method will not free the object. To remove from the linked list and free the object, use the jit_linklist_deleteindex method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>t_jit_linklist object pointer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>index to remove (zero based)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>index removed, or -1 if unsuccessful</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>While exported, it is recommend to use jit_object_method to call methods on an object when the object may not be an instance of t_jit_linklist, but instead an object that supports some portion of the t_jit_linklist interface. One instance where this is the case is inside of a MOP matrix_calc method, where the arguments can be either an instance of t_jit_linklist, or t_jit_matrix which has a getindex method. </dd></dl>

</div>
</div>
<a class="anchor" id="gad38efced2bcc418a6daa82a41221ea3c"></a><!-- doxytag: member="jit.linklist.c::jit_linklist_clear" ref="gad38efced2bcc418a6daa82a41221ea3c" args="(t_jit_linklist *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jit_linklist_clear </td>
          <td>(</td>
          <td class="paramtype">t_jit_linklist *&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clears the linked list, freeing all objects in list. </p>
<p>To remove all elements from the linked list without freeing the objects, use the jit_linklist_chuck method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>t_jit_linklist object pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>While exported, it is recommend to use jit_object_method to call methods on an object when the object may not be an instance of t_jit_linklist, but instead an object that supports some portion of the t_jit_linklist interface. One instance where this is the case is inside of a MOP matrix_calc method, where the arguments can be either an instance of t_jit_linklist, or t_jit_matrix which has a getindex method. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5939ee7afe931f55c10fe78b4f562b00"></a><!-- doxytag: member="jit.linklist.c::jit_linklist_deleteindex" ref="ga5939ee7afe931f55c10fe78b4f562b00" args="(t_jit_linklist *x, long index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long jit_linklist_deleteindex </td>
          <td>(</td>
          <td class="paramtype">t_jit_linklist *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete object at specified index, freeing the object. </p>
<p>To remove from the linked list without freeing the object, use the jit_linklist_chuckindex method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>t_jit_linklist object pointer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>index to delete (zero based)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>index deleted, or -1 if unsuccessful</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>While exported, it is recommend to use jit_object_method to call methods on an object when the object may not be an instance of t_jit_linklist, but instead an object that supports some portion of the t_jit_linklist interface. One instance where this is the case is inside of a MOP matrix_calc method, where the arguments can be either an instance of t_jit_linklist, or t_jit_matrix which has a getindex method. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0d8554428ade7ae33962323087eb1809"></a><!-- doxytag: member="jit.linklist.c::jit_linklist_findall" ref="ga0d8554428ade7ae33962323087eb1809" args="(t_jit_linklist *x, t_jit_linklist **out, long cmpfn(void *, void *), void *cmpdata)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jit_linklist_findall </td>
          <td>(</td>
          <td class="paramtype">t_jit_linklist *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_jit_linklist **&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &nbsp;</td>
          <td class="paramname"> <em>cmpfn</em>void *, void *, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>cmpdata</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves a linked list of all objects that satisfy the comparison function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>t_jit_linklist object pointer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>out</em>&nbsp;</td><td>pointer to linked list containing all objects found found (set to NULL, if not found) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cmpfn</em>&nbsp;</td><td>comparison function pointer (should returns 1 if object matches data, otherwise 0) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cmpdata</em>&nbsp;</td><td>opaque data used in comparison function</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>While exported, it is recommend to use jit_object_method to call methods on an object when the object may not be an instance of t_jit_linklist, but instead an object that supports some portion of the t_jit_linklist interface. One instance where this is the case is inside of a MOP matrix_calc method, where the arguments can be either an instance of t_jit_linklist, or t_jit_matrix which has a getindex method. </dd></dl>

</div>
</div>
<a class="anchor" id="gad09f6bfef859b63516a2c54a347250f8"></a><!-- doxytag: member="jit.linklist.c::jit_linklist_findcount" ref="gad09f6bfef859b63516a2c54a347250f8" args="(t_jit_linklist *x, long cmpfn(void *, void *), void *cmpdata)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long jit_linklist_findcount </td>
          <td>(</td>
          <td class="paramtype">t_jit_linklist *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &nbsp;</td>
          <td class="paramname"> <em>cmpfn</em>void *, void *, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>cmpdata</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the number of objects that satisfy the comparison function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>t_jit_linklist object pointer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cmpfn</em>&nbsp;</td><td>comparison function pointer (should returns 1 if object matches data, otherwise 0) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cmpdata</em>&nbsp;</td><td>opaque data used in comparison function</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number object objects that satisfy the comparison function</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>While exported, it is recommend to use jit_object_method to call methods on an object when the object may not be an instance of t_jit_linklist, but instead an object that supports some portion of the t_jit_linklist interface. One instance where this is the case is inside of a MOP matrix_calc method, where the arguments can be either an instance of t_jit_linklist, or t_jit_matrix which has a getindex method. </dd></dl>

</div>
</div>
<a class="anchor" id="gad879a11361215edf7d233c8c67ec66f9"></a><!-- doxytag: member="jit.linklist.c::jit_linklist_findfirst" ref="gad879a11361215edf7d233c8c67ec66f9" args="(t_jit_linklist *x, void **o, long cmpfn(void *, void *), void *cmpdata)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jit_linklist_findfirst </td>
          <td>(</td>
          <td class="paramtype">t_jit_linklist *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &nbsp;</td>
          <td class="paramname"> <em>cmpfn</em>void *, void *, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>cmpdata</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the first object that satisfies the comparison function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>t_jit_linklist object pointer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>o</em>&nbsp;</td><td>pointer to object pointer found (set to NULL, if not found) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cmpfn</em>&nbsp;</td><td>comparison function pointer (should returns 1 if object matches data, otherwise 0) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cmpdata</em>&nbsp;</td><td>opaque data used in comparison function</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>While exported, it is recommend to use jit_object_method to call methods on an object when the object may not be an instance of t_jit_linklist, but instead an object that supports some portion of the t_jit_linklist interface. One instance where this is the case is inside of a MOP matrix_calc method, where the arguments can be either an instance of t_jit_linklist, or t_jit_matrix which has a getindex method. </dd></dl>

</div>
</div>
<a class="anchor" id="ga727e60be2a2ff3426661dbac83119599"></a><!-- doxytag: member="jit.linklist.c::jit_linklist_getindex" ref="ga727e60be2a2ff3426661dbac83119599" args="(t_jit_linklist *x, long index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* jit_linklist_getindex </td>
          <td>(</td>
          <td class="paramtype">t_jit_linklist *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the object at the specified list index. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>t_jit_linklist object pointer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>list index ()</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>object pointer</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>While exported, it is recommend to use jit_object_method to call methods on an object when the object may not be an instance of t_jit_linklist, but instead an object that supports some portion of the t_jit_linklist interface. One instance where this is the case is inside of a MOP matrix_calc method, where the arguments can be either an instance of t_jit_linklist, or t_jit_matrix which has a getindex method. </dd></dl>

</div>
</div>
<a class="anchor" id="gaab0a8e1a6848d0d6713d703ebe7b9427"></a><!-- doxytag: member="jit.linklist.c::jit_linklist_getsize" ref="gaab0a8e1a6848d0d6713d703ebe7b9427" args="(t_jit_linklist *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long jit_linklist_getsize </td>
          <td>(</td>
          <td class="paramtype">t_jit_linklist *&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the linked list size. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>t_jit_linklist object pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>linked list size</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>While exported, it is recommend to use jit_object_method to call methods on an object when the object may not be an instance of t_jit_linklist, but instead an object that supports some portion of the t_jit_linklist interface. One instance where this is the case is inside of a MOP matrix_calc method, where the arguments can be either an instance of t_jit_linklist, or t_jit_matrix which has a getindex method. </dd></dl>

</div>
</div>
<a class="anchor" id="gabd11461161921960afdceb120d039a04"></a><!-- doxytag: member="jit.linklist.c::jit_linklist_insertindex" ref="gabd11461161921960afdceb120d039a04" args="(t_jit_linklist *x, void *o, long index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long jit_linklist_insertindex </td>
          <td>(</td>
          <td class="paramtype">t_jit_linklist *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert object at specified index. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>t_jit_linklist object pointer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>o</em>&nbsp;</td><td>object pointer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>index (zero based)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>index inserted at, or -1 if unsuccessful</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>While exported, it is recommend to use jit_object_method to call methods on an object when the object may not be an instance of t_jit_linklist, but instead an object that supports some portion of the t_jit_linklist interface. One instance where this is the case is inside of a MOP matrix_calc method, where the arguments can be either an instance of t_jit_linklist, or t_jit_matrix which has a getindex method. </dd></dl>

</div>
</div>
<a class="anchor" id="ga46b1ab616dda1cd288c0ef2bcff09ae8"></a><!-- doxytag: member="jit.linklist.c::jit_linklist_makearray" ref="ga46b1ab616dda1cd288c0ef2bcff09ae8" args="(t_jit_linklist *x, void **a, long max)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long jit_linklist_makearray </td>
          <td>(</td>
          <td class="paramtype">t_jit_linklist *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>max</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flatten the linked list into an array. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>t_jit_linklist object pointer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>array pointer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max</em>&nbsp;</td><td>maximum array size</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of object pointers copied into array</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>While exported, it is recommend to use jit_object_method to call methods on an object when the object may not be an instance of t_jit_linklist, but instead an object that supports some portion of the t_jit_linklist interface. One instance where this is the case is inside of a MOP matrix_calc method, where the arguments can be either an instance of t_jit_linklist, or t_jit_matrix which has a getindex method. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeba2a3ea3a843bcae52247957926b2bc"></a><!-- doxytag: member="jit.linklist.c::jit_linklist_methodall" ref="gaeba2a3ea3a843bcae52247957926b2bc" args="(t_jit_linklist *x, t_symbol *s,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jit_linklist_methodall </td>
          <td>(</td>
          <td class="paramtype">t_jit_linklist *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__symbol.html">t_symbol</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calls a method on all objects in linked list. </p>
<p>Equivalent to calling jit_object_method on the object at each index.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>t_jit_linklist object pointer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>method name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>...</em>&nbsp;</td><td>untyped arguments</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>While exported, it is recommend to use jit_object_method to call methods on an object when the object may not be an instance of t_jit_linklist, but instead an object that supports some portion of the t_jit_linklist interface. One instance where this is the case is inside of a MOP matrix_calc method, where the arguments can be either an instance of t_jit_linklist, or t_jit_matrix which has a getindex method. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0c9f6670c63e65887edca9f67a6982ec"></a><!-- doxytag: member="jit.linklist.c::jit_linklist_methodindex" ref="ga0c9f6670c63e65887edca9f67a6982ec" args="(t_jit_linklist *x, long i, t_symbol *s,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* jit_linklist_methodindex </td>
          <td>(</td>
          <td class="paramtype">t_jit_linklist *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__symbol.html">t_symbol</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calls a method on the object at the specified index. </p>
<p>Equivalent to calling jit_object_method on the object.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>t_jit_linklist object pointer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>index </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>method name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>...</em>&nbsp;</td><td>untyped arguments</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>method return value</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>While exported, it is recommend to use jit_object_method to call methods on an object when the object may not be an instance of t_jit_linklist, but instead an object that supports some portion of the t_jit_linklist interface. One instance where this is the case is inside of a MOP matrix_calc method, where the arguments can be either an instance of t_jit_linklist, or t_jit_matrix which has a getindex method. </dd></dl>

</div>
</div>
<a class="anchor" id="gae31b06dd709cdaf1e035ad562bd5626f"></a><!-- doxytag: member="jit.linklist.c::jit_linklist_new" ref="gae31b06dd709cdaf1e035ad562bd5626f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* jit_linklist_new </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs instance of t_jit_linklist. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>t_jit_linklist object pointer</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>While exported, it is recommend to use jit_object_new to construct a t_jit_linklist object. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2861d793a9f33c725e5d49946bb7e6bc"></a><!-- doxytag: member="jit.linklist.c::jit_linklist_objptr2index" ref="ga2861d793a9f33c725e5d49946bb7e6bc" args="(t_jit_linklist *x, void *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long jit_linklist_objptr2index </td>
          <td>(</td>
          <td class="paramtype">t_jit_linklist *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the list index for an object pointer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>t_jit_linklist object pointer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>object pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>object's list index (zero based), or -1 if not present</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>While exported, it is recommend to use jit_object_method to call methods on an object when the object may not be an instance of t_jit_linklist, but instead an object that supports some portion of the t_jit_linklist interface. One instance where this is the case is inside of a MOP matrix_calc method, where the arguments can be either an instance of t_jit_linklist, or t_jit_matrix which has a getindex method. </dd></dl>

</div>
</div>
<a class="anchor" id="gaba23e6020b0364064707661e188037ac"></a><!-- doxytag: member="jit.linklist.c::jit_linklist_reverse" ref="gaba23e6020b0364064707661e188037ac" args="(t_jit_linklist *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jit_linklist_reverse </td>
          <td>(</td>
          <td class="paramtype">t_jit_linklist *&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reverses the order of objects in the linked list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>t_jit_linklist object pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>While exported, it is recommend to use jit_object_method to call methods on an object when the object may not be an instance of t_jit_linklist, but instead an object that supports some portion of the t_jit_linklist interface. One instance where this is the case is inside of a MOP matrix_calc method, where the arguments can be either an instance of t_jit_linklist, or t_jit_matrix which has a getindex method. </dd></dl>

</div>
</div>
<a class="anchor" id="ga596c1db3539f73b998755bcb46296111"></a><!-- doxytag: member="jit.linklist.c::jit_linklist_rotate" ref="ga596c1db3539f73b998755bcb46296111" args="(t_jit_linklist *x, long i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jit_linklist_rotate </td>
          <td>(</td>
          <td class="paramtype">t_jit_linklist *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotates the order of objects in the linked list, by the specified number of indeces. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>t_jit_linklist object pointer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>rotation index count</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>While exported, it is recommend to use jit_object_method to call methods on an object when the object may not be an instance of t_jit_linklist, but instead an object that supports some portion of the t_jit_linklist interface. One instance where this is the case is inside of a MOP matrix_calc method, where the arguments can be either an instance of t_jit_linklist, or t_jit_matrix which has a getindex method. </dd></dl>

</div>
</div>
<a class="anchor" id="ga28d9508c94d221c86ce8dc6897443992"></a><!-- doxytag: member="jit.linklist.c::jit_linklist_shuffle" ref="ga28d9508c94d221c86ce8dc6897443992" args="(t_jit_linklist *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jit_linklist_shuffle </td>
          <td>(</td>
          <td class="paramtype">t_jit_linklist *&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Randomizes the order of objects in the linked list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>t_jit_linklist object pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>While exported, it is recommend to use jit_object_method to call methods on an object when the object may not be an instance of t_jit_linklist, but instead an object that supports some portion of the t_jit_linklist interface. One instance where this is the case is inside of a MOP matrix_calc method, where the arguments can be either an instance of t_jit_linklist, or t_jit_matrix which has a getindex method. </dd></dl>

</div>
</div>
<a class="anchor" id="ga31462d238515067801b11b9b55f99e7a"></a><!-- doxytag: member="jit.linklist.c::jit_linklist_sort" ref="ga31462d238515067801b11b9b55f99e7a" args="(t_jit_linklist *x, long cmpfn(void *, void *))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jit_linklist_sort </td>
          <td>(</td>
          <td class="paramtype">t_jit_linklist *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &nbsp;</td>
          <td class="paramname"> <em>cmpfn</em>void *, void *</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sorts linked list based on the provided comparison function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>t_jit_linklist object pointer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cmpfn</em>&nbsp;</td><td>comparison function pointer (returns 0 if a&gt;b, otherwise 1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>While exported, it is recommend to use jit_object_method to call methods on an object when the object may not be an instance of t_jit_linklist, but instead an object that supports some portion of the t_jit_linklist interface. One instance where this is the case is inside of a MOP matrix_calc method, where the arguments can be either an instance of t_jit_linklist, or t_jit_matrix which has a getindex method. </dd></dl>

</div>
</div>
<a class="anchor" id="gae989e1d64d2bba31133aa79d7107f3fc"></a><!-- doxytag: member="jit.linklist.c::jit_linklist_swap" ref="gae989e1d64d2bba31133aa79d7107f3fc" args="(t_jit_linklist *x, long a, long b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jit_linklist_swap </td>
          <td>(</td>
          <td class="paramtype">t_jit_linklist *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap list location of the indeces specified. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>t_jit_linklist object pointer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>index a </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>index b</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>While exported, it is recommend to use jit_object_method to call methods on an object when the object may not be an instance of t_jit_linklist, but instead an object that supports some portion of the t_jit_linklist interface. One instance where this is the case is inside of a MOP matrix_calc method, where the arguments can be either an instance of t_jit_linklist, or t_jit_matrix which has a getindex method. </dd></dl>

</div>
</div>
</div>
		<div id="c74footer">
			<p>Copyright &copy; 2008, <a href="http://www.cycling74.com/">Cycling '74</a></p>
		</div>
	</body>
</html>
