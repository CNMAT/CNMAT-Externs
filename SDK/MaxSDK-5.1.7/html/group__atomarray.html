<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
		<title>Max5 API Reference</title>
		<link href="c74-doxygen.css" rel="stylesheet" type="text/css">
	</head>
	<body>

		<div id="c74header">
			<img src="max5.png" />
			<p>Max 5 API Reference</p>
		</div>

<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Atom Array<br/>
<small>
[<a class="el" href="group__datastore.html">Data Storage</a>]</small>
</h1>
<p>Max's atomarray object is a container for an array of atoms with an interface for manipulating that array.  
<a href="#_details">More...</a></p>

<p><div class="dynheader">
Collaboration diagram for Atom Array:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__atomarray.png" border="0" alt="" usemap="#group____atomarray_map"/>
<map name="group____atomarray_map" id="group____atomarray">
<area shape="rect" href="group__datastore.html" title="Max provides a number of ways of storing and manipulating data at a high level." alt="" coords="5,5,123,32"/></map></td></tr></table></center>
</div>
</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt__atomarray.html">t_atomarray</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The atomarray object.  <a href="structt__atomarray.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atomarray.html#ga9d4f9396731ae8115a08f99d02421d02">ATOMARRAY_FLAG_FREECHILDREN</a>&nbsp;&nbsp;&nbsp;(1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The atomarray flags.  <a href="#ga9d4f9396731ae8115a08f99d02421d02"></a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structt__atomarray.html">t_atomarray</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atomarray.html#ga2896b4949e03841f4c5a71ad7f7fadf7">atomarray_new</a> (long ac, <a class="el" href="structt__atom.html">t_atom</a> *av)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new atomarray object.  <a href="#ga2896b4949e03841f4c5a71ad7f7fadf7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atomarray.html#gad99be67bb7fafb7987412ee8fc2802f0">atomarray_flags</a> (<a class="el" href="structt__atomarray.html">t_atomarray</a> *x, long flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the atomarray flags.  <a href="#gad99be67bb7fafb7987412ee8fc2802f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atomarray.html#gae784ffaf3fce1cd4967046faf4c7a377">atomarray_getflags</a> (<a class="el" href="structt__atomarray.html">t_atomarray</a> *x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the atomarray flags.  <a href="#gae784ffaf3fce1cd4967046faf4c7a377"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__datatypes.html#ga73edaae82b318855cc09fac994918165">t_max_err</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atomarray.html#ga52b68a97eb1bb7f97411715401d9d2ad">atomarray_setatoms</a> (<a class="el" href="structt__atomarray.html">t_atomarray</a> *x, long ac, <a class="el" href="structt__atom.html">t_atom</a> *av)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace the existing array contents with a new set of atoms Note that atoms provided to this function will be <em>copied</em>.  <a href="#ga52b68a97eb1bb7f97411715401d9d2ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__datatypes.html#ga73edaae82b318855cc09fac994918165">t_max_err</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atomarray.html#ga28824a30f15ddaec8b1a323f285fbe85">atomarray_getatoms</a> (<a class="el" href="structt__atomarray.html">t_atomarray</a> *x, long *ac, <a class="el" href="structt__atom.html">t_atom</a> **av)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve a pointer to the first atom in the internal array of atoms.  <a href="#ga28824a30f15ddaec8b1a323f285fbe85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__datatypes.html#ga73edaae82b318855cc09fac994918165">t_max_err</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atomarray.html#gaec25ec428f6bb7b1a1c8092b5c01f2c2">atomarray_copyatoms</a> (<a class="el" href="structt__atomarray.html">t_atomarray</a> *x, long *ac, <a class="el" href="structt__atom.html">t_atom</a> **av)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve a copy of the atoms in the array.  <a href="#gaec25ec428f6bb7b1a1c8092b5c01f2c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atomarray.html#gaef611e510133de82b09496f9ff59662f">atomarray_getsize</a> (<a class="el" href="structt__atomarray.html">t_atomarray</a> *x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of atoms in the array.  <a href="#gaef611e510133de82b09496f9ff59662f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__datatypes.html#ga73edaae82b318855cc09fac994918165">t_max_err</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atomarray.html#ga1ee643830e94d84c325fd8caa4db9d4b">atomarray_getindex</a> (<a class="el" href="structt__atomarray.html">t_atomarray</a> *x, long index, <a class="el" href="structt__atom.html">t_atom</a> *av)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy an a specific atom from the array.  <a href="#ga1ee643830e94d84c325fd8caa4db9d4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atomarray.html#ga96ea96717c2ed692197361b1d02bab47">atomarray_duplicate</a> (<a class="el" href="structt__atomarray.html">t_atomarray</a> *x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new atomarray object which is a copy of another atomarray object.  <a href="#ga96ea96717c2ed692197361b1d02bab47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atomarray.html#gad2d3608a3089f42590d744814c6fee42">atomarray_appendatom</a> (<a class="el" href="structt__atomarray.html">t_atomarray</a> *x, <a class="el" href="structt__atom.html">t_atom</a> *a)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy a new atom onto the end of the array.  <a href="#gad2d3608a3089f42590d744814c6fee42"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atomarray.html#gae604fed9f8ca266b1b0d080e8cc929c3">atomarray_appendatoms</a> (<a class="el" href="structt__atomarray.html">t_atomarray</a> *x, long ac, <a class="el" href="structt__atom.html">t_atom</a> *av)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy multiple new atoms onto the end of the array.  <a href="#gae604fed9f8ca266b1b0d080e8cc929c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atomarray.html#gaf76d3ab0de8a7b6b0b0e32193608c2dd">atomarray_chuckindex</a> (<a class="el" href="structt__atomarray.html">t_atomarray</a> *x, long index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove an atom from any location within the array.  <a href="#gaf76d3ab0de8a7b6b0b0e32193608c2dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atomarray.html#ga185b275ee3d94fa9a21d3ca6ece43c33">atomarray_clear</a> (<a class="el" href="structt__atomarray.html">t_atomarray</a> *x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the array.  <a href="#ga185b275ee3d94fa9a21d3ca6ece43c33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atomarray.html#gacfb767a18f14fb13a0952c6ed7903de1">atomarray_funall</a> (<a class="el" href="structt__atomarray.html">t_atomarray</a> *x, <a class="el" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d">method</a> fun, void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call the specified function for every item in the atom array.  <a href="#gacfb767a18f14fb13a0952c6ed7903de1"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Max's atomarray object is a container for an array of atoms with an interface for manipulating that array. </p>
<p>It can be useful for passing lists as a single atom, such as for the return value of an <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47ad150bf3de9c8dc2ddfa0ca0ca2382360" title="request that args be passed as an array, the routine will check the types itself...">A_GIMMEBACK</a> method. It also used frequently in when working with Max's <a class="el" href="structt__dictionary.html" title="The dictionary object.">t_dictionary</a> object.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__dictionary.html" title="In Max 5, we have a new &quot;dictionary&quot; object which can be used for object...">Dictionary</a> </dd></dl>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga9d4f9396731ae8115a08f99d02421d02"></a><!-- doxytag: member="ext_atomarray.h::ATOMARRAY_FLAG_FREECHILDREN" ref="ga9d4f9396731ae8115a08f99d02421d02" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ATOMARRAY_FLAG_FREECHILDREN&nbsp;&nbsp;&nbsp;(1)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The atomarray flags. </p>
<p>Currently the only flag is ATOMARRAY_FLAG_FREECHILDREN. If set via <a class="el" href="group__atomarray.html#gad99be67bb7fafb7987412ee8fc2802f0" title="Set the atomarray flags.">atomarray_flags()</a> the atomarray will free any contained A_OBJ atoms when the atomarray is freed. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gad2d3608a3089f42590d744814c6fee42"></a><!-- doxytag: member="ext_atomarray.h::atomarray_appendatom" ref="gad2d3608a3089f42590d744814c6fee42" args="(t_atomarray *x, t_atom *a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void atomarray_appendatom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__atomarray.html">t_atomarray</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__atom.html">t_atom</a> *&nbsp;</td>
          <td class="paramname"> <em>a</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy a new atom onto the end of the array. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The atomarray instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>A pointer to the new atom to append to the end of the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__atomarray.html#gae604fed9f8ca266b1b0d080e8cc929c3" title="Copy multiple new atoms onto the end of the array.">atomarray_appendatoms()</a> </dd>
<dd>
<a class="el" href="group__atomarray.html#ga52b68a97eb1bb7f97411715401d9d2ad" title="Replace the existing array contents with a new set of atoms Note that atoms provided...">atomarray_setatoms()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae604fed9f8ca266b1b0d080e8cc929c3"></a><!-- doxytag: member="ext_atomarray.h::atomarray_appendatoms" ref="gae604fed9f8ca266b1b0d080e8cc929c3" args="(t_atomarray *x, long ac, t_atom *av)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void atomarray_appendatoms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__atomarray.html">t_atomarray</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__atom.html">t_atom</a> *&nbsp;</td>
          <td class="paramname"> <em>av</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy multiple new atoms onto the end of the array. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The atomarray instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ac</em>&nbsp;</td><td>The number of new atoms to be appended to the array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>av</em>&nbsp;</td><td>A pointer to the first of the new atoms to append to the end of the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__atomarray.html#gad2d3608a3089f42590d744814c6fee42" title="Copy a new atom onto the end of the array.">atomarray_appendatom()</a> </dd>
<dd>
<a class="el" href="group__atomarray.html#ga52b68a97eb1bb7f97411715401d9d2ad" title="Replace the existing array contents with a new set of atoms Note that atoms provided...">atomarray_setatoms()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf76d3ab0de8a7b6b0b0e32193608c2dd"></a><!-- doxytag: member="ext_atomarray.h::atomarray_chuckindex" ref="gaf76d3ab0de8a7b6b0b0e32193608c2dd" args="(t_atomarray *x, long index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void atomarray_chuckindex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__atomarray.html">t_atomarray</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove an atom from any location within the array. </p>
<p>The array will be resized and collapsed to fill in the gap.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The atomarray instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>The zero-based index of the atom to remove from the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga185b275ee3d94fa9a21d3ca6ece43c33"></a><!-- doxytag: member="ext_atomarray.h::atomarray_clear" ref="ga185b275ee3d94fa9a21d3ca6ece43c33" args="(t_atomarray *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void atomarray_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__atomarray.html">t_atomarray</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear the array. </p>
<p>Frees all of the atoms and sets the size to zero. This function does not perform a 'deep' free, meaning that any <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a82cc76e0d53c8fc28df167c35d5bbd1a" title="t_object pointer (for argtype lists; passes the value of sym)">A_OBJ</a> atoms will not have their object's freed. Only the references to those objects contained in the atomarray will be freed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The atomarray instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of atoms in the array. </dd></dl>

</div>
</div>
<a class="anchor" id="gaec25ec428f6bb7b1a1c8092b5c01f2c2"></a><!-- doxytag: member="ext_atomarray.h::atomarray_copyatoms" ref="gaec25ec428f6bb7b1a1c8092b5c01f2c2" args="(t_atomarray *x, long *ac, t_atom **av)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__datatypes.html#ga73edaae82b318855cc09fac994918165">t_max_err</a> atomarray_copyatoms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__atomarray.html">t_atomarray</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&nbsp;</td>
          <td class="paramname"> <em>ac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__atom.html">t_atom</a> **&nbsp;</td>
          <td class="paramname"> <em>av</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve a copy of the atoms in the array. </p>
<p>This method does not copy the atoms, btu simply provides access to them. To retrieve a copy of the atoms use <a class="el" href="group__atomarray.html#gaec25ec428f6bb7b1a1c8092b5c01f2c2" title="Retrieve a copy of the atoms in the array.">atomarray_copyatoms()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The atomarray instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ac</em>&nbsp;</td><td>The address of a long where the number of atoms will be set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>av</em>&nbsp;</td><td>The address of a <a class="el" href="structt__atom.html" title="An atom is a typed datum.">t_atom</a> pointer where the atoms will be allocated and copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A Max error code.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>You are responsible for freeing memory allocated for the copy of the atoms returned. <div class="fragment"><pre class="fragment">   <span class="keywordtype">long</span>  ac = 0;
   <a class="code" href="structt__atom.html" title="An atom is a typed datum.">t_atom</a> *av = NULL;
   
   <a class="code" href="group__atomarray.html#gaec25ec428f6bb7b1a1c8092b5c01f2c2" title="Retrieve a copy of the atoms in the array.">atomarray_copyatoms</a>(anAtomarray, &amp;ac, &amp;av);
   <span class="keywordflow">if</span>(ac &amp;&amp; av){
      <span class="comment">// do something with ac and av here...</span>
      <a class="code" href="group__memory.html#ga200c82639e547869db1f3887d17102d3" title="Free memory allocated with sysmem_newptr().">sysmem_freeptr</a>(av);
   }  
</pre></div></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__atomarray.html#ga28824a30f15ddaec8b1a323f285fbe85" title="Retrieve a pointer to the first atom in the internal array of atoms.">atomarray_getatoms()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga96ea96717c2ed692197361b1d02bab47"></a><!-- doxytag: member="ext_atomarray.h::atomarray_duplicate" ref="ga96ea96717c2ed692197361b1d02bab47" args="(t_atomarray *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* atomarray_duplicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__atomarray.html">t_atomarray</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new atomarray object which is a copy of another atomarray object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The atomarray instance which is to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new atomarray which is copied from x.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__atomarray.html#ga2896b4949e03841f4c5a71ad7f7fadf7" title="Create a new atomarray object.">atomarray_new()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gad99be67bb7fafb7987412ee8fc2802f0"></a><!-- doxytag: member="ext_atomarray.h::atomarray_flags" ref="gad99be67bb7fafb7987412ee8fc2802f0" args="(t_atomarray *x, long flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void atomarray_flags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__atomarray.html">t_atomarray</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the atomarray flags. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The atomarray instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>The new value for the flags. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacfb767a18f14fb13a0952c6ed7903de1"></a><!-- doxytag: member="ext_atomarray.h::atomarray_funall" ref="gacfb767a18f14fb13a0952c6ed7903de1" args="(t_atomarray *x, method fun, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void atomarray_funall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__atomarray.html">t_atomarray</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d">method</a>&nbsp;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call the specified function for every item in the atom array. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The atomarray instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fun</em>&nbsp;</td><td>The function to call, specified as function pointer cast to a Max <a class="el" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d" title="Function pointer type for generic methods.">method</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>An argument that you would like to pass to the function being called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A max error code.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The <a class="el" href="group__atomarray.html#gacfb767a18f14fb13a0952c6ed7903de1" title="Call the specified function for every item in the atom array.">atomarray_funall()</a> method will call your function for every item in the list. It will pass both a pointer to the item in the list, and any argument that you provide. The following example shows a function that could be called by <a class="el" href="group__hashtab.html#ga37e7b5c20c9fc69e9435f788f35335dc" title="Call the specified function for every item in the hashtab.">hashtab_funall()</a>. <div class="fragment"><pre class="fragment">   <span class="keywordtype">void</span> myFun(<a class="code" href="structt__atom.html" title="An atom is a typed datum.">t_atom</a> *a, <span class="keywordtype">void</span> *myArg)
   {
      <span class="comment">// do something with a and myArg here</span>
      <span class="comment">// a is the atom in the atom array</span>
   }
</pre></div></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__linklist.html#ga6f4496ef6dc1d6d121acf25d7cd5f946" title="Call the specified function for every item in the linklist.">linklist_funall()</a> </dd>
<dd>
<a class="el" href="group__hashtab.html#ga37e7b5c20c9fc69e9435f788f35335dc" title="Call the specified function for every item in the hashtab.">hashtab_funall()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga28824a30f15ddaec8b1a323f285fbe85"></a><!-- doxytag: member="ext_atomarray.h::atomarray_getatoms" ref="ga28824a30f15ddaec8b1a323f285fbe85" args="(t_atomarray *x, long *ac, t_atom **av)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__datatypes.html#ga73edaae82b318855cc09fac994918165">t_max_err</a> atomarray_getatoms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__atomarray.html">t_atomarray</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&nbsp;</td>
          <td class="paramname"> <em>ac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__atom.html">t_atom</a> **&nbsp;</td>
          <td class="paramname"> <em>av</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve a pointer to the first atom in the internal array of atoms. </p>
<p>This method does not copy the atoms, btu simply provides access to them. To retrieve a copy of the atoms use <a class="el" href="group__atomarray.html#gaec25ec428f6bb7b1a1c8092b5c01f2c2" title="Retrieve a copy of the atoms in the array.">atomarray_copyatoms()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The atomarray instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ac</em>&nbsp;</td><td>The address of a long where the number of atoms will be set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>av</em>&nbsp;</td><td>The address of a <a class="el" href="structt__atom.html" title="An atom is a typed datum.">t_atom</a> pointer where the address of the first atom of the array will be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A Max error code.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__atomarray.html#gaec25ec428f6bb7b1a1c8092b5c01f2c2" title="Retrieve a copy of the atoms in the array.">atomarray_copyatoms()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae784ffaf3fce1cd4967046faf4c7a377"></a><!-- doxytag: member="ext_atomarray.h::atomarray_getflags" ref="gae784ffaf3fce1cd4967046faf4c7a377" args="(t_atomarray *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long atomarray_getflags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__atomarray.html">t_atomarray</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the atomarray flags. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The atomarray instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current value of the atomarray flags. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1ee643830e94d84c325fd8caa4db9d4b"></a><!-- doxytag: member="ext_atomarray.h::atomarray_getindex" ref="ga1ee643830e94d84c325fd8caa4db9d4b" args="(t_atomarray *x, long index, t_atom *av)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__datatypes.html#ga73edaae82b318855cc09fac994918165">t_max_err</a> atomarray_getindex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__atomarray.html">t_atomarray</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__atom.html">t_atom</a> *&nbsp;</td>
          <td class="paramname"> <em>av</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy an a specific atom from the array. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The atomarray instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>The zero-based index into the array from which to retrieve an atom pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>av</em>&nbsp;</td><td>The address of an atom to contain the copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A Max error code.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Example: <div class="fragment"><pre class="fragment">   {
      <a class="code" href="structt__atom.html" title="An atom is a typed datum.">t_atom</a> a;

      <span class="comment">// fetch a copy of the second atom in a previously existing array</span>
      <a class="code" href="group__atomarray.html#ga1ee643830e94d84c325fd8caa4db9d4b" title="Copy an a specific atom from the array.">atomarray_getindex</a>(anAtomarray, 1, &amp;a);
      <span class="comment">// do something with the atom here...</span>
   }
</pre></div> </dd></dl>

</div>
</div>
<a class="anchor" id="gaef611e510133de82b09496f9ff59662f"></a><!-- doxytag: member="ext_atomarray.h::atomarray_getsize" ref="gaef611e510133de82b09496f9ff59662f" args="(t_atomarray *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long atomarray_getsize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__atomarray.html">t_atomarray</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the number of atoms in the array. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The atomarray instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of atoms in the array. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2896b4949e03841f4c5a71ad7f7fadf7"></a><!-- doxytag: member="ext_atomarray.h::atomarray_new" ref="ga2896b4949e03841f4c5a71ad7f7fadf7" args="(long ac, t_atom *av)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structt__atomarray.html">t_atomarray</a>* atomarray_new </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__atom.html">t_atom</a> *&nbsp;</td>
          <td class="paramname"> <em>av</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new atomarray object. </p>
<p>Note that atoms provided to this function will be <em>copied</em>. The copies stored internally to the atomarray instance. You can free the atomarray by calling <a class="el" href="group__obj.html#ga3759846cb356195532c41e35b87522ee" title="Call the free function and release the memory for an instance of an internal object...">object_free()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ac</em>&nbsp;</td><td>The number of atoms to be initially contained in the atomarray. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>av</em>&nbsp;</td><td>A pointer to the first of an array of atoms to initially copy into the atomarray. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the new atomarray object.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Note that due to the unusual prototype of this method that you cannot instantiate this object using the <a class="el" href="group__obj.html#ga459c71aca6316e345379eeb424ad56ff" title="Allocates the memory for an instance of an object class and initialize its object...">object_new_typed()</a> function. If you wish to use the dynamically bound creator to instantiate the object, you should instead should use <a class="el" href="group__obj.html#gac4b370265c776db4f545d257089af1cf" title="Allocates the memory for an instance of an object class and initialize its object...">object_new()</a> as demonstrated below. The primary reason that you might choose to instantiate an atomarray using <a class="el" href="group__obj.html#gac4b370265c776db4f545d257089af1cf" title="Allocates the memory for an instance of an object class and initialize its object...">object_new()</a> instead of <a class="el" href="group__atomarray.html#ga2896b4949e03841f4c5a71ad7f7fadf7" title="Create a new atomarray object.">atomarray_new()</a> is for using the atomarray object in code that is also intended to run in Max 4. <div class="fragment"><pre class="fragment">   <a class="code" href="group__obj.html#gac4b370265c776db4f545d257089af1cf" title="Allocates the memory for an instance of an object class and initialize its object...">object_new</a>(<a class="code" href="group__class.html#ga090d3cbc4f137661806fc1b72249a791" title="A namespace for creating hidden or internal object classes which are not a direct...">CLASS_NOBOX</a>, <a class="code" href="group__symbol.html#ga5d8db08b384aeb76eaee85a15f46fbcb" title="Given a C-string, fetch the matching t_symbol pointer from the symbol table, generating...">gensym</a>(<span class="stringliteral">&quot;atomarray&quot;</span>), argc, argv);
</pre></div></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__atomarray.html#ga96ea96717c2ed692197361b1d02bab47" title="Create a new atomarray object which is a copy of another atomarray object.">atomarray_duplicate()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga52b68a97eb1bb7f97411715401d9d2ad"></a><!-- doxytag: member="ext_atomarray.h::atomarray_setatoms" ref="ga52b68a97eb1bb7f97411715401d9d2ad" args="(t_atomarray *x, long ac, t_atom *av)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__datatypes.html#ga73edaae82b318855cc09fac994918165">t_max_err</a> atomarray_setatoms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__atomarray.html">t_atomarray</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__atom.html">t_atom</a> *&nbsp;</td>
          <td class="paramname"> <em>av</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replace the existing array contents with a new set of atoms Note that atoms provided to this function will be <em>copied</em>. </p>
<p>The copies stored internally to the atomarray instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The atomarray instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ac</em>&nbsp;</td><td>The number of atoms to be initially contained in the atomarray. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>av</em>&nbsp;</td><td>A pointer to the first of an array of atoms to initially copy into the atomarray. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A Max error code. </dd></dl>

</div>
</div>
</div>
		<div id="c74footer">
			<p>Copyright &copy; 2008, <a href="http://www.cycling74.com/">Cycling '74</a></p>
		</div>
	</body>
</html>
