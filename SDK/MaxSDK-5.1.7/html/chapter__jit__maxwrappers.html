<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
		<title>Max5 API Reference</title>
		<link href="c74-doxygen.css" rel="stylesheet" type="text/css">
	</head>
	<body>

		<div id="c74header">
			<img src="max5.png" />
			<p>Max 5 API Reference</p>
		</div>

<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="chapter_jit_maxwrappers">Jitter Max Wrappers </a></h1><h2><a class="anchor" id="chapter_jit_maxwrappers_classes">
Max Wrapper Classes</a></h2>
<p>In order to expose the Jitter object to the Max patcher, a Max "wrapper" class must be defined. For simple classes, this is largely facilitated by a handful of utility functions that take a Jitter class and create the appropriate wrapper class with default functionality. However, there are occasions which warrant additional intervention to achieve special behavior, such as the use of additional inlets and outlets, integrating with MSP, converting matrix information to and from Max lists, etc. The first Max wrapper class we'll demonstrate won't have any extra complication beyond simply containing a basic Jitter class.</p>
<p>In general it is preferable to design the Jitter class so that it knows nothing about the Max patcher, and that any logic necessary to communicate with the patcher is maintained in the Max wrapper class. In situations where this might seem difficult, this can typically be accomplished by making special methods in the Jitter class that are only meant to be called by the Max wrapper, or by using Jitter's object notification mechanism, which we'll discuss in a future chapter. Below is the minimal Max wrapper class for the minimal Jitter class shown in the last chapter.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> <span class="keyword">struct </span>_max_jit_foo
{
   <a class="code" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or...">t_object</a>       ob;
   <span class="keywordtype">void</span>         *obex;
} t_max_jit_foo;

<span class="keywordtype">void</span> *class_max_jit_foo;

<span class="keywordtype">void</span> main()
{   
   <span class="keywordtype">void</span> *p,*q;
   
   <span class="comment">// initialize the Jitter class</span>
   jit_foo_init(); 
   
   <span class="comment">// create the Max class as documented in Writing Max Externals</span>
   <a class="code" href="group__class__old.html#ga24bbc5a9e8f7bb0a1c6847326e2f0a20" title="Use the setup() function to initialize your class by informing Max of its size, the...">setup</a>(&amp;class_max_jit_foo, 
      (<a class="code" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d" title="Function pointer type for generic methods.">method</a>) max_jit_foo_new, 
      (<a class="code" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d" title="Function pointer type for generic methods.">method</a>) max_jit_foo_free, 
      (<span class="keywordtype">short</span>)<span class="keyword">sizeof</span>(t_max_jit_foo), 
      0L, <a class="code" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a81c1a8550f038db16a619167a70a79b6" title="request that args be passed as an array, the routine will check the types itself...">A_GIMME</a>, 0);

   <span class="comment">// specify a byte offset to keep additional information</span>
   p = <a class="code" href="group__maxwrapmod.html#ga773b6e6430d9de2e295419c7f038979e" title="Allocates and initializes special t_max_jit_classex data, used by the Max wrapper...">max_jit_classex_setup</a>(<a class="code" href="group__misc.html#gaad95899dfbc7b5b8fe11921643ef46f0" title="Find byte offset of a named member of a struct, relative to the beginning of that...">calcoffset</a>(t_max_jit_foo, obex));
   
   <span class="comment">// look up the Jitter class in the class registry</span>
   q = <a class="code" href="group__classmod.html#ga63eb9d25f881cd6fba11e24f9ac9b02f" title="Retrieves class pointer associated with name provided.">jit_class_findbyname</a>(<a class="code" href="group__symbol.html#ga5d8db08b384aeb76eaee85a15f46fbcb" title="Given a C-string, fetch the matching t_symbol pointer from the symbol table, generating...">gensym</a>(<span class="stringliteral">&quot;jit_foo&quot;</span>));    
   
   <span class="comment">// wrap the Jitter class with the standard methods for Jitter objects</span>
   <a class="code" href="group__maxwrapmod.html#ga9b8377bdccc2497e02582c72204b5250" title="Adds standard Jitter methods, as well as public methods and attributes of the specified...">max_jit_classex_standard_wrap</a>(p, q, 0);    

   <span class="comment">// add an inlet/outlet assistance method</span>
   <a class="code" href="group__class__old.html#ga0d9bfa416fdd861d1b2fd2d17701cbb3" title="Use addmess() to bind a function to a message other than the standard ones covered...">addmess</a>((<a class="code" href="group__datatypes.html#gac26ba0a173b50597f5738132e059b42d" title="Function pointer type for generic methods.">method</a>)max_jit_foo_assist, <span class="stringliteral">&quot;assist&quot;</span>, <a class="code" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47af48193ec36e53b1507d81c49873c8d7a" title="cannot typecheck args">A_CANT</a>,0);
}

<span class="keywordtype">void</span> max_jit_foo_assist(t_max_jit_foo *x, <span class="keywordtype">void</span> *b, <span class="keywordtype">long</span> m, <span class="keywordtype">long</span> a, <span class="keywordtype">char</span> *s)
{
   <span class="comment">// no inlet/outlet assistance</span>
}

<span class="keywordtype">void</span> max_jit_foo_free(t_max_jit_foo *x)
{
   <span class="comment">// lookup the internal Jitter object instance and free</span>
   <a class="code" href="group__objectmod.html#ga64970b62e5afe7a2cbd57efd6e9e9f74" title="Frees an object.">jit_object_free</a>(<a class="code" href="group__maxwrapmod.html#ga063ab88bfc92c1a666f3ad6251834e20" title="Retrieves the wrapped Jitter object from a Max wrapper object.">max_jit_obex_jitob_get</a>(x));
   
   <span class="comment">// free resources associated with the obex entry</span>
   <a class="code" href="group__maxwrapmod.html#gabcf9c466a6baa22994a66e30b54e7dd6" title="Frees additional resources for the Max wrapper object instance.">max_jit_obex_free</a>(x);
}

<span class="keywordtype">void</span> *max_jit_foo_new(<a class="code" href="structt__symbol.html" title="The symbol.">t_symbol</a> *s, <span class="keywordtype">long</span> argc, <a class="code" href="structt__atom.html" title="An atom is a typed datum.">t_atom</a> *argv)
{
   t_max_jit_foo *x;
   <span class="keywordtype">long</span> attrstart;
   <span class="keywordtype">void</span> *o;

   <span class="comment">// create the wrapper object instance based on the</span>
   <span class="comment">// max wrapper class, and the jitter class </span>
   <span class="keywordflow">if</span> (x = (t_max_jit_foo *)<a class="code" href="group__maxwrapmod.html#gacf7fc6f3f87db8515f61b12efbcc9073" title="Allocates an initializes a new Max wrapper object instance.">max_jit_obex_new</a>(class_max_jit_foo, 
         <a class="code" href="group__symbol.html#ga5d8db08b384aeb76eaee85a15f46fbcb" title="Given a C-string, fetch the matching t_symbol pointer from the symbol table, generating...">gensym</a>(<span class="stringliteral">&quot;jit_foo&quot;</span>))) 
   {
      <span class="comment">// add a general purpose outlet (rightmost)</span>
      <a class="code" href="group__maxwrapmod.html#ga8e63a402ecf8cef78a9093c774159a9e" title="Sets the Max wrapper object&amp;#39;s dump outlet&amp;#39;s outlet pointer.">max_jit_obex_dumpout_set</a>(x, <a class="code" href="group__inout.html#gac25db50a2a7eb76c5e057dd907c11d44" title="Use outlet_new() to create an outlet that can send a specific non-standard message...">outlet_new</a>(x,0L));
      
      <span class="comment">// get normal args if necessary</span>
      attrstart = <a class="code" href="group__maxwrapmod.html#ga1a28ddf72d9bdcb2096df36384b63de6" title="Determines argument offset to first attribute argument.">max_jit_attr_args_offset</a>(argc,argv);
      
      <span class="comment">// instantiate Jitter object</span>
      <span class="keywordflow">if</span> (o = <a class="code" href="group__objectmod.html#gabde2eb49750992ec4125af862b402342" title="Instantiates an object specified by class name.">jit_object_new</a>(<a class="code" href="group__symbol.html#ga5d8db08b384aeb76eaee85a15f46fbcb" title="Given a C-string, fetch the matching t_symbol pointer from the symbol table, generating...">gensym</a>(<span class="stringliteral">&quot;jit_foo&quot;</span>))) 
      {
         <span class="comment">// set internal jitter object instance </span>
         <a class="code" href="group__maxwrapmod.html#gaa1b174cf92680ca46bfb189a812d2a65" title="Sets the wrapped Jitter object for a Max wrapper object.">max_jit_obex_jitob_set</a>(x,o);
         
         <span class="comment">// process attribute arguments</span>
         <a class="code" href="group__maxwrapmod.html#gac1ffd4864421154c8e6364b5df9a09ff" title="Processes attribtue arguments.">max_jit_attr_args</a>(x,argc,argv);
      } 
      <span class="keywordflow">else</span> 
      {   
         <span class="comment">// couldn&#39;t instantiate, clean up and report an error</span>
         <a class="code" href="group__class__old.html#gadf30646e52376a37b93cc20efac65636" title="Release the memory used by a Max object.">freeobject</a>((<span class="keywordtype">void</span> *)x);
         x = NULL;
         <a class="code" href="group__console.html#ga8a87d2e25431900a88722759ec115757" title="Print an error to the Max window.">error</a>(<span class="stringliteral">&quot;jit.foo: out of memory&quot;</span>);
      }
   }

   <span class="keywordflow">return</span> (x);
}
</pre></div><h2><a class="anchor" id="chapter_jit_maxwrappers_struct">
Object Struct</a></h2>
<p>The first thing you must do is define your Max class object struct. As is typical, for standard Max objects the first entry of the object struct must be of type <a class="el" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or...">t_object</a>; for UI objects, it must be of type <a class="el" href="structt__jbox.html" title="The t_jbox struct provides the header for a Max user-interface object.">t_jbox</a>; for MSP objects, it must be of type <a class="el" href="structt__pxobject.html" title="Header for any non-ui signal processing object.">t_pxobject</a>; and for MSP UI objects, it must be of type <a class="el" href="structt__pxjbox.html" title="Header for any ui signal processing object.">t_pxjbox</a>. For more information on these different Max/MSP object types, please consult the Max/MSP developer documentation. Jitter objects can be wrapped within any of these object types.</p>
<p>You also need to define a pointer to point to extra information and resources needed to effectively wrap your Jitter class. This is typically referred to as the "obex" data, and it is where Jitter stores things like attribute information, the general purpose "dumpout", the internal Jitter object instance, Matrix Operator resources for inlets/outlets, and other auxiliary object information that is not required in a simple Max object. As of Max 4.5 there is also the facility for making use of such additional object information for ordinary Max objects. At the time of this writing, such information is provided in the Pattr developer documentation, as it is relevant to the definition of object attributes, which may be stored and operated upon by the patcher attribute suite of objects.</p>
<h2><a class="anchor" id="chapter_jit_maxwrappers_classdef">
Defining Your Max Class</a></h2>
<p>In your Max class registration, which takes place in your external's main function, you should begin by calling your Jitter class's registration function, typically named something like your_object_name_init(). Then you should proceed to define the Max class's constructor, destructor, object struct size, and typed arguments as is typically accomplished for Max objects via the setup function. In order for your wrapper class to be able to find the obex data, you need to specify a byte offset where this pointer is located within each object instance and allocate the resource in which this is stored in your Max class. This is accomplished with the <a class="el" href="group__maxwrapmod.html#ga773b6e6430d9de2e295419c7f038979e" title="Allocates and initializes special t_max_jit_classex data, used by the Max wrapper...">max_jit_classex_setup()</a> function. You should then look up the Jitter class via <a class="el" href="group__classmod.html#ga63eb9d25f881cd6fba11e24f9ac9b02f" title="Retrieves class pointer associated with name provided.">jit_class_findbyname()</a>, and wrap it via the <a class="el" href="group__maxwrapmod.html#ga9b8377bdccc2497e02582c72204b5250" title="Adds standard Jitter methods, as well as public methods and attributes of the specified...">max_jit_classex_standard_wrap()</a> function. The <a class="el" href="group__maxwrapmod.html#ga9b8377bdccc2497e02582c72204b5250" title="Adds standard Jitter methods, as well as public methods and attributes of the specified...">max_jit_classex_standard_wrap()</a> function will add all typed methods defined in the Jitter class, as well getter and setter methods for attributes that are not opaque (i.e. private), and all the methods that are common to Jitter objects like getattributes, getstate, summary, importattrs, exportattrs, etc.</p>
<p>Now that you have wrapped the Jitter class, you can add any additional methods that you wish, such as your inlet/outlet assistance method, or something specific to the Max object. Like Jitter objects, you can also add methods which have defer or usurp wrappers, and these should be added via the <a class="el" href="group__maxwrapmod.html#gac057d2e8d94686363fa9ae8ea0b41fee" title="Adds method to Max class that calls defer_low rather than the method directly.">max_addmethod_defer_low()</a> or <a class="el" href="group__maxwrapmod.html#ga2c596151798123076dcd1d4f7d76e203" title="Adds method to Max class that uses the usurp mechanism to execute method at low priority...">max_addmethod_usurp_low()</a> functions, rather than simply using the traditional <a class="el" href="group__class__old.html#ga0d9bfa416fdd861d1b2fd2d17701cbb3" title="Use addmess() to bind a function to a message other than the standard ones covered...">addmess()</a> function. C</p>
<h2><a class="anchor" id="chapter_jit_maxwrappers_ctor">
Constructor</a></h2>
<p>Inside the Max object constructor, there are a few things which are different than building an ordinary Max external. If your object is to respond to attribute arguments, the constructor must be defined to take variable number of typed atom arguments, accomplished with the <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a81c1a8550f038db16a619167a70a79b6" title="request that args be passed as an array, the routine will check the types itself...">A_GIMME</a> signature. You allocate your Max object with the <a class="el" href="group__maxwrapmod.html#gacf7fc6f3f87db8515f61b12efbcc9073" title="Allocates an initializes a new Max wrapper object instance.">max_jit_obex_new()</a> function, instead of the traditional newobject function. You need to pass your Jitter class name to the <a class="el" href="group__maxwrapmod.html#gacf7fc6f3f87db8515f61b12efbcc9073" title="Allocates an initializes a new Max wrapper object instance.">max_jit_obex_new()</a> function, which also allocates and initializes your obex data. If successful, you should proceed to add your general purpose "dumpout" outlet, used for returning attribute queries and other methods that provide information like *jit.qt.movie*'s framedump method's frame number or read method success code, with the max_jit_object_dumpout_set() function. If your object is a Matrix Operator that calls <a class="el" href="group__maxmopmod.html#gac3eaca207281516b72e81f0dc5f4bf94" title="Initializes default state and resources for MOP Max wrapper class.">max_jit_mop_setup_simple()</a> you will not need to explicitly call max_jit_object_dumpout_set(), as <a class="el" href="group__maxmopmod.html#gac3eaca207281516b72e81f0dc5f4bf94" title="Initializes default state and resources for MOP Max wrapper class.">max_jit_mop_setup_simple()</a> calls max_jit_object_dumpout_set() internally.</p>
<p>You then allocate your Jitter object with <a class="el" href="group__objectmod.html#gabde2eb49750992ec4125af862b402342" title="Instantiates an object specified by class name.">jit_object_new()</a>, and store it in your obex data via <a class="el" href="group__maxwrapmod.html#gaa1b174cf92680ca46bfb189a812d2a65" title="Sets the wrapped Jitter object for a Max wrapper object.">max_jit_obex_jitob_set()</a>. Note that this Jitter object instance can always be found with the function <a class="el" href="group__maxwrapmod.html#ga063ab88bfc92c1a666f3ad6251834e20" title="Retrieves the wrapped Jitter object from a Max wrapper object.">max_jit_obex_jitob_get()</a>. If you wish, prior to allocating your Jitter object, you can look at your non-attribute arguments first — those arguments up to the location returned by <a class="el" href="group__maxwrapmod.html#ga1a28ddf72d9bdcb2096df36384b63de6" title="Determines argument offset to first attribute argument.">max_jit_attr_args_offset()</a> — and make use of them in your Jitter object constructor. It is typical to process attribute arguments after you've allocated both the Max and Jitter object instances, with <a class="el" href="group__maxwrapmod.html#gac1ffd4864421154c8e6364b5df9a09ff" title="Processes attribtue arguments.">max_jit_attr_args()</a>, which is passed the Max object instance. If you wanted to use the attribute arguments somehow in your Jitter object constructor, you would need to parse the attribute arguments yourself. If you are not able to allocate your Jitter object (as is the case if you have run out of memory or if Jitter is present but not authorized), it is important that you clean up your Max wrapper object, and return NULL.</p>
<h2><a class="anchor" id="chapter_jit_maxwrappers_dtor">
Destructor</a></h2>
<p>In your Max object destructor, you additionally need to free your internal Jitter object with <a class="el" href="group__objectmod.html#ga64970b62e5afe7a2cbd57efd6e9e9f74" title="Frees an object.">jit_object_free()</a>, and free any additional obex data with <a class="el" href="group__maxwrapmod.html#gabcf9c466a6baa22994a66e30b54e7dd6" title="Frees additional resources for the Max wrapper object instance.">max_jit_obex_free()</a>. Matrix operators will typically require that <a class="el" href="group__maxmopmod.html#ga441ff70d705e1eccff8297437c85e46c" title="Frees additional resources used by a MOP Max wrapper object.">max_jit_mop_free()</a> is called, to free the resources allocated for matrix inputs and outputs. If your object has attached to a registered object for notification via <a class="el" href="group__objectmod.html#ga213166e8beeb29aca36c57cd07c722f1" title="Attaches an object as a client of a named server object for notification.">jit_object_attach()</a>, you should detach from that object in your destructor using <a class="el" href="group__objectmod.html#gaa286218b643371fe28cbe261facd5b21" title="Detaches a client object from a named server object.">jit_object_detach()</a> to prevent invalid memory accesses as the registered object might attempt to notify the memory of a now freed object. Object registration and notification is discussed in further detail in following chapters.</p>
<h2><a class="anchor" id="chapter_jit_maxwrappers_dumpout">
Dumpout</a></h2>
<p>The general purpose outlet, also known as "dumpout", is automatically used by the Max wrapper object when calling attribute getters and several of the standard methods like summary, or getattributes. It is also available for use in any other Max method you want, most easily accessed with the <a class="el" href="group__maxwrapmod.html#ga161cd54f4612d26057e4140b56e14729" title="Sends a message and arguments out the dump outlet.">max_jit_obex_dumpout()</a> function that operates similar to <a class="el" href="group__inout.html#ga12798ee897e01dac21ee547c4091d8a8" title="Use outlet_anything() to send any message out an outlet.">outlet_anything()</a>, but uses the max object pointer rather than the outlet pointer as the first argument. The outlet pointer which has been set in your constructor can be queried with the <a class="el" href="group__maxwrapmod.html#gae0f179c644d50a572a7c159db83490a5" title="Retrieves the Max wrapper object&#39;s dump outlet&#39;s outlet pointer.">max_jit_obex_dumpout_get()</a> function, and used in the standard outlet calls. However, it is recommended for routing purposes that any output through the dumpout outlet is a message beginning with a symbol, rather than simply a bang, int, or float. Therefore, <a class="el" href="group__inout.html#ga12798ee897e01dac21ee547c4091d8a8" title="Use outlet_anything() to send any message out an outlet.">outlet_anything()</a> makes the most sense to use.</p>
<h2><a class="anchor" id="chapter_jit_maxwrappers_inout">
Additional inlets/outlets</a></h2>
<p>To add additional inlets and outlets to your Max external, a few things should be noted. First, if your object is a Matrix Operator, matrix inlets and outlets will be added either through either the high level <a class="el" href="group__maxmopmod.html#gac3eaca207281516b72e81f0dc5f4bf94" title="Initializes default state and resources for MOP Max wrapper class.">max_jit_mop_setup_simple()</a>, or lower level <a class="el" href="group__maxmopmod.html#gaec99be7b60c1cec6a8391097d5008bc6" title="Creates input resources for a MOP Max wrapper object.">max_jit_mop_inputs()</a> or <a class="el" href="group__maxmopmod.html#ga07f044bc4c7fe4380f31e150844948df" title="Creates output resources for a MOP Max wrapper object.">max_jit_mop_outputs()</a> calls. These Matrix Operator functions will be covered in the chapter on Matrix Operators. Secondly, if your object is an MSP object, all signal inlets and outlets must be leftmost, and all non-signal inlets and outlets must be to the right of any single inlets or outlets—i.e. they cannot be intermixed. Lastly, additional inlets should use proxies (covered in detail in the Max/MSP developer documentation) so that your object knows which inlet a message has been received. This is accomplished with the <a class="el" href="group__maxwrapmod.html#ga010c3e4a11d73d6553b7513719a19b7f" title="Creates a new proxy inlet.">max_jit_obex_proxy_new()</a> function. The inlet number is zero based, and you do not need to create a proxy for the leftmost inlet. Inside any methods which need to know which inlet the triggering message has been received, you can use the <a class="el" href="group__maxwrapmod.html#ga2c0d72889d3a89cbabe1001d55c86c3e" title="Retrieves the current inlet number used by inlet proxies.">max_jit_obex_inletnumber_get()</a> function.</p>
<h2><a class="anchor" id="chapter_jit_maxwrappers_attrs">
Max Wrapper Attributes</a></h2>
<p>Sometimes you will need additional attributes which are specific to the Max wrapper class, but are not part of the internal Jitter class. Attributes objects for the Max wrapper class are defined in the same way as those for the Jitter class, documented in the previous chapter. However, these attributes are not added to the Max class with the <a class="el" href="group__classmod.html#ga37e39db544b4d73596da1557e6c7563a" title="Adds an attribute to a class.">jit_class_addattr()</a> function, but instead with the <a class="el" href="group__maxwrapmod.html#ga888aa461197db2e7ef2fb0ae34479c3e" title="Adds an attribute to the Max wrapper class.">max_jit_classex_addattr()</a> function, which takes the classex pointer returned from <a class="el" href="group__maxwrapmod.html#ga773b6e6430d9de2e295419c7f038979e" title="Allocates and initializes special t_max_jit_classex data, used by the Max wrapper...">max_jit_classex_setup()</a>. Attribute flags, and custom getter and setter methods should be defined exactly as they would for the Jitter class. </p>
</div>
		<div id="c74footer">
			<p>Copyright &copy; 2008, <a href="http://www.cycling74.com/">Cycling '74</a></p>
		</div>
	</body>
</html>
